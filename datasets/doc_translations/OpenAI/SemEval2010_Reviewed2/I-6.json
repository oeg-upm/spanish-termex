{
    "id": "I-6",
    "original_text": "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems. Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself. We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1. INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17]. Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)). Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour. Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions. Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action. However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics. Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed. Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents. This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification. Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents. In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems. Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL. These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour. In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1. An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2. A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3. A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs. Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties. The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics. In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics. Section 4 reviews related approaches, and section 5 concludes. 2. FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple. Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states. A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env. We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j]. Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions. The set of all agent functions for i given A and Env is denoted by Gi(Env, A). The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi). This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously. We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g). We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned). We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e. Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid. Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j. The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it. A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated. Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected. Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution. Figure 1 provides a graphic representation of commitment state transitions in this framework. Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . .}, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧). As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1. A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12. He was supposed to make the payment after receiving the toys unless he sent back the toys. We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof. This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire). For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ). We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C). To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true. For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true. Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true. Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true. We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far. It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction. Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour. To provide such grounding, we introduce notions of compliant and expected behaviour. An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments. More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions. To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2. For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status. The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour. For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t . They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense. To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments. Hence, compliant( CS ) specifies what agents are supposed to do. CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments. With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise. The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them). Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process. For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi. In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r). We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type. Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively. Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS. PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning. For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q. All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot. In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS. A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators. In the following, we will assume that agents always adhere to the ACL specification syntactically6 . Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled. At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request. Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space. The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3. A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments). The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j . Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly. In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants). We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag. We describe δ by the transition diagram shown in figure 2. In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state. Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A. For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i). The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour). If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments. Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future. However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments). This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them. However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again. In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again. Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before. We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots). In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4. The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s . What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour. Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step. By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions. Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours. This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time. In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states. In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified. As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents. Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS. In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages. Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution. This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3. ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption). In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active). The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent). Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1. Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O .(pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O .(action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4. Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification. Our framework raises interesting questions regarding further potential properties of DS such as: 1. Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent. While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2. Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims. Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3. Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state). This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4. Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 . If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction. The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5. Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again. Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour. Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6. Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved. Our simple example semantics satisfies all these properties apart from convergence. Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour. While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4. RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences. The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11]. However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation. Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation. Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments. Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions. In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions. However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded. Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5. CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents. Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour. We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication. Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs. We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics. Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable). In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6. REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre. ACL Semantics between Social Commitments and Mental Attitudes. In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen. Expectation-Oriented Analysis and Design. In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001. Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque. Communicative actions for artificial agents. In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault. Elements of a Plan-Based Theory of Speech Acts. Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia. Formalising Agent Mediated Electronic Institutions. In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti. Operational specification of a commitment-based agent communication language. In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles. A New Semantics for the FIPA Agent Communication Language based on Social Attitudes. In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006. IOS Press. [8] F. Guerin and J. Pitt. Denotational Semantics for Agent Communication Languages. In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss. EmpiricalRational Semantics of Agent Communication. In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani. Some Remarks on the Semantics of FIPAs Agent Communication Language. Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß. Interaction is Meaning: A New Model for Communication in Open Systems. In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek. Dialogue acts are rational plans. In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh. Agent communication languages: Rethinking the principles. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh. A social semantics for agent communication languages. In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh. A semantics for speech acts. Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer. Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems. Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge. Verifiable semantics for agent communication languages. In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107",
    "original_translation": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107",
    "original_sentences": [
        "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
        "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
        "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
        "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
        "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
        "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
        "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
        "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
        "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
        "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
        "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
        "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
        "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
        "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
        "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
        "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
        "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
        "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
        "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
        "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
        "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
        "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
        "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
        "Section 4 reviews related approaches, and section 5 concludes. 2.",
        "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
        "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
        "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
        "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
        "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
        "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
        "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
        "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
        "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
        "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
        "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
        "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
        "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
        "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
        "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
        "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
        "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
        "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
        "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
        "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
        "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
        "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
        "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
        "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
        "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
        "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
        "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
        "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
        "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
        "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
        "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
        "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
        "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
        "To provide such grounding, we introduce notions of compliant and expected behaviour.",
        "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
        "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
        "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
        "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
        "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
        "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
        "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
        "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
        "Hence, compliant( CS ) specifies what agents are supposed to do.",
        "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
        "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
        "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
        "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
        "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
        "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
        "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
        "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
        "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
        "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
        "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
        "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
        "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
        "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
        "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
        "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
        "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
        "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
        "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
        "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
        "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
        "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
        "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
        "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
        "We describe δ by the transition diagram shown in figure 2.",
        "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
        "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
        "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
        "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
        "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
        "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
        "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
        "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
        "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
        "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
        "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
        "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
        "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
        "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
        "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
        "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
        "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
        "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
        "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
        "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
        "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
        "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
        "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
        "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
        "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
        "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
        "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
        "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
        "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
        "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
        "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
        "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
        "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
        "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
        "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
        "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
        "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
        "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
        "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
        "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
        "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
        "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
        "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
        "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
        "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
        "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
        "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
        "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
        "Our simple example semantics satisfies all these properties apart from convergence.",
        "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
        "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
        "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
        "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
        "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
        "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
        "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
        "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
        "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
        "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
        "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
        "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
        "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
        "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
        "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
        "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
        "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
        "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
        "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
        "ACL Semantics between Social Commitments and Mental Attitudes.",
        "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
        "Expectation-Oriented Analysis and Design.",
        "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
        "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
        "Communicative actions for artificial agents.",
        "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
        "Elements of a Plan-Based Theory of Speech Acts.",
        "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
        "Formalising Agent Mediated Electronic Institutions.",
        "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
        "Operational specification of a commitment-based agent communication language.",
        "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
        "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
        "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
        "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
        "IOS Press. [8] F. Guerin and J. Pitt.",
        "Denotational Semantics for Agent Communication Languages.",
        "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
        "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
        "EmpiricalRational Semantics of Agent Communication.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
        "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
        "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
        "Interaction is Meaning: A New Model for Communication in Open Systems.",
        "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
        "Dialogue acts are rational plans.",
        "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
        "Agent communication languages: Rethinking the principles.",
        "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
        "A social semantics for agent communication languages.",
        "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
        "A semantics for speech acts.",
        "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
        "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
        "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
        "Verifiable semantics for agent communication languages.",
        "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
    ],
    "translated_text_sentences": [
        "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos.",
        "Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo.",
        "Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1.",
        "INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17].",
        "Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)).",
        "Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento.",
        "La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones.",
        "Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida.",
        "Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL.",
        "Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa.",
        "Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales.",
        "Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL.",
        "En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados.",
        "En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas.",
        "Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL.",
        "Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento.",
        "Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1.",
        "Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2.",
        "Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3.",
        "Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos.",
        "Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades.",
        "El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica.",
        "En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica.",
        "La sección 4 revisa enfoques relacionados, y la sección 5 concluye.",
        "MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple.",
        "Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno.",
        "Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env.",
        "Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j].",
        "Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas.",
        "El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A).",
        "El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi).",
        "Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente.",
        "Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g).",
        "Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones).",
        "Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir.",
        "La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas.",
        "Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j.",
        "El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado.",
        "Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará.",
        "Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado.",
        "Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor.",
        "La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco.",
        "Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧).",
        "En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1.",
        "Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12.",
        "Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes.",
        "Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación.",
        "Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará).",
        "Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ).",
        "Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C).",
        "Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero.",
        "Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero.",
        "Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero.",
        "Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero.",
        "Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora.",
        "Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción.",
        "Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente.",
        "Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado.",
        "Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos.",
        "Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes.",
        "Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2.",
        "Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado.",
        "El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente.",
        "Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t.",
        "Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo.",
        "Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos.",
        "Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer.",
        "CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos.",
        "Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario.",
        "El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos).",
        "En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación.",
        "Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi.",
        "En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r).",
        "También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación.",
        "Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente.",
        "Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS.",
        "Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional.",
        "Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q.",
        "Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción.",
        "En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS.",
        "Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores.",
        "En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL.",
        "El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado.",
        "Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud.",
        "Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio.",
        "Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3.",
        "Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles).",
        "El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j.",
        "Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia.",
        "En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2).",
        "Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag.",
        "Describimos δ mediante el diagrama de transición mostrado en la figura 2.",
        "En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo.",
        "Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A.",
        "Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
        "Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i).",
        "La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme).",
        "Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro.",
        "Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro.",
        "Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos).",
        "Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos.",
        "Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i.",
        "En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más.",
        "En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes.",
        "Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido).",
        "En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4.",
        "El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s.",
        "Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes.",
        "Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso.",
        "Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones.",
        "Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes).",
        "Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo.",
        "En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db).",
        "En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse.",
        "En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes.",
        "Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS.",
        "En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes.",
        "Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS.",
        "Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos).",
        "ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención).",
        "En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos).",
        "El Sexto Internacional.",
        "Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio).",
        "Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1.",
        "No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
        "Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
        "Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4.",
        "Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada.",
        "Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1.",
        "Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente.",
        "Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2.",
        "Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias.",
        "Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3.",
        "Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial).",
        "Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4.",
        "Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente.",
        "Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial.",
        "La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5.",
        "Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente.",
        "Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo.",
        "Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6.",
        "Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas.",
        "Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia.",
        "Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo.",
        "Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4.",
        "TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción.",
        "Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11].",
        "Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa.",
        "La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación.",
        "Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos.",
        "Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones.",
        "En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones.",
        "Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados.",
        "Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5.",
        "CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes.",
        "Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado.",
        "Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación.",
        "Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes.",
        "Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica.",
        "Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable).",
        "En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6.",
        "REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre.",
        "Semántica de la ACL entre compromisos sociales y actitudes mentales.",
        "En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen.",
        "Análisis y Diseño Orientado a la Expectativa.",
        "En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001.",
        "Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque.",
        "Acciones comunicativas para agentes artificiales.",
        "En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault.",
        "Elementos de una teoría basada en planes de actos de habla.",
        "Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia.",
        "Formalizando Instituciones Electrónicas Mediadas por Agentes.",
        "En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti.",
        "Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos.",
        "En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002.",
        "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles.",
        "Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales.",
        "En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006.",
        "IOS Press. [8] F. Guerin y J. Pitt.",
        "Semántica denotacional para lenguajes de comunicación de agentes.",
        "En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504.",
        "ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss.",
        "Semántica Racional Empírica de la Comunicación de Agentes.",
        "En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani.",
        "Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA.",
        "Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß.",
        "La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos.",
        "En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek.",
        "Los actos de diálogo son planes racionales.",
        "En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh.",
        "Lenguajes de comunicación de agentes: Repensando los principios.",
        "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
        "Una semántica social para los lenguajes de comunicación de agentes.",
        "En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh.",
        "Una semántica para actos de habla.",
        "Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer.",
        "Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes.",
        "Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge.",
        "Semántica verificable para lenguajes de comunicación de agentes.",
        "En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107"
    ],
    "error_count": 5,
    "keys": {
        "agent communication language": {
            "translated_key": "lenguaje de comunicación de agentes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of <br>agent communication language</br> (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based <br>agent communication language</br>.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA <br>agent communication language</br> based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs <br>agent communication language</br>.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "INTRODUCTION The field of <br>agent communication language</br> (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Operational specification of a commitment-based <br>agent communication language</br>.",
                "A New Semantics for the FIPA <br>agent communication language</br> based on Social Attitudes.",
                "Some Remarks on the Semantics of FIPAs <br>agent communication language</br>."
            ],
            "translated_annotated_samples": [
                "INTRODUCCIÓN El campo de la investigación del <br>lenguaje de comunicación de agentes</br> (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17].",
                "Especificación operativa de un <br>lenguaje de comunicación de agentes basado en compromisos</br>.",
                "Una nueva semántica para el <br>Lenguaje de Comunicación de Agentes</br> FIPA basada en Actitudes Sociales.",
                "Algunas observaciones sobre la semántica del <br>lenguaje de comunicación de agentes</br> FIPA."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del <br>lenguaje de comunicación de agentes</br> (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un <br>lenguaje de comunicación de agentes basado en compromisos</br>. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el <br>Lenguaje de Comunicación de Agentes</br> FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del <br>lenguaje de comunicación de agentes</br> FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107 ",
            "candidates": [],
            "error": [
                [
                    "lenguaje de comunicación de agentes",
                    "lenguaje de comunicación de agentes basado en compromisos",
                    "Lenguaje de Comunicación de Agentes",
                    "lenguaje de comunicación de agentes"
                ]
            ]
        },
        "dynamic semantics": {
            "translated_key": "semántica dinámica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>dynamic semantics</br> for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes <br>dynamic semantics</br> for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete <br>dynamic semantics</br> together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose <br>dynamic semantics</br> (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with <br>dynamic semantics</br>.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 <br>dynamic semantics</br> 2.4.1 Defining <br>dynamic semantics</br> To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A <br>dynamic semantics</br> (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a <br>dynamic semantics</br> O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces <br>dynamic semantics</br> for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined <br>dynamic semantics</br> as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of <br>dynamic semantics</br> for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "<br>dynamic semantics</br> for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes <br>dynamic semantics</br> for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete <br>dynamic semantics</br> together with examples, and analyse their properties.",
                "In this paper, we propose <br>dynamic semantics</br> (DSs) for ACLs as a solution to these problems.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with <br>dynamic semantics</br>.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 <br>dynamic semantics</br> 2.4.1 Defining <br>dynamic semantics</br> To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request."
            ],
            "translated_annotated_samples": [
                "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una <br>semántica dinámica</br> para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos.",
                "Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de <br>semánticas dinámicas</br> concretas junto con ejemplos, y analizamos sus propiedades.",
                "En este artículo, proponemos una <br>semántica dinámica</br> (DSs) para los ACL como solución a estos problemas.",
                "En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con <br>semántica dinámica</br>.",
                "Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una <br>semántica dinámica</br> para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de <br>semánticas dinámicas</br> concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una <br>semántica dinámica</br> (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con <br>semántica dinámica</br>. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. ",
            "candidates": [],
            "error": [
                [
                    "semántica dinámica",
                    "semánticas dinámicas",
                    "semántica dinámica",
                    "semántica dinámica"
                ]
            ]
        },
        "social reasoning": {
            "translated_key": "razonamiento social",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "commitment-based semantics": {
            "translated_key": "semántica basada en compromisos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "<br>commitment-based semantics</br> [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) <br>commitment-based semantics</br> and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example <br>commitment-based semantics</br> for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of <br>commitment-based semantics</br>, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "<br>commitment-based semantics</br> [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) <br>commitment-based semantics</br> and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example <br>commitment-based semantics</br> for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "Based on a common framework of <br>commitment-based semantics</br>, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour."
            ],
            "translated_annotated_samples": [
                "La <br>semántica basada en compromisos</br>, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones.",
                "Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una <br>semántica basada en compromisos</br> ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud.",
                "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de <br>semántica basada en compromisos</br> para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3.",
                "Basándonos en un marco común de <br>semántica basada en compromisos</br>, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La <br>semántica basada en compromisos</br>, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una <br>semántica basada en compromisos</br> ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de <br>semántica basada en compromisos</br> para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de <br>semántica basada en compromisos</br>, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "state transition system": {
            "translated_key": "sistema de transición de estados",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a <br>state transition system</br> in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the <br>state transition system</br>, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a <br>state transition system</br> in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "What is not ensured by this definition is consistency of the <br>state transition system</br>, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour."
            ],
            "translated_annotated_samples": [
                "Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un <br>sistema de transición de estados</br> en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud.",
                "Lo que no garantiza esta definición es la consistencia del <br>sistema de transición de estados</br>, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un <br>sistema de transición de estados</br> en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del <br>sistema de transición de estados</br>, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "reputation-based adaptation": {
            "translated_key": "adaptación basada en la reputación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • <br>reputation-based adaptation</br>: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • <br>reputation-based adaptation</br>: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption)."
            ],
            "translated_annotated_samples": [
                "ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención)."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107 ",
            "candidates": [],
            "error": [
                []
            ]
        },
        "mutuality of expectation": {
            "translated_key": "mutualidad de expectativas",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "expectation mutuality": {
            "translated_key": "mutualidad de expectativas",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "recovery mechanism": {
            "translated_key": "mecanismo de recuperación",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "non-redundancy": {
            "translated_key": "no redundancia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "<br>non-redundancy</br>: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [
                "<br>non-redundancy</br>: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2."
            ],
            "translated_annotated_samples": [
                "No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2."
            ],
            "translated_text": "Semántica Dinámica para Lenguajes de Comunicación de Agentes Michael Rovatsos Escuela de Informática Universidad de Edimburgo Edimburgo EH8 9LE Reino Unido mrovatso@inf.ed.ac.uk RESUMEN Este artículo propone una semántica dinámica para lenguajes de comunicación de agentes (ACLs) como un método para abordar algunos de los problemas fundamentales asociados con la comunicación de agentes en sistemas multiagentes abiertos. Basado en la idea de proporcionar variantes semánticas alternativas para actos de habla y reglas de transición entre ellos que dependen del comportamiento previo del agente, nuestro marco proporciona una noción mejorada de semántica de fundamentación en la interacción en curso, un mecanismo simple para distinguir entre comportamiento conforme y esperado, y una forma de especificar mecanismos de sanción y recompensa como parte del ACL mismo. Extendemos un marco común para la semántica de ACL basada en compromisos para obtener estas propiedades, discutimos los deseos para el diseño de semánticas dinámicas concretas junto con ejemplos, y analizamos sus propiedades. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente 1. INTRODUCCIÓN El campo de la investigación del lenguaje de comunicación de agentes (ACL) ha estado plagado durante mucho tiempo por problemas de verificabilidad y fundamentación [10, 13, 17]. Las semánticas mentalísticas tempranas que especifican la semántica de los actos de habla en términos de condiciones previas y posteriores contingentes a los estados mentales de los participantes (por ejemplo, [3, 4, 12, 15]) carecen de verificabilidad en cuanto al cumplimiento de los agentes con la semántica pretendida (ya que los estados mentales de los agentes no pueden ser observados en sistemas multiagentes abiertos (MASs)). Incapaces de protegerse contra el abuso por agentes maliciosos, engañosos o con mal funcionamiento, la semántica mentalista es inherentemente poco confiable e inapropiada para su uso en Sistemas Multiagente abiertos, en los cuales agentes con objetivos potencialmente conflictivos podrían deliberadamente explotar las concepciones de semántica de mensajes de sus adversarios para provocar cierto comportamiento. La semántica basada en compromisos, por otro lado, define el significado de los mensajes intercambiados entre agentes en términos de compromisos públicamente observables, es decir, promesas de llevar a cabo un estado de cosas o realizar ciertas acciones. Tales semánticas resuelven el problema de verificabilidad al permitir rastrear el estado de compromisos existentes en cualquier momento dado mensajes y acciones observadas, de modo que cualquier observador pueda, por ejemplo, establecer si un agente ha llevado a cabo una acción prometida. Sin embargo, esto solo se puede hacer a posteriori, lo que crea un problema de fundamentación ya que no se pueden formar expectativas sobre lo que sucederá en el futuro en el momento de emitir o recibir un mensaje puramente en función de la semántica del ACL. Además, esto implica que la especificación semántica no proporciona una interfaz a los mecanismos de deliberación y planificación de los agentes, por lo tanto, no está claro cómo los agentes racionales podrían decidir si suscribirse a una semántica ACL sugerida cuando se implementa. Finalmente, ninguno de los enfoques existentes permite que la ACL especifique cómo responder a una violación de su semántica por parte de agentes individuales. Esto tiene dos implicaciones: en primer lugar, se deja a criterio del agente individual razonar sobre posibles violaciones, es decir, asumir la carga de planificar su propia reacción ante el comportamiento no conforme de otros (por ejemplo, para sancionarlos) y anticipar las reacciones de otros ante su propia mala conducta sin ninguna orientación de la especificación del ACL. En segundo lugar, los enfoques existentes no logran aprovechar las posibilidades de sancionar y recompensar ciertos comportamientos de una manera inherente a la comunicación, modificando el significado futuro de los mensajes emitidos o recibidos por agentes cumplidores/desviados. En este artículo, proponemos una semántica dinámica (DSs) para los ACL como solución a estos problemas. Nuestra noción de DS se basa en la idea muy simple de definir diferentes alternativas para el significado de actos de habla individuales (llamadas variantes semánticas) en una especificación semántica de ACL, y reglas de transición entre estados semánticos (es decir, colecciones de variantes para diferentes actos de habla) que describen el significado actual del ACL. Estos elementos, tomados en conjunto, resultan en una vista de las especificaciones de ACL similar a la de una Máquina de Estados Finitos, donde cada estado individual proporciona una semántica de ACL completa y las transiciones de estado son desencadenadas por el comportamiento del agente observado con el fin de (1) reflejar expectativas futuras basadas en la experiencia de interacción previa y (2) sancionar o recompensar ciertos tipos de comportamiento. Al definir un marco de trabajo de DS para ACL basados en compromisos, este documento realiza tres contribuciones: 1. Una extensión de la semántica de ACL basada en compromisos para proporcionar una noción mejorada de compromisos fundamentales en la interacción de agentes y permitir que las especificaciones de ACL se utilicen directamente para la toma de decisiones racionales basada en la planificación. 2. Una forma sencilla de distinguir entre el comportamiento conforme y esperado con respecto a una especificación de ACL que permite razonar sobre el comportamiento potencial de los agentes puramente desde una perspectiva semántica de ACL. 3. Un mecanismo para especificar cómo evoluciona el significado con el comportamiento del agente y cómo esto puede ser utilizado para describir mecanismos de sanción y recompensa inherentes a la comunicación, esenciales para el diseño de Sistemas Multiagentes abiertos. Además, discutimos los desiderata para el diseño de DS que se pueden derivar de nuestro marco, presentamos ejemplos y analizamos sus propiedades. El resto de este documento está estructurado de la siguiente manera: La Sección 2 presenta un marco formal para la semántica de ACL dinámica. En la sección 3 presentamos un análisis y discusión de este marco y hablamos de los desiderata para el diseño de ACL con semántica dinámica. La sección 4 revisa enfoques relacionados, y la sección 5 concluye. MARCO FORMAL Nuestro marco general para describir el tipo de Sistemas Multiagente en los que estamos interesados es bastante simple. Sea Ag = {1, . . . , n} un conjunto finito de agentes, {Aci}i∈Ag una colección de conjuntos de acciones (donde Aci son las acciones del agente i), A = ×n i=1Aci el espacio de acciones conjunto, y Env un conjunto de estados del entorno. Una ejecución es una secuencia r = e1 a1 → . . . at−1 → et donde ai ∈ A (ai[j] denota la acción del agente j en esta tupla), y ei ∈ Env. Definimos |r| = t, last(r) = et, r[1 : j] es una abreviatura de la subsecuencia inicial de longitud j de r, y escribimos r r para cualquier secuencia r si y solo si ∃j ∈ N.r = r[1 : j]. Escribiendo R(Env, A) para el conjunto de todas las posibles ejecuciones, podemos ver a cada agente i como una función gi: R(Env, A) → Aci que describe las elecciones de acción de los agentes según el historial de estados ambientales anteriores y acciones conjuntas. El conjunto de todas las funciones de agente para i dado A y Env se denota por Gi(Env, A). El entorno (finito, discreto, estacionario, completamente accesible, determinista) está definido por una función transformadora de estado f: Env × A → Env, de modo que la operación de los sistemas para un estado inicial e1 está definida por ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) para todo i ≥ 1 (g es el vector conjunto de funciones gi). Esta definición implica que la ejecución de acciones está sincronizada entre agentes, de modo que el sistema evoluciona a través de una ejecución de rondas donde todos los agentes realizan sus acciones simultáneamente. Denotamos el conjunto de todas las ejecuciones dada una configuración particular de funciones de agente g por R(Env, A, g). Escribimos gi ∼ r donde gi es una función de agente y r una ejecución si y solo si ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (es decir, gi es compatible con r en cada paso de tiempo en lo que respecta a sus acciones). Usamos un lenguaje lógico proposicional estándar L con la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L deunset pending cancelled active violated fulfilled Figura 1: Estados de compromiso y transiciones de estado en el modelo de Fornara y Colombetti: las aristas dibujadas con líneas sólidas indican transiciones provocadas por la comunicación entre agentes, las líneas discontinuas indican acciones físicas de agentes o eventos ambientales que causan transiciones de estado multadas de la manera habitual. Introducimos proposiciones especiales Done(i, a) para cada acción a ∈ ∪n i=1Aci en L para denotar que es cierto que la acción a acaba de ser realizada, extendiendo |= a ejecuciones r de la siguiente manera: r |= ϕ si last(r) |= ϕ r |= Done(i, a) si r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] es decir. La fórmula Done(i, a) es exactamente verdadera para aquellas acciones que formaron parte del vector de acciones conjuntas ai−1 en el estado predecesor, y todas las demás fórmulas que fueron implicadas por el último estado de r siguen siendo válidas. Nuestro modelo implica que cada agente ejecuta exactamente una acción en cada paso de tiempo. 2.1 Compromisos Nuestra noción de compromisos se basa en una ligera variación del marco propuesto por Fornara y Colombetti [6]: Los compromisos entran en existencia como no establecidos, por ejemplo, cuando se emite una solicitud para lograr χ si una cierta condición ϕ se vuelve verdadera de i a j. El compromiso queda pendiente si el deudor j está obligado a cumplirlo, por ejemplo, después de haberlo aceptado. Un compromiso pendiente se activará si su condición ϕ se vuelve verdadera, y si χ se lleva a cabo en ese caso, se cumplirá; de lo contrario, se violará. Los compromisos pueden ser cancelados en diferentes situaciones, por ejemplo, si un compromiso no establecido es rechazado. Además, los eventos ambientales pueden hacer que χ se convierta en verdadero, en cuyo caso el compromiso se cumple sin la contribución del deudor. La Figura 1 proporciona una representación gráfica de las transiciones de estado de compromiso en este marco. Además de una notación ligeramente diferente utilizada para mantener un historial más detallado de compromisos, los extenderemos para que también contengan una condición de desactivación ψ aparte de ϕ (que llamamos condición de activación) que provoca que cualquier compromiso se cancele si se vuelve verdadero. Más precisamente, L contiene proposiciones atómicas P = {p, q, ...}, los conectivos habituales ∨ y ¬ (con abreviaturas ⇒ y ∧). En cuanto a la semántica, una función de interpretación de funciones I: P × Env → { , ⊥} asigna un valor de verdad a cada proposición en cada estado ambiental, y la relación de implicación e |= ϕ para e ∈ Env y ϕ ∈ L se define de forma inductiva: e |= ϕ si ϕ ∈ P e I(ϕ, e) = ; e |= ¬ϕ si e |= ϕ; e |= ϕ ∨ ψ si e |= ϕ o e |= ψ. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 101 D: CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A: CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F: CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V: CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Tabla 1: Reglas de procesamiento de compromisos ambientales para la ejecución actual r con |r| = t Definición 1. Un compromiso es una estructura ι, s: χ ⊕ ϕ ψ i→j t donde - ι es un identificador de compromiso único, - s denota el estado del compromiso (cualquiera de no establecido, pendiente, activo, violado, cumplido o cancelado, abreviado por la inicial respectiva), - i es el deudor, j es el acreedor, - χ ∈ L es el debitum (es decir, la proposición que i se compromete a hacer verdadera frente a j), - ϕ, ψ ∈ L son las condiciones de activación/desactivación, - y t es el instante (en una ejecución) en el que este compromiso entró en su estado actual s. Como ejemplo, x, v: received(5, $500) ⊕ received(3, juguetes) returned(3, juguetes) 3→5 12 denota que el agente 3 violó el compromiso x hacia el agente 5 de pagarle $500 en el paso de tiempo 12. Se suponía que él haría el pago después de recibir los juguetes a menos que devolviera los juguetes. Introducimos condiciones de desactivación para poder revocar por completo compromisos existentes: Devolver el dinero no constituye el cumplimiento del contrato original, sino más bien su anulación. Esto nos proporciona la capacidad de definir condiciones de validez utilizando ϕ y ψ, lo cual es útil para cosas como plazos para compromisos no establecidos (si no recibo una respuesta dentro de 3 pasos de tiempo, mi solicitud expirará). Por brevedad, a veces omitimos índices o elementos de contenido cuando son claros en el contexto (en particular, a menudo escribimos Γ para el contenido χ ⊕ ϕ ψ). Escribimos C para el conjunto de todos los compromisos posibles y denotamos conjuntos de compromisos (llamados almacenes de compromisos) por CS ∈ ℘fin (C). Para manejar los efectos de eventos ambientales y acciones de agentes en una tienda de compromisos CS, la tabla 1 introduce cinco reglas de transición de compromisos que son ejecutadas en cada paso de tiempo por el sistema o cualquier observador que pretenda aclarar el estado de los compromisos existentes en el orden mostrado: la regla de desactivación D es la primera en activarse y cancela cualquier compromiso no establecido, pendiente o activo si ψ se vuelve verdadero. Para los compromisos pendientes restantes, la regla de activación A describe cómo se vuelven activos si ϕ se vuelve verdadero. Se debe tener en cuenta que cuando ϕ es verdadero en estados posteriores, verificamos si 2 Para evitar problemas con especificaciones de compromiso contradictorias (por ejemplo, cuando tanto ϕ como ψ se vuelven verdaderos), otorgamos estricta prioridad a la desactivación sobre la activación. este compromiso activo está contenido en CS para evitar duplicados (esto se debe a que mantenemos un registro completo del historial de compromisos por razones que se aclararán a continuación).3 La regla S se ocupa de la serendipia, es decir, el cumplimiento de compromisos no provocados por el respectivo agente, sino simplemente por cambios ambientales que hicieron que el débito fuera verdadero. Finalmente, las reglas de cumplimiento/violación F/V registran si la acción realizada por el deudor en el paso anterior (r |= Hecho(i, a)) ha causado que el débito χ de cualquier compromiso que se activó en el paso anterior se convierta en verdadero. Solo necesitamos considerar aquellos compromisos que se activaron en el paso anterior t − 1, ya que podemos verificar su estado de cumplimiento en t. Esta verificación depende de un predicado dependiente del dominio causes(a, χ) que no hemos mencionado hasta ahora. Debería ser cierto si se supone que la acción a va a producir χ, y delinea la noción social existente de lo que constituye un intento razonable de lograr χ en el contexto dado (su definición puede variar desde requerir que χ se haya logrado realmente hasta permitir cualquier acción a que no necesariamente resulte en ¬χ). 2.2 Fundamentación En los enfoques de Fornara y Colombetti y similares, el estado de los compromisos es verificable, pero no están fundamentados en expectativas sobre la interacción. Tales semánticas (similares en estilo a lo que acabamos de definir en términos de reglas de actualización de CS) nos dicen qué compromisos existen y en qué estado se encuentran, pero no cómo esto afectará el comportamiento futuro del agente. Para proporcionar tal base, introducimos nociones de comportamiento conforme y esperado. Un agente se comporta de acuerdo con sus compromisos si siempre cumple de inmediato con todos los compromisos activos. Más precisamente, se dice que el comportamiento del agente i es conforme con CS en el tiempo t si y solo si ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS. Aunque simple, esta definición de conformidad no es muy útil porque impone restricciones en las CS pero no en las funciones reales de los agentes. Para lograr esto, en su lugar podemos utilizar el contenido del CS para restringir el rango de funciones de agente admisibles a aquellas que estén de acuerdo con él utilizando la siguiente definición: Definición 2. Para cualquier ejecución r ∈ R(Env, A), sea CS(r) el conjunto de compromisos que ha resultado de la ejecución de r asumiendo que ciertas acciones (incluyendo mensajes) crean compromisos o cambian su estado. El conjunto de funciones de agente compatibles con respecto a una tienda de compromisos CS es 3. Si bien los identificadores de compromiso afectan negativamente la legibilidad de nuestra notación, son necesarios aquí para determinar de manera única qué compromiso pendiente se activa. 102 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) define como cumpliente (CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ Lo que esta definición captura es la siguiente caracterización de una función de agente cumpliente gi: para todas las ejecuciones r en las que la función de agente gi contribuye: si r ha creado un compromiso pendiente con respecto a χ, entonces si este compromiso se vuelve activo al final de alguna extensión r de r en el futuro, gi hará que el agente realice una acción a que cause χ.4 A continuación, para atender la anticipación de un comportamiento no cumpliente, necesitamos introducir una noción de comportamiento esperado que anule el comportamiento cumpliente. Para esto, introducimos un segundo tipo de compromisos que llamaremos expectativas para evitar confusiones y distinguirlos de los compromisos ordinarios (ahora llamados normativos) mediante el uso de paréntesis redondos (ι, s : Γ)i→j t. Se les trata exactamente igual que otros compromisos en términos de las reglas introducidas anteriormente, pero expresan lo que se espera que haga el agente (en el sentido no normativo de una predicción objetiva del comportamiento) en lugar de lo que se supone que debe hacer en un sentido normativo. Para definir las nociones que necesitamos a continuación, introducimos los siguientes constructos: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simplemente restringe el almacén de compromisos a todos los compromisos normativos. Por lo tanto, el cumplimiento (CS) especifica lo que se supone que los agentes deben hacer. CS, por otro lado, anula todos los elementos de compromiso normativo en CS para los cuales también existe una expectativa, es decir, las expectativas tienen prioridad sobre los compromisos normativos. Con esto, podemos definir el comportamiento esperado como esperado(CS) := cumplimiento(CS) es decir, un comportamiento que se adhiere a las expectativas cuando estas existen y es conforme en caso contrario. El tratamiento separado y paralelo del comportamiento conforme y esperado tiene dos ventajas: en primer lugar, podemos responder al comportamiento conforme inesperado, es decir, cuando esperamos que alguien no cumpla con sus compromisos, aún podemos responder si lo hacen (y, por ejemplo, recuperar la confianza en ellos). En segundo lugar, podemos adaptarnos a una variedad de reglas para traducir tiendas de compromisos a eventos futuros reales que un agente de razonamiento puede utilizar en su proceso de planificación. Para los propósitos de este documento, asumiremos que los agentes basan sus predicciones sobre otros en el comportamiento esperado si es diferente del comportamiento conforme, y que predicen el comportamiento conforme en caso contrario. 4 Observa la cuantificación en esta definición: la propiedad debe cumplirse para cada ejecución que dio lugar a ι y es compatible con gi. En particular, esto debe ser independiente de cualquier parte de la historia (por ejemplo, acciones de otros agentes y estados previos del entorno) dada CS(r). También cuantificamos sobre todas las extensiones r de r, es decir, el cumplimiento del compromiso debe ocurrir si las condiciones apropiadas surgen independientemente de otros factores. 2.3 Semántica de ACL Estática La Tabla 2 muestra un ejemplo de un pequeño fragmento de una semántica de ACL definida utilizando nuestro marco de trabajo, con dos definiciones alternativas (AC y AC2) para la semántica del tipo de mensaje de aceptación. Cada uno de los llamados operadores de diálogo (similares a los esquemas de acción de planificación de IA) se define utilizando la notación gráfica p a q donde p, a y q son esquemas para precondiciones, mensajes (de un cierto tipo) y postcondiciones, respectivamente. Las precondiciones determinan si un esquema de acción es aplicable en una situación determinada o no, y contienen fórmulas de L y/o restricciones sobre el contenido actual de CS. Las PostCondiciones contienen cambios en la base de conocimientos y modificaciones en CS, es decir, se interpretan como listas de agregar/eliminar en la planificación de IA tradicional. Para cualquier operador o = p, a, q definimos pre(o) = p, acción(o) = a y post(o) = q. Todos los elementos de un operador de diálogo pueden contener variables lógicas en sus pre y postcondiciones, y variables de emisor/receptor/contenido en la ranura de acción. En nuestro fragmento de ejemplo, el operador RQ para solicitudes crea un compromiso no establecido con un identificador ι nuevo y una marca de tiempo actual (asumimos que r |= time(t) ⇔ |r| = t, y que existe un tiempo de sistema global que puede ser inspeccionado por todos los agentes), y AC/RJ añaden un equivalente pendiente/cancelado de ι a CS. Un fragmento que consiste en {RQ, RJ, AC} es equivalente a la semántica estándar de los respectivos tipos performativos definidos en [6].5. Tenga en cuenta que nuestros operadores solo contienen precondiciones y postcondiciones objetivamente verificables, y si los agentes desean cumplir con ello, deben cumplir con estos operadores. En lo siguiente, asumiremos que los agentes siempre siguen la especificación sintáctica del ACL. El uso de AC2 en lugar de AC nos permite aprovechar el poder de nuestra distinción entre el comportamiento conforme y esperado, expresando que no confiamos en que i se adhiera a la semántica normal de aceptar: su postcondición especifica que expected(CS) no se limita a comportamientos que cumplirán el compromiso, sino que sugiere que este ha sido cancelado. Al mismo tiempo, mantenemos el compromiso normativo de que ι está pendiente para que su comportamiento se vea como conforme (CS) si se desvía de nuestra expectativa (pesimista) y hace lo correcto en su lugar. 2.4 Semántica Dinámica 2.4.1 Definiendo la Semántica Dinámica Para definir la SD para ACLs, introducimos ahora un sistema de transición de estados en el que cada estado especifica una semántica basada en compromisos ordinarios (estáticos) y un rango de pares de agentes para los cuales se asume que estas semánticas se aplican. Nota que permitimos solicitar cosas idénticas antes de recibir una respuesta y responder varias veces a la misma solicitud. Se pueden introducir condiciones adicionales simples para evitar estos efectos, los cuales omitimos aquí por falta de espacio. Lo mismo ocurre con restricciones adicionales para gestionar problemas de flujo de control en diálogos reales (por ejemplo, el turno de habla). Esto significa que, para una sustitución de variables adecuada ϑ, r |= pre(o)ϑ se cumple cuando o se aplica en r y que CS(r) se transforma de acuerdo a post(o)ϑ después de su aplicación. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 103 RQ: tiempo(t), nuevo(ι) solicitud(i, j, ι: Γ) CS ← CS ∪ { ι, u: Γ i→j t } RJ: ι, u: Γ j→i t ∈ CS, tiempo(t) rechazar(i, j, ι: Γ) CS ← CS ∪ { ι, c: Γ i→j t } AC: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } AC2: ι, u: Γ j→i t ∈ CS, tiempo(t) aceptar(i, j, ι: Γ) CS ← CS ∪ { ι, p: Γ i→j t } ∪ {(ι, c: Γ)i→j t } Tabla 2: Ejemplo de semántica basada en compromisos para un pequeño fragmento de ACL ι, v: Γ i→j ∈ CS: {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v: Γ i→j t ∈ CS ∃ ι, f: Γ i→j t ∈ CS.t > t: {(i, ∗)} Figura 2: Diagrama de transición de estados similar a una Máquina de Estados Finitos que describe la relación Δ en una especificación de DS Definición 3. Una semántica dinámica (DS) es una estructura O, S, s0, Δ donde - O = {o1, o2, . . . , on} un conjunto de operadores de diálogo, - S ⊆ ℘(O) es un conjunto de estados semánticos especificados como subconjuntos de operadores de diálogo que son válidos en este estado, - s0 ∈ S es el estado semántico inicial, - y la relación de transición Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S define las transiciones sobre S desencadenadas por condiciones expresadas como elementos de ℘(C) (C es el conjunto de todos los compromisos posibles). El significado de una transición (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ es el siguiente: Supongamos una función act : Ag × Ag → S que especifica que la semántica de los operadores en s se aplica a los mensajes enviados de i a j. Entonces, si CS ∈ c (es decir, el CS actual coincide con la restricción c dada como una colección de posibles CS) esto desencadenará una transición al estado s para todos los pares de agentes en {(i1, j1), . . . , (in, jn)} para los cuales la restricción fue satisfecha y actualizará act en consecuencia. En otras palabras, el acto de mapeo rastrea qué versión de la semántica es válida para qué pares de socios de comunicación a lo largo del tiempo. 2.4.2 Ejemplo Para ilustrar estos conceptos, consideremos el siguiente ejemplo: Sea O = {RQ, RJ, AC, AC2}, S = {s0, s1} donde s0 = {RQ, RJ, AC} y s1 = {RQ, RJ, AC2}, es decir, hay dos estados posibles de la semántica que solo difieren en su definición de aceptar (llamamos variantes semánticas a versiones alternativas de un único operador de diálogo como AC y AC2). Suponemos que inicialmente act(i, j) = s0 para todos los agentes i, j ∈ Ag. Describimos δ mediante el diagrama de transición mostrado en la figura 2. En este diagrama, las aristas llevan etiquetas c : A donde c es una restricción sobre el contenido de CS seguido de una descripción del conjunto de pares de agentes A para los cuales la transición debe realizarse al estado objetivo. Al escribir A(s) = act−1 (s) para el llamado rango de pares de agentes para los cuales s está activo, usamos variables de agente como i y j y el símbolo comodín ∗ que puede ser vinculado a cualquier agente en A(s), y asumimos que esta vinculación se extiende a las descripciones de A. Por ejemplo, el borde con etiqueta ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} se puede interpretar de la siguiente manera: seleccionar todos los pares (i, j) ∈ A(s0) para los cuales aplica ι, v : Γ i→j ∈ CS (es decir, i ha violado algún compromiso hacia j) y hacer que s1 sea válido para el conjunto de agentes {(i, k)|k ∈ A(s0)} ∪ {(j, i)}. Esto significa que para todos los agentes i que han mentido, s1 se activará para (i, j) donde j ∈ A(s0) y s1 también se activará para (j, i). La forma en que funciona el DS del diagrama anterior es la siguiente: inicialmente, la semántica establece (para cada agente i) que cumplirán cualquier compromiso de manera veraz (el uso de AC garantiza que el comportamiento esperado sea equivalente al comportamiento conforme). Si un agente i viola un compromiso una vez, entonces s1 se activará para i hacia todos los demás agentes, de modo que no esperen que i cumpla con ningún compromiso futuro. Además, esto también se aplicará a (j, i) para que el culpable i no espere que el agente engañado j cumpla sus promesas hacia i en el futuro. Sin embargo, esto no afectará las expectativas con respecto a sus interacciones con i por agentes que no sean i (es decir, aún no tienen derecho a violar sus propios compromisos). Esto refleja la idea de que solo los agentes que han sido engañados tienen permitido transgredir solo contra aquellos agentes que transgredieron contra ellos. Sin embargo, si alguna vez cumple con algún compromiso nuevamente (después de la última violación, esto está garantizado por la compleja restricción utilizada como etiqueta para la transición de s1 a s0), la semántica en s0 volverá a ser válida para i. En este caso, sin embargo, s1 seguirá siendo válido para el par (j, i), es decir, el agente j recuperará la confianza en i pero no se puede esperar que vuelva a ser confiable hacia i nunca más. En lugar de sugerir que este es un mecanismo inherente a la comunicación particularmente útil para sancionar y recompensar tipos específicos de comportamiento, este ejemplo sirve para ilustrar la expresividad de nuestro marco y el tipo de distinciones que nos permite hacer. 2.4.3 Semántica Formal La semántica de un DS puede definirse de forma inductiva de la siguiente manera: Permita que CS(r) denote el contenido de la tienda de compromisos después de la ejecución r como antes. Usamos la notación A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A para denotar el conjunto de agentes que deben ser movidos de s a s debido a la regla de transición δ = (s, c, A, s) ∈ Δ dada CS, donde CS|i,j es el conjunto de compromisos que mencionan a i y/o j (en sus espacios de emisor/receptor/contenido). En otras palabras, A(δ, CS) contiene aquellos pares de agentes que (i) son mencionados en los compromisos cubiertos por la restricción c, (ii) están contenidos en el rango de s, y (iii) están explícitamente listados en A como pertenecientes a esos pares de agentes que deberían ser afectados por la transición δ. 104 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Definición 4. El estado de una semántica dinámica O, S, s0, Δ después de la ejecución r con predecesor inmediato r está definido como un mapeo actr de la siguiente manera: 1. r = ε: actε(i, j) = s0 para todo i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s si ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else Esto mantiene la propiedad act−1 r (s) = act−1 r (s) − A(δ, CS(r )), que especifica que los pares de agentes que se moverán de s a s se eliminan del rango de s y se agregan al rango de s. Lo que no garantiza esta definición es la consistencia del sistema de transición de estados, es decir, asegurarse de que el estado sucesor semántico esté identificado de manera única para cualquier estado del almacén de compromisos y estado previo, de modo que cada par de agentes solo se le asigne un estado activo en cada paso, es decir, actr es en realidad una función para cualquier r. Integración Una vez que el DS en sí mismo ha sido especificado, necesitamos integrar los diferentes componentes de nuestro marco para monitorear la dinámica de nuestra semántica de ACL y sus implicaciones para el comportamiento esperado de los agentes. Comenzando con una tienda de compromisos CS inicialmente vacía y un estado semántico inicial s0 tal que actε(i, j) = s0 para cualquier par de agentes i y j, el agente (u observador externo) observa (un subconjunto parcial de) todo lo que se comunica en el sistema en cada paso. Al aplicar las reglas de transición de compromiso (D, A, S, F y V), podemos actualizar CS en consecuencia, ignorando cualquier mensaje observado enviado de i a j que no coincida sintácticamente con el conjunto de operadores de diálogo definidos en actr(i, j) para una ejecución actual r. Después de que se haya realizado esta actualización para todos los mensajes observados y acciones en este ciclo, que no deben depender del orden de los mensajes, podemos calcular para cualquier mensaje enviado de i a j el nuevo valor de actr(i, j) dependiendo de las reglas de transición semántica del DS si r es la ejecución sucesora de r. Con esto, podemos determinar cuál será el comportamiento conforme y esperado de los agentes bajo estas nuevas condiciones. Por lo tanto, un agente puede utilizar información sobre el comportamiento esperado en sus propios procesos de planificación al asumir que todos los agentes involucrados exhibirán sus comportamientos esperados (en lugar de solo obedientes). Esta predicción no siempre será más precisa que bajo la semántica ACL normal (estática), pero dado que es de conocimiento común que los agentes asumen que el comportamiento esperado ocurrirá (y, en virtud de la especificación DS-ACL, tienen el derecho de hacerlo), la mayoría de las especificaciones razonables de ACL dinámicas harán disposiciones para garantizar que es más seguro asumir el comportamiento esperado en lugar de completamente compatible si desean promover su uso por los agentes. Una forma de garantizar esto es requerir que ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) para que no se puedan cumplir dos restricciones relacionadas con las aristas salientes de s por CS al mismo tiempo. En algunos casos esto puede ser demasiado grueso, sería suficiente que las restricciones fueran mutuamente excluyentes para el mismo par de agentes en cualquier momento, pero esto tendría que ser verificado para un DS individual caso por caso. Esto es válido para nuestros operadores, ya que sus pre y postcondiciones nunca conciernen o afectan a compromisos que no involucren tanto a i como a j, evitando cualquier conexión con terceros nos ayuda a mantener la actualización de CS independiente del orden en que se procesan las observaciones. Problemas de Complejidad El principal inconveniente de nuestro enfoque es la complejidad espacial de la especificación dinámica de ACL: Si d es el número de operadores de diálogo en un idioma y b es el número máximo de variantes semánticas de un solo operador de diálogo dentro de este idioma, la especificación de DS tendría que especificar estados O(db). En muchos casos, sin embargo, la mayoría de los actos de habla no tendrán diferentes variantes (como RQ y RJ en nuestro ejemplo) y esto puede reducir significativamente el número de estados de DS que deben especificarse. En cuanto al comportamiento en tiempo de ejecución de nuestro mecanismo de procesamiento de semántica, podemos asumir que se envían/realizan n mensajes/acciones en cada paso de procesamiento en un sistema con n agentes. Cada regla de procesamiento de compromisos (D, S, etc.) debe realizar un recorrido por el contenido de CS. En el peor de los casos, cada compromiso originalmente creado (de los cuales puede haber nt después de t pasos) podría haberse convertido inmediatamente en pendiente, activo y violado (lo cual no requiere ninguna acción física adicional, por lo que cada agente puede crear un nuevo compromiso en cada paso). Por lo tanto, si algún agente crea un nuevo compromiso en cada paso sin nunca cumplirlo, esto resultará en que el tamaño total de CS esté en O(nt). En cuanto a las transiciones de estado semántico, hasta n diferentes pares de agentes podrían ser afectados en una sola iteración por n mensajes. Suponiendo que la verificación de las restricciones de CS para estas transiciones tomaría O(nt), esto resulta en un tiempo total de actualización de O(n2 t) para rastrear la evolución de DS. Este límite se puede reducir a O(n2) si se hace una suposición de cuasi-estacionariedad al limitar la ventana de compromisos anteriores que se están considerando al verificar las restricciones de transición a un tamaño constante (y así obtener un conjunto finito de posibles almacenes de compromisos). ANÁLISIS Y DISCUSIÓN La principal fortaleza de nuestro marco de trabajo es que nos permite explotar los tres elementos principales de la reciprocidad: • Adaptación basada en la reputación: El DS adapta las expectativas hacia el agente i de acuerdo con su comportamiento previo modificando el estado semántico para reflejar mejor este comportamiento (basado en la suposición de que se repetirá en el futuro). • Mutualidad de expectativas: El DS adapta las expectativas hacia el comportamiento de js de acuerdo con su comportamiento previo hacia j para reflejar mejor la respuesta de js al comportamiento observado de i (permitiendo en particular que j se comporte hacia i como i se comportó hacia j anteriormente). • Mecanismos de recuperación: El DS permite a i volver a un estado semántico anterior después de deshacer un cambio en las expectativas mediante un cambio posterior y posterior en el comportamiento (por ejemplo, a través de la redención). En sistemas abiertos en los que no podemos hacer cumplir ciertos comportamientos, estos son efectivamente los únicos medios disponibles para sanciones y recompensas indirectas. Esto es en realidad solo un límite inferior en la complejidad para el procesamiento de compromisos, que podría empeorar si está dominado por la complejidad de verificar la implicación |=; sin embargo, esto también sería válido para una semántica de ACL estática. Por ejemplo, esto podría ser útil si queremos descartar compromisos cuyo estado fue modificado por última vez hace más de k pasos de tiempo (esto es problemático, ya que podría obligarnos a descartar ciertos compromisos no establecidos/pendientes antes de que se vuelvan pendientes/activos). El Sexto Internacional. Hay dos dimensiones adicionales que afectan a los mecanismos de sanción y recompensa basados en DS y son ortogonales a lo anterior: una se refiere al carácter de los cambios de estado semántico (es decir, si es una recompensa o un castigo), y la otra al grado de adaptación (los mecanismos basados en la reputación, por ejemplo, no necesitan reflejar de manera realista el comportamiento del culpable, sino que pueden utilizar en su lugar la estigmatización inmediata (exagerada) de agentes como un elemento disuasorio). Aunque simple, nuestro ejemplo de DS descrito anteriormente hace uso de todos estos aspectos, y además de la consistencia y la completitud, también satisface algunas otras propiedades útiles: 1. No redundancia: Ningún par de operadores de diálogo en O debe tener precondiciones y postcondiciones idénticas, y cualquier par de variantes semánticas de un operador debe diferir en términos de precondiciones y/o postcondiciones: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (acción(o) = acción(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2. Alcanzabilidad de todos los estados semánticos: Cualquier restricción que cause una transición debe ser satisfacible en principio al usar los operadores de diálogo y acciones físicas proporcionados: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3. Distinción entre el comportamiento esperado y el cumplimiento: El contenido de las expectativas debe diferir del de los compromisos normativos al menos para algunas variantes semánticas (dando lugar a expectativas no conformes para algunas ejecuciones): ∃r ∈ R(Env, A) .esperado(CS(r)) = cumplido(CS(r)) 4. Realizabilidad de cumplimiento/desviación: Debe ser posible para los agentes en principio cumplir con compromisos normativos o desviarse de ellos en principio: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ Si bien no son absolutamente esenciales, estos constituyen deseos para el diseño de DS-ACLs ya que contribuyen a la simplicidad y claridad de una especificación semántica dada. Nuestro marco plantea preguntas interesantes sobre posibles propiedades adicionales de DS, tales como: 1. Respeto por la autonomía de compromiso: La semántica no debe permitir que un agente cree un compromiso pendiente para otro agente o viole un compromiso en nombre de otro agente. Si bien en algunos casos algunos agentes deberían poder hacer cumplir compromisos sobre otros, esto debería evitarse en general para garantizar la autonomía del agente. 2. Evitando la inconsistencia en el compromiso: La ACL debe o bien prohibir el compromiso con acciones o creencias contradictorias, o al menos proporcionar operadores para rectificar tales afirmaciones contradictorias. Bajo compromisos contradictorios, ningún comportamiento posible puede ser conforme, por lo que depende del diseñador decidir en qué medida esto debería permitirse. 3. Juicio imparcial: La predicción del comportamiento esperado no debe desviarse de la predicción del comportamiento conforme si hasta ahora no se ha observado un comportamiento desviado (en particular, esto debe cumplirse para el estado semántico inicial). Esto puede que no siempre sea deseable, ya que la desconfianza inicial es necesaria en algunos sistemas, pero aumenta las posibilidades de que los agentes acepten participar en la comunicación. 4. Convergencia: El estado semántico de cada uno de los operadores de diálogo permanecerá estable después de un número finito de transiciones, independientemente del comportamiento adicional del agente. Si esta propiedad se cumple, esto implicaría que los agentes pueden dejar de rastrear las transiciones de estado semántico después de cierta cantidad de interacción inicial. La ventaja de esto es la reducción de la complejidad, lo cual, por supuesto, implica renunciar a la adaptabilidad. 5. Perdón: Después de una desviación inicial, un comportamiento posteriormente conforme de un agente debería llevar a un estado semántico que predice un comportamiento conforme de ese agente nuevamente. Aquí, tenemos que equilibrar la cautela con la provisión de incentivos para reanudar el comportamiento cooperativo. Confiar en un agente hace que otros sean vulnerables a la explotación; sin embargo, poner en una lista negra a un agente para siempre podría llevar a que dicho agente mantenga su comportamiento impredecible y potencialmente malicioso. 6. Igualdad: A menos que esto sea requerido por restricciones específicas del dominio, las mismas dinámicas de semántica deberían aplicarse a todas las partes involucradas. Nuestra semántica de ejemplo simple satisface todas estas propiedades excepto la convergencia. Muchas de las propiedades mencionadas anteriormente son discutibles, ya que debemos equilibrar la precaución con la provisión de incentivos para el comportamiento cooperativo. Si bien no podemos hacer declaraciones generales aquí sobre el diseño óptimo de DS-ACL, nuestro marco proporciona las herramientas para probar y evaluar el rendimiento de diferentes mecanismos de sanción y recompensa inherentes a la comunicación (es decir, reglas sociales que no presuponen la capacidad de dirigir castigos o recompensas a través de acciones físicas) en aplicaciones del mundo real. 4. TRABAJO RELACIONADO La razón basada en expectativas sobre la interacción fue propuesta por primera vez en [2], considerando la evolución de las expectativas descritas como expectativas probabilísticas de secuencias de comunicación y acción. Los mismos autores sugirieron un marco más general para la semántica de la comunicación basada en expectativas [9], y argumentan a favor de una visión consecuencialista de la semántica que se basa en definir el significado de las enunciaciones en términos de sus consecuencias esperadas y actualizar estas expectativas con nuevas observaciones [11]. Sin embargo, su enfoque no utiliza una noción explícita de compromisos que en nuestro marco de trabajo media entre la comunicación y el fundamento basado en el comportamiento, y proporciona una clara distinción entre una noción normativa de cumplimiento y una noción más empírica de expectativa. La fundamentación para la semántica de ACL (lingüística computacional) ha sido investigada en [7], donde la información fundamentada es vista como información que es públicamente expresada y aceptada como verdadera por todos los agentes que participan en una conversación. Al igual que [1] (que basa la noción de expresión pública en roles en lugar de estados internos de agentes), la principal preocupación de estos autores es proporcionar una base verificable para determinar la semántica de los estados mentales expresados y los compromisos. Aunque nuestro marco se preocupa únicamente por el compromiso con el logro de estados de cosas en lugar de la información intercambiada, en cierto sentido, DS proporciona una visión alternativa al especificar lo que sucederá si se violan las suposiciones en las que se basa lo que es públicamente aceptado. En un sentido no trivial, es decir, cuando algunas transiciones iniciales son posibles en principio. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07). Nuestro marco de trabajo también está relacionado con métodos deontológicos para la especificación de obligaciones, normas y sanciones. En esta área, [16] es el único marco del que tenemos conocimiento que considera obligaciones dinámicas, normas y sanciones. Sin embargo, como hemos descrito anteriormente, solo utilizamos la evolución semántica como mecanismo de sanción y recompensa, es decir, a diferencia de este trabajo, no asumimos que los agentes puedan ser directamente castigados o recompensados. Finalmente, la estructura tipo FSM de los sistemas de transición de DS en combinación con la comunicación entre agentes recuerda al trabajo sobre instituciones electrónicas [5], pero allí el enfoque se centra en proporcionar diferentes medios de comunicación en diferentes escenas del proceso de interacción (por ejemplo, diferentes protocolos para diferentes fases de la interacción basada en el mercado), mientras que nosotros nos enfocamos en diferentes variantes semánticas que se deben utilizar en el mismo contexto de interacción. 5. CONCLUSIÓN Este artículo introduce la semántica dinámica para las ACL como un método para abordar algunos problemas fundamentales de la comunicación entre agentes en sistemas abiertos, siendo la idea subyacente simple que diferentes cursos de comportamiento de agentes pueden dar lugar a diferentes interpretaciones del significado de los mensajes intercambiados entre agentes. Basándonos en un marco común de semántica basada en compromisos, presentamos una noción de fundamentación para compromisos basada en nociones de comportamiento conforme y esperado. Luego definimos la semántica dinámica como sistemas de transición de estados sobre diferentes estados semánticos que pueden ser vistos como diferentes versiones de la semántica de ACL en el sentido tradicional, y pueden asociarse fácilmente con una visión basada en la planificación del razonamiento sobre la comunicación. Por lo tanto, nuestro enfoque se centró en la simplicidad y en proporcionar mecanismos para rastrear la evolución semántica de una manera concreta y algorítmica para garantizar la aplicabilidad a muchos diseños de agentes diferentes. Discutimos las propiedades de nuestro marco, mostrando cómo puede ser utilizado como un mecanismo poderoso inherente a la comunicación para recompensar y sancionar el comportamiento de agentes en sistemas abiertos sin comprometer la autonomía de los agentes, discutimos su integración con los procesos de planificación de agentes, problemas de complejidad y presentamos una lista de deseos para el diseño de ACL con dicha semántica. Actualmente, estamos trabajando en especificaciones completas de la semántica dinámica para lenguajes más complejos y en la extensión de nuestro enfoque a la semántica mentalista, donde vemos las afirmaciones sobre estados mentales como compromisos respecto a las implicaciones racionales de estos estados mentales (un ejemplo simple de esto es que un agente se compromete a abandonar una intención aparente que está afirmando mantener si resulta ser inalcanzable). En este contexto, estamos particularmente interesados en mecanismos apropiados para detectar y responder a la mentira mediante el interrogatorio de agentes sospechosos y obligándolos a comprometerse públicamente con (conjuntos de) estados mentales, sancionándolos cuando estos son inconsistentes con sus acciones. 6. REFERENCIAS [1] G. Boella, R. Damiano, J. Hulstijn y L. van der Torre. Semántica de la ACL entre compromisos sociales y actitudes mentales. En Actas del Taller Internacional sobre Comunicación de Agentes, 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß y K. F. Lorentzen. Análisis y Diseño Orientado a la Expectativa. En Actas del 2º Taller sobre Ingeniería de Software Orientada a Agentes, LNCS 2222, 2001. Springer-Verlag, Berlín. [3] P. R. Cohen y H. J. Levesque. Acciones comunicativas para agentes artificiales. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagente, páginas 65-72, 1995. [4] P. R. Cohen y C. R. Perrault. Elementos de una teoría basada en planes de actos de habla. Ciencia Cognitiva, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra y P. Garcia. Formalizando Instituciones Electrónicas Mediadas por Agentes. En el Congreso Catalán sobre Inteligencia Artificial, páginas 29-38, 2000. [6] N. Fornara y M. Colombetti. Especificación operativa de un lenguaje de comunicación de agentes basado en compromisos. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 536-542, Bolonia, Italia, 2002. ACM Press. [7] B. Gaudou, A. Herzig, D. Longin y M. Nickles. Una nueva semántica para el Lenguaje de Comunicación de Agentes FIPA basada en Actitudes Sociales. En Actas de la 17ª Conferencia Europea sobre Inteligencia Artificial, Riva del Garda, Italia, 2006. IOS Press. [8] F. Guerin y J. Pitt. Semántica denotacional para lenguajes de comunicación de agentes. En Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 497-504. ACM Press, 2001. [9] M. Nickles, M. Rovatsos y G. Weiss. Semántica Racional Empírica de la Comunicación de Agentes. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Nueva York, NY, 2004. [10] J. Pitt y A. Mamdani. Algunas observaciones sobre la semántica del lenguaje de comunicación de agentes FIPA. Agentes Autónomos y Sistemas Multiagente, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles y G. Weiß. La interacción es significado: un nuevo modelo para la comunicación en sistemas abiertos. En Actas de la Segunda Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, Melbourne, Australia, 2003. [12] M. D. Sadek. Los actos de diálogo son planes racionales. En Actas del Taller ESCA/ETRW sobre la Estructura del Diálogo Multimodal, páginas 1-29, 1991. [13] M. Singh. Lenguajes de comunicación de agentes: Repensando los principios. IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.\nIEEE Computer, 31(12):55-61, 1998. [14] M. Singh. Una semántica social para los lenguajes de comunicación de agentes. En Actas del Taller IJCAI sobre Lenguajes de Comunicación de Agentes, 2000. [15] M. P. Singh. Una semántica para actos de habla. Anales de Matemáticas e Inteligencia Artificial, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos y F. Fischer. Especificando la Entrelazamiento de la Cooperación y la Autonomía en Sistemas basados en Agentes. Revista de Redes y Aplicaciones Informáticas, 29, 2007. [17] M. J. Wooldridge. Semántica verificable para lenguajes de comunicación de agentes. En Actas de la Tercera Conferencia Internacional sobre Sistemas Multiagente, páginas 349-356, París, Francia, 1998. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 107 ",
            "candidates": [],
            "error": [
                []
            ]
        },
        "social reason": {
            "translated_key": "razón social",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Dynamic Semantics for Agent Communication Languages Michael Rovatsos School of Informatics The University of Edinburgh Edinburgh EH8 9LE United Kingdom mrovatso@inf.ed.ac.uk ABSTRACT This paper proposes dynamic semantics for agent communication languages (ACLs) as a method for tackling some of the fundamental problems associated with agent communication in open multiagent systems.",
                "Based on the idea of providing alternative semantic variants for speech acts and transition rules between them that are contingent on previous agent behaviour, our framework provides an improved notion of grounding semantics in ongoing interaction, a simple mechanism for distinguishing between compliant and expected behaviour, and a way to specify sanction and reward mechanisms as part of the ACL itself.",
                "We extend a common framework for commitment-based ACL semantics to obtain these properties, discuss desiderata for the design of concrete dynamic semantics together with examples, and analyse their properties.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems 1.",
                "INTRODUCTION The field of agent communication language (ACL) research has long been plagued by problems of verifiability and grounding [10, 13, 17].",
                "Early mentalistic semantics that specify the semantics of speech acts in terms of preand post-conditions contingent on mental states of the participants (e.g. [3, 4, 12, 15]) lack verifiability regarding compliance of agents with the intended semantics (as the mental states of agents cannot be observed in open multiagent systems (MASs)).",
                "Unable to safeguard themselves against abuse by malicious, deceptive or malfunctioning agents, mentalistic semantics are inherently unreliable and inappropriate for use in open MAS in which agents with potentially conflicting objectives might deliberately exploit their adversaries conceptions of message semantics to provoke a certain behaviour.",
                "Commitment-based semantics [6, 8, 14], on the other hand, define the meaning of messages exchanged among agents in terms of publicly observable commitments, i.e. pledges to bring about a state of affairs or to perform certain actions.",
                "Such semantics solve the verifiability problem as they allow for tracing the status of existing commitments at any point in time given observed messages and actions so that any observer can, for example, establish whether an agent has performed a promised action.",
                "However, this can only be done a posteriori, and this creates a grounding problem as no expectations regarding what will happen in the future can be formed at the time of uttering or receiving a message purely on the grounds of the ACL semantics.",
                "Further, this implies that the semantics specification does not provide an interface to agents deliberation and planning mechanisms and hence it is unclear how rational agents would be able to decide whether to subscribe to a suggested ACL semantics when it is deployed.",
                "Finally, none of the existing approaches allows the ACL to specify how to respond to a violation of its semantics by individual agents.",
                "This has two implications: Firstly, it is left it up to the individual agent to reason about potential violations, i.e. to bear the burden of planning its own reaction to others non-compliant behaviour (e.g. in order to sanction them) and to anticipate others reactions to own misconduct without any guidance from the ACL specification.",
                "Secondly, existing approaches fail to exploit the possibilities of sanctioning and rewarding certain behaviours in a communication-inherent way by modifying the future meaning of messages uttered or received by compliant/deviant agents.",
                "In this paper, we propose dynamic semantics (DSs) for ACLs as a solution to these problems.",
                "Our notion of DS is based on the very simple idea of defining different alternatives for the meaning of individual speech acts (so-called semantic variants) in an ACL semantics specification, and transition rules between semantic states (i.e. collections of variants for different speech acts) that describe the current meaning of the ACL.",
                "These elements taken together result in a FSM-like view of ACL specifications where each individual state provides a complete ACL semantics and state transitions are triggered by observed agent behaviour in order to (1) reflect future expectations based on previous interaction experience and (2) sanction or reward certain kinds of behaviour.",
                "In defining a DS framework for commitment-based ACLs, this paper makes three contributions: 1.",
                "An extension of commitment-based ACL semantics to provide an improved notion of grounding commitments in agent interaction and to allow ACL specifications to be directly used for planning-based rational decision making. 2.",
                "A simple way of distinguishing between compliant and expected behaviour with respect to an ACL specification that enables reasoning about the potential behaviour of agents purely from an ACL semantics perspective. 3.",
                "A mechanism for specifying how meaning evolves with agent behaviour and how this can be used to describe communication-inherent sanctioning and rewarding mechanisms essential to the design of open MASs.",
                "Furthermore, we discuss desiderata for DS design that can be derived from our framework, present examples and analyse their properties.",
                "The remainder of this paper is structured as follows: Section 2 introduces a formal framework for dynamic ACL semantics.",
                "In section 3 we present an analysis and discussion of this framework and discuss desiderata for the design of ACLs with dynamic semantics.",
                "Section 4 reviews related approaches, and section 5 concludes. 2.",
                "FORMAL FRAMEWORK Our general framework for describing the kind of MASs we are interested in is fairly simple.",
                "Let Ag = {1, . . . , n} a finite set of agents, {Aci}i∈Ag a collection of action sets (where Aci are the actions of agent i), A = ×n i=1Aci the joint action space, and Env a set of environment states.",
                "A run is a sequence r = e1 a1 → . . . at−1 → et where ai ∈ A (ai[j] denotes the action of agent j in this tuple), and ei ∈ Env.",
                "We define |r| = t, last(r) = et, r[1 : j] is short for the j-long initial sub-sequence of r, and we write r r for any run r iff ∃j ∈ N.r = r[1 : j].",
                "Writing R(Env, A) for the set of all possible runs, we can view each agent i as a function gi : R(Env, A) → Aci describing the agents action choices depending on the history of previous environment states and joint actions.",
                "The set of all agent functions for i given A and Env is denoted by Gi(Env, A).",
                "The (finite, discrete, stationary, fully accessible, deterministic) environment is defined by a state transformer function f : Env × A → Env, so that the systems operation for an initial state e1 is defined by ei+1 = f(ei, g(e1 a1 → . . . ai−1 → ei)) for all i ≥ 1 (g is the joint vector of functions gi).",
                "This definition implies that execution of actions is synchronised among agents, so that the system evolves though an execution of rounds where all agents perform their actions simultaneously.",
                "We denote the set of all runs given a particular configuration of agent functions g by R(Env, A, g).",
                "We write gi ∼ r where gi an agent function and r a run iff ∀1 ≤ j ≤ |r|.gi(r[1 : j]) = aj [i] (i.e. gi is compatible with r in every time step as far as is actions are concerned).",
                "We use a (standard) propositional logical language L with entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L deunset pending cancelled active violated fulfilled Figure 1: Commitment states and state transitions in the Fornara and Colombetti model: edges drawn using solid lines indicate transitions brought about by agent communication, dashed lines indicate physical agent action or environmental events that cause state transitions fined in the usual way.1 We introduce special propositions Done(i, a) for each action a ∈ ∪n i=1Aci in L to denote it is true that action a has just been performed, extending |= to runs r in the following way: r |= ϕ if last(r) |= ϕ r |= Done(i, a) if r = e1 a1 → . . . at−1 → et ∧ a = at−1[i] i.e.",
                "Done(i, a) is exactly true for those actions that made up part of the joint action vector ai−1 in the predecessor state, and all other formulae that were entailed by the last state of r are still valid.",
                "Our model implies that each agent executes exactly one action in each time step. 2.1 Commitments Our notion of commitments is based on a slight variation of the framework proposed by Fornara and Colombetti [6]: Commitments come into existence as unset, e.g. when a request for achieving χ if a certain condition ϕ becomes true is issued from i to j.",
                "The commitment becomes pending if the debtor j is required to fulfill it, e.g. after having accepted it.",
                "A pending commitment will become active if its condition ϕ becomes true, and if χ is brought about in that case it becomes fulfilled, otherwise violated.",
                "Commitments can become cancelled in different situations, e.g. if an unset commitment is rejected.",
                "Also, environmental events can lead χ to become true in which case the commitment becomes fulfilled without the debtors contribution.",
                "Figure 1 provides a graphic representation of commitment state transitions in this framework.",
                "Apart from a slightly different notation used to maintain a more detailed history of commitments, we will extend them to also contain a deactivation condition ψ apart from ϕ (which we call activation condition) which causes any commitment to be cancelled if it becomes true. 1 More precisely L contains atomic propositions P = {p, q, . . . }, the usual connectives ∨ and ¬ (with abbreviations ⇒ and ∧).",
                "As for semantics, a function interpretation function I : P ×Env → { , ⊥} assigns a truth value to each proposition in each environmental state, and the entailment relation e |= ϕ for e ∈ Env and ϕ ∈ L is defined inductively: e |= ϕ if ϕ ∈ P and I(ϕ, e) = ; e |= ¬ϕ if e |= ϕ; e |= ϕ ∨ ψ if e |= ϕ or e |= ψ.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 101 D : CS ← CS∪{ ι, c : χ ⊕ ϕ ψ t| ι, s : χ ⊕ ϕ ψ ∈ CS, r |= ψ, s ∈ {u, p, a}, ι, c : χ ⊕ ϕ ψ /∈ CS} A : CS ← CS∪{ ι, a : χ ⊕ ϕ ψ t| ι, p : χ ⊕ ϕ ψ ∈ CS, r |= ϕ, ι, a : χ ⊕ ϕ ψ /∈ CS} S : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ t| ι, a : χ ⊕ ϕ ψ ∈ CS, r |= χ, ι, f : χ ⊕ ϕ ψ /∈ CS} F : CS ← CS∪{ ι, f : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), causes(a, χ)} V : CS ← CS∪{ ι, v : χ ⊕ ϕ ψ i→j t | ι, a : χ ⊕ ϕ ψ i→j t−1 ∈ CS, r |= Done(i, a), ¬causes(a, χ)} Table 1: Environmental commitment processing rules for current run r with |r| = t Definition 1.",
                "A commitment is a structure ι, s : χ ⊕ ϕ ψ i→j t where - ι is a unique commitment identifier, - s denotes the commitment state (any of unset, pending, active, violated, fulfilled, or cancelled, abbreviated by the respective initial), - i is the debtor, j is the creditor, - χ ∈ L is the debitum (i.e. the proposition that i commits to making true in front of j), - ϕ, ψ ∈ L are the activation/deactivation conditions, - and t is the instant (in a run) at which this commitment entered its current state s. As an example, x, v : received(5, $500) ⊕ received(3, toys) returned(3, toys) 3→5 12 denotes that agent 3 violated commitment x towards agent 5 to pay him $500 in timestep 12.",
                "He was supposed to make the payment after receiving the toys unless he sent back the toys.",
                "We introduce deactivation conditions so as to be able to completely revoke existing commitments: Sending back the money does not constitute a fulfillment of the original contract, but instead an annulment thereof.",
                "This provides us with the capability to define validity conditions using ϕ and ψ, which is useful for things like deadlines for unset commitments (if I dont get a response within 3 time-steps my request will expire).",
                "For brevity, we sometimes omit indices or content elements when clear from the context (in particular, we often write Γ for the content χ ⊕ ϕ ψ).",
                "We write C for the set of all possible commitments and denote sets of commitments (so-called commitment stores) by CS ∈ ℘fin (C).",
                "To handle the effects of environmental events and agent actions on a commitment store CS, table 1 introduces five commitment transition rules which are executed in each time step by the system or any observer who intends to clarify the status of existing commitments in the order shown: the deactivation rule D is the first to fire and cancels any unset, pending or active commitments if ψ becomes true.",
                "For the remaining pending commitments2 , the activation rule A describes how these become active if ϕ becomes true.",
                "Note that when ϕ is true in subsequent states we check whether 2 To avoid problems with contradictory commitment specifications (e.g. when both ϕ and ψ become true), we give deactivation strict precedence over activation. this active commitment is contained in CS to avoid duplicates (this is because we keep a full record of the commitment history for reasons which will become clear below).3 Rule S caters for serendipity i.e. fulfillment of commitments not brought about by the respective agent, but simply by environmental changes that made the debitum true.",
                "Finally, the fulfilment/violation rules F/V record whether the action performed by the debtor in the previous step (r |= Done(i, a)) has caused the debitum χ of any commitment which became active in the previous timestep to become true.",
                "We need only consider those commitments that became active in the previous step t − 1 since we can verify their fulfilment status in t. This verification hinges on a domain-dependent predicate causes(a, χ) which we have not mentioned so far.",
                "It should be true if action a is supposed to bring about χ, and delineates the existing social notion of what constitutes a reasonable attempt to achieve χ in the given context (its definition may range from requiring that χ has actually been achieved to allowing any action a that does not necessarily result in ¬χ). 2.2 Grounding In Fornara and Colombettis and similar approaches, the status of commitments is verifiable, but they are not grounded in expectations about interaction.",
                "Such semantics (similar in style to what he have just defined in terms of CS update rules) tell us what commitments exist and which state they are in, but not how this will affect future agent behaviour.",
                "To provide such grounding, we introduce notions of compliant and expected behaviour.",
                "An agent is behaving in compliance with its commitments if it always immediately fulfills all active commitments.",
                "More precisely, the behaviour of agent i is said to be compliant with CS at time t iff ∀k ≤ t ι, a : Γ i→j k ∈ CS ⇒ ι, f : Γ i→j k ∈ CS Though simple, this definition of compliance is not very useful because it places constraints on CSs but not on actual agent functions.",
                "To achieve this, we can instead use the contents of the CS to restrict the range of admissible agent functions to those that are in accordance with it using the following definition: Definition 2.",
                "For any run r ∈ R(Env, A), let CS(r) the set of commitments that has resulted from execution of r assuming that certain actions (including messages) create commitments or change their status.",
                "The set of compliant agent functions with respect to a commitment store CS is 3 While commitment identifiers adversely affect the readability of our notation, they are necessary here to uniquely determine which pending commitment is activated. 102 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) defined as compliant(CS) := ˘ gi ∈ Gi(Env, A) ˛ ˛ ∀r ∼ gi. ι, p : χ ⊕ ϕ ψ i→j ∈ CS(r) = CS. ∀r r. ι, a : χ ⊕ ϕ ψ i→j |r | ∈ CS(r ) ⇒ ` ∃a ∈ Aci.causes(a, χ) ∧ gi(r ) = a ´ ¯ What this definition captures is the following characterisation of a compliant agent function gi: for all runs r that the agent function gi contributes to: if r has created a pending commitment regarding χ, then if this commitment becomes active at the end of some extension r of r in the future, gi will cause the agent to perform an action a that causes χ.4 Next, to cater for the anticipation of non-compliant behaviour we need to introduce a notion of expected behaviour that overrides compliant behaviour.",
                "For this, we introduce a second type of commitments which we will call expectations to avoid confusion and distinguish from ordinary (now called normative) commitments by using round brackets (ι, s : Γ)i→j t .",
                "They are treated exactly like other commitments in terms of the rules introduced above but express what the agent is expected to do (in the non-normative sense of an objective prediction of behaviour) rather than what it is supposed to do in a normative sense.",
                "To define the notions we need below, we introduce the following constructs: CS := { ι, s : Γ ∈ CS|s ∈ {u, p, a, f, v}} CS := {(ι, s : Γ) ∈ CS|(ι, s : Γ) ∈ CS, ι, s : Γ ∈ CS, s, s ∈ {u, p, a, f, v}} CS simply restricts the commitment store to all normative commitments.",
                "Hence, compliant( CS ) specifies what agents are supposed to do.",
                "CS , on the other hand, overrides all normative commitment elements in CS for which an expectation also exists, i.e. expectations are given precedence over the normative commitments.",
                "With this, we can define expected behaviour as expected(CS) := compliant( CS ) i.e. behaviour that adheres to expectations where such expectations exist and is compliant otherwise.",
                "The separate, parallel, treatment of compliant and expected behaviour has two advantages: Firstly, we can respond to unexpected compliant behaviour, i.e. when we expect that someone will not obey their commitments we can still respond to it if they do (and, for example, regain trust in them).",
                "Secondly, we can cater for a variety of rules for translating commitment stores to actual future events which a reasoning agent can use in its planning process.",
                "For the purposes of this paper, we will assume that agents base their predictions about others on expected behaviour if it is different from compliant behaviour, and that they predict compliant behaviour, else. 4 Note the quantification in this definition: the property has to hold for every run that gave rise to ι and is compatible with gi.",
                "In particular, this must be independent of any part of the history (e.g. other agents actions and previous environment states) given CS(r).",
                "We also quantify over all extensions r of r, i.e. fulfillment of the commitment has to happen if the appropriate conditions arise regardless of other factors. 2.3 Static ACL Semantics Table 2 shows an example for a small fragment of an ACL semantics defined using our framework, with two alternative definitions (AC and AC2) for the semantics of the accept message type.",
                "Each of the so-called dialogue operators (similar to AI planning action schemata) is defined using the graphical notation p a q where p, a, and q are schemata for preconditions, messages (of a certain type), and post-conditions, respectively.",
                "Preconditions determine whether an action schema is applicable in a certain situation or not and contain formulae from L and/or constraints on the current contents of CS.",
                "PostConditions contain changes to the knowledge base and modifications to CS, i.e. they are interpreted like add/deletelists in traditional AI planning.",
                "For any such operator o = p, a, q we define pre(o) = p, action(o) = a and post(o) = q.",
                "All elements of a dialogue operator can contain logical variables in their pre- and post-conditions and sender/receiver/content variables in the action slot.",
                "In our example fragment, the operator RQ for requests creates an unset commitment with a fresh identifier ι and current timestamp (we assume that r |= time(t) ⇔ |r| = t, and there is a global system time that can be inspected by all agents), and AC/RJ add a pending/cancelled equivalent of ι to CS.",
                "A fragment consisting of {RQ, RJ, AC} is equivalent to the standard semantics of the respective performative types defined in [6].5 Note that our operators only contain objectively verifiable pre- and post-conditions, and if agents want to conform to it they need to comply with these operators.",
                "In the following, we will assume that agents always adhere to the ACL specification syntactically6 .",
                "Using AC2 instead of AC enables us to exploit the power of our distinction between compliant and expected behaviour, expressing that we dont trust i to adhere to the normal semantics of accept: its postcondition specifies that expected(CS) is not restricted to behaviours that will fulfill the commitment but suggest that it has actually been cancelled.",
                "At the same time, we maintain the normative commitment that ι is pending so that is behaviour would be seen to lie within compliant(CS) if i deviates from our (pessimistic) expectation and does the right thing instead. 2.4 Dynamic Semantics 2.4.1 Defining Dynamic Semantics To define DS for ACLs we now introduce a state transition system in which each state specifies an ordinary (static) commitment-based semantics and a range of agent pairs for which these semantics are assumed to apply. 5 Note that we allow for requesting identical things before receiving a response and responding several times to the same request.",
                "Simple additional conditions can be introduced to avoid these effects which we omit here for lack of space.",
                "The same is true of additional constraints to manage control flow issues in actual dialogues (e.g. turn-taking). 6 This means that, for an appropriate variable substitution ϑ, r |= pre(o)ϑ holds when o is applied at r and that CS(r) is transformed according to post(o)ϑ after its application.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 103 RQ : time(t), new(ι) request(i, j, ι : Γ) CS ← CS ∪ { ι, u : Γ i→j t } RJ : ι, u : Γ j→i t ∈ CS, time(t) reject(i, j, ι : Γ) CS ← CS ∪ { ι, c : Γ i→j t } AC : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } AC2 : ι, u : Γ j→i t ∈ CS, time(t) accept(i, j, ι : Γ) CS ← CS ∪ { ι, p : Γ i→j t } ∪ {(ι, c : Γ)i→j t } Table 2: Example commitment-based semantics for a small ACL fragment ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} s0 s1 ∀ ι, v : Γ i→j t ∈ CS ∃ ι, f : Γ i→j t ∈ CS.t > t : {(i, ∗)} Figure 2: FSM-like state transition diagram describing the Δ-relation in a DS specification Definition 3.",
                "A dynamic semantics (DS) is a structure O, S, s0, Δ where - O = {o1, o2, . . . , on} a set of dialogue operators, - S ⊆ ℘(O) is a set of semantic states specified as subsets of dialogue operators which are valid in this state, - s0 ∈ S is the initial semantic state, - and the transition relation Δ ⊆ S × ℘(C) × ℘(Ag × Ag) × S defines the transitions over S triggered by conditions expressed as elements of ℘(C) (C is the set of all possible commitments).",
                "The meaning of a transition (s, c, {(i1, j1), . . . , (in, jn)}, s ) ∈ Δ is as follows: Assume a mapping act : Ag × Ag → S which specifies that the semantics of operators in s holds for messages sent from i to j .",
                "Then, if CS ∈ c (i.e. the current CS matches the constraint c given as a collection of possible CSs) this will trigger a transition to state s for all pairs of agents in {(i1, j1), . . . , (in, jn)} for which the constraint was satisfied and will update act accordingly.",
                "In other words, the act mapping tracks which version of the semantics is valid for which pairs of communication partners over time. 2.4.2 Example To illustrate these concepts, consider the following example: Let O = {RQ, RJ, AC, AC2}, S = {s0, s1} where s0 = {RQ, RJ, AC} and s1 = {RQ, RJ, AC2}, i.e. there are two possible states of the semantics which only differ in their definition of accept (we call alternative versions of a single dialogue operator like AC and AC2 semantic variants).",
                "We assume that initially act(i, j) = s0 for all agents i, j ∈ Ag.",
                "We describe δ by the transition diagram shown in figure 2.",
                "In this diagram, edges carry labels c : A where c is a constraint on the contents of CS followed by a description of the set of agent pairs A for which the transition should be made to the target state.",
                "Writing A(s) = act−1 (s) for the so-called range of agent pairs for which s is active, we use agent variables like i and j and the wildcard symbol ∗ that can be bound to any agent in A(s), and we assume that this binding carries over to descriptions of A.",
                "For example, the edge with label ι, v : Γ i→j ∈ CS : {(i, ∗)} ∪ {(j, i)} can be interpreted as follows: select all pairs (i, j) ∈ A(s0) for which ι, v : Γ i→j ∈ CS applies (i.e. i has violated some commitment toward j) and make s1 valid for the set of agents {(i, k)|k ∈ A(s0)} ∪ {(j, i)}.",
                "This means that for all agents i who have lied, s1 will become active for (i, j ) where j ∈ A(s0) and s1 will also become active for (j, i).",
                "The way the DS of the diagram above works is as follows: initially the semantics says (for every agent i) that they will fulfill any commitment truthfully (the use of AC ensures that expected behaviour is equivalent to compliant behaviour).",
                "If an agent i violates a commitment once then s1 will become active for i towards all other agents, so that they wont expect i to fulfill any future commitments.",
                "Moreover, this will also apply to (j, i) so that the culprit i should not expect the deceived agent j to keep its promises towards i either in the future.",
                "However, this will not affect expectations regarding their interactions with i by agents other than i (i.e. they still have no right to violate their own commitments).",
                "This reflects the idea that (only) agents that have been fooled are allowed to trespass (only) against those agents who trespassed against them.",
                "However, if i ever fulfills any commitment again (after the latest violation, this is ensured by the complex constraint used as a label for the transition from s1 to s0), the semantics in s0 will become valid for i again.",
                "In this case, though, s1 will still be valid for the pair (j, i), i.e. agent j will regain trust in i but cannot be expected to be trustworthy toward i ever again.",
                "Rather than suggesting that this is a particularly useful communication-inherent mechanism for sanctioning and rewarding specific kinds of behaviour, this example serves to illustrate the expressiveness of our framework and the kind of distinctions it enables us to make. 2.4.3 Formal Semantics The semantics of a DS can be defined inductively as follows: Let CS(r) denote the contents of the commitment store after run r as before.",
                "We use the notation A(δ, CS) = {(i, j)|CS|i,j ∈ c} ∩ A(s) ∩ A to denote the set of agents that are to be moved from s to s due to transition rule δ = (s, c, A, s ) ∈ Δ given CS, where CS|i,j is the set of commitments that mention i and/or j (in their sender/receiver/content slots).",
                "In other words, A(δ, CS) contains those pairs of agents who are (i) mentioned in the commitments covered by the constraint c, (ii) contained in the range of s, and (iii) explicitly listed in A as belonging to those pairs of agents that should be affected by the transition δ. 104 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Definition 4.",
                "The state of a dynamic semantics O, S, s0, Δ after run r with immediate predecessor r is defined as a mapping actr as follows: 1. r = ε: actε(i, j) = s0 for all i, j ∈ Ag 2. r = ε: actr(i, j) = 8 >< >: s if ∃δ = (s, c, A, s ) ∈ Δ. (i, j) ∈ A(δ, CS(r)) actr (i, j) else This maintains the property act−1 r (s) = act−1 r (s) − A(δ, CS(r )), which specifies that the agent pairs to be moved from s to s are removed from the range of s and added to the range of s .",
                "What is not ensured by this definition is consistency of the state transition system, i.e. making sure that the semantic successor state is uniquely identified for any state of the commitment store and previous state so that every agent pair is only assigned one active state in each step, i.e. actr is actually a function for any r.7 2.4.4 Integration Once the DS itself has been specified, we need to integrate the different components of our framework to monitor the dynamics of our ACL semantics and its implications for expected agent behaviour.",
                "Starting with an initially empty commitment store CS and initial semantic state s0 such that actε(i, j) = s0 for any two agents i and j, the agent (or external observer) observes (a partial subset of) everything that is communicated in the system in each step.",
                "By applying the commitment transition rules (D, A, S, F and V ) we can update CS accordingly, ignoring any observed message sent from i to j that does not syntactically match the dialogue operator set defined in actr(i, j) for a current run r. After this update has been performed for all observed messages and actions in this cycle, which should not depend on the ordering of messages8 , we can compute for any message sent from i to j the new value of actr (i, j) depending on the semantic transition rules of the DS if r is the successor run of r. With this, we can then determine what the compliant and expected behaviour of agents will be under these new conditions.",
                "Thus, an agent can use information about expected behaviour in its own planning processes by assuming that all agents involved will exhibit their expected (rather than just compliant) behaviours.",
                "This prediction will not always be more accurate than under normal (static) ACL semantics, but since it is common knowledge that agents assume expected behaviour to occur (and, by virtue of the DS-ACL specification, have the right to do that) most reasonable dynamic ACL specifications will make provisions to ensure that it is safer to assume expected rather than fully compliant behaviour if they want to promote their use by agents. 7 One way of ensuring this is to require that ∀s ∈ S. (∩{c|(s, c, A, s ) ∈ Δ(s)} = ∅) so that no two constraints pertaining to outgoing edges of s can be fulfilled by CS at a time.",
                "In some cases this may be too coarse-grained - it would be sufficient for constraints to be mutually exclusive for the same pair of agents at any point in time - but this would have to be verified for an individual DS on a case-bycase basis. 8 This is the case for our operators, because their pre- and post-conditions never concern or affect any commitments other than those that involve both i and j - avoiding any connection to third parties helps us keep the CS-update independent of the order in which observations are processed. 2.4.5 Complexity Issues The main disadvantage of our approach is the space complexity of the dynamic ACL specification: If d is the number of dialogue operators in a language and b is the maximum number of semantic variants of a single dialogue operator within this language, the DS specification would have to specify O(db ) states.",
                "In many cases, however, most of the speech acts will not have different variants (like RQ and RJ in our example) and this may significantly reduce the number of DS states that need to be specified.",
                "As for the run-time behaviour of our semantics processing mechanism, we can assume that n messages/actions are sent/performed in each processing step in a system with n agents.",
                "Every commitment processing rule (D, S, etc.) has to perform a pass over the contents of CS.",
                "In the worst case every originally created commitment (of which there may be nt after t steps) may have immediately become pending, active and violated (which doesnt require any further physical actions, so that every agent can create a new commitment in each step).Thus, if any agent creates a new commitment in each step without ever fulfilling it, this will result in the total size of CS being in O(nt).9 Regarding semantic state transitions, as many as n different pairs of agents could be affected in a single iteration by n messages.",
                "Assuming that the verification of CS-constraints for these transitions would take O(nt), this yields a total update time of O(n2 t) for tracking DS evolution.",
                "This bound can be reduced to O(n2 ) if a quasi-stationarity assumption is made by limiting the window of earlier commitments that are being considered when verifying transition constraints to a constant size (and thus obtaining a finite set of possible commitment stores).10 3.",
                "ANALYSIS AND DISCUSSION The main strength of our framework is that it allows us to exploit the three main elements of reciprocity: • Reputation-based adaptation: The DS adapts the expectations toward agent i according to is previous behaviour by modifying the semantic state to better reflect this behaviour (based on the assumption that it will repeat itself in the future). • Mutuality of expectations: The DS adapts the expectations toward js behaviour according to is previous behaviour toward j to better reflect js response to is observed behaviour (in particular, allowing j to behave toward i as i behaved toward j earlier). • Recovery mechanisms: The DS allows i to revert to an earlier semantic state after having undone a change in expectations by a further, later change of behaviour (e.g. by means of redemption).",
                "In open systems in which we cannot enforce certain behaviours, these are effectively the only available means for indirect sanctions and rewards. 9 This is actually only a lower bound on the complexity for commitment processing which could become even worse if dominated by the complexity of verifying entailment |=; however, this would also hold for a static ACL semantics. 10 For example, this could be useful if we want to discard commitments whose status was last modified more than k time steps ago (this is problematic, as it might force us to discard certain unset/pending commitments before they become pending/active).",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 105 There are two further dimensions that affect DS-based sanctioning and reward mechanisms and are orthogonal to the above: One concerns the character of the semantic state changes (i.e. whether it is a reward or punishment), the other the degree of adaptation (reputation-based mechanisms, for example, need not realistically reflect the behaviour of the culprit, but may instead utilise immediate (exaggerated) stigmatisation of agents as a deterrent).",
                "Albeit simple, our example DS described above makes use of all these aspects, and apart from consistency and completeness, it also satisfies some other useful properties: 1.",
                "Non-redundancy: No two dialogue operators in O should have identical pre- and post-conditions, and any two semantic variants of an operator must differ in terms of pre- and/or post-conditions: ∀o, o ∈ O . (pre(o) = pre(o )∧post(o) = post(o ) ⇒ o = o ) ∀o, o ∈ O . (action(o) = action(o ) ⇒ pre(o) = pre(o ) ∨ post(o) = post(o)) 2.",
                "Reachability of all semantic states: Any constraint causing a transition must be satisfiable in principle when using the dialogue operators and physical actions that are provided: ∀(s, c, A, s ) ∈ Δ ∃r ∈ R(Env, A).CS(r) ∩ c = ∅ 3.",
                "Distinction between expected and compliant behaviour: The content of expectations must differ from that of normative commitments at least for some semantic variants (giving rise to non-compliant expectations for some runs): ∃r ∈ R(Env, A) .expected(CS(r)) = compliant(CS(r)) 4.",
                "Compliance/deviance realisability: It must be possible for agents in principle to comply with normative commitments or deviate from them in principle: ∃r ∈ R(Env, A) .expected(CS(r)) = ∅∧ compliant(CS(r)) = ∅ While not absolutely essential, these constitute desiderata for the design of DS-ACLs as they add to the simplicity and clarity of a given semantics specification.",
                "Our framework raises interesting questions regarding further potential properties of DS such as: 1.",
                "Respect for commitment autonomy: The semantics must not allow an agent to create a pending commitment for another agent or to violate a commitment on behalf of another agent.",
                "While in some cases some agents should be able to enforce commitments upon others, this should generally be avoided to ensure agent autonomy. 2.",
                "Avoiding commitment inconsistency: The ACL must either disallow commitment to contradictory actions or beliefs, or at least provide operators for rectifying such contradictory claims.",
                "Under contradictory commitments, no possible behaviour can be compliantit is up to the designer to decide to which extent this should be permitted. 3.",
                "Unprejudiced judgement: Expected behaviour prediction must not deviate from compliant behaviour prediction if deviant behaviour has not been observed so far (in particular this must hold for the initial semantic state).",
                "This might not always be desirable as initial distrust is necessary in some systems, but it increases the chances that agents will agree to participate in communication. 4.",
                "Convergence: The semantic state of each of the dialogue operators will remain stable after a finite number of transitions, regardless of any further agent behaviour11 .",
                "If this property holds, this would imply that agents can stop tracking semantic state transitions after some amount of initial interaction.",
                "The advantage of this is reduced complexity, which of course comes at the price of giving up adaptiveness. 5.",
                "Forgiveness: After initial deviance, further compliant behaviour of an agent should lead to a semantic state that predicts compliant behaviour for that agent again.",
                "Here, we have to trade off cautiousness against the provision of incentives to resume cooperative behaviour.",
                "Trusting an agent makes others vulnerable to exploitation - blacklisting an agent forever, though, might lead that agent to keep up its unpredictable and potentially malicious behaviour. 6.",
                "Equality: Unless this is required by domain-specific constraints, the same dynamics of semantics should apply to all parties involved.",
                "Our simple example semantics satisfies all these properties apart from convergence.",
                "Many of the above properties are debatable, as we have to trade off cautiousness against the provision of incentives for cooperative behaviour.",
                "While we cannot make any general statements here regarding optimal DS-ACL design, our framework provides the tools to test and evaluate the performance of different such communication-inherent sanctioning and rewarding mechanisms (i.e. social rules that do not presuppose ability to direct punishment or reward through physical actions) in real-world applications. 4.",
                "RELATED WORK Expectation-based reasoning about interaction was first proposed in [2], considering the evolution of expectations described as probabilistic expectations of communication and action sequences.",
                "The same authors suggested a more general framework for expectation-based communication semantics [9], and argue for a consequentialist view of semantics that is based on defining the meaning of utterances in terms of their expected consequences and updating these expectations with new observations [11].",
                "However, their approach does not use an explicit notion of commitments which in our framework mediates between communication and behaviour-based grounding, and provides a clear distinction between a normative notion of compliance and a more empirical notion of expectation.",
                "Grounding for (mentalistic) ACL semantics has been investigated in [7] where grounded information is viewed as information that is publicly expressed and accepted as being true by all the agents participating in a conversation.",
                "Like [1] (which bases the notion of publicly expressed on roles rather than internal states of agents) these authors main concern is to provide a verifiable basis for determining the semantics of expressed mental states and commitments.",
                "Though our framework is only concerned with commitment to the achievement of states of affairs rather than exchanged information, in a sense, DS provides an alternative view by specifying what will happen if the assumptions on which what is publicly accepted is based are violated. 11 In a non-trivial sense, i.e. when some initial transitions are possible in principle 106 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Our framework is also related to deontic methods for the specification of obligations, norms and sanctions.",
                "In this area, [16] is the only framework that we are aware of which considers dynamic obligations, norms and sanctions.",
                "However, as we have described above we solely utilise semantic evolution as a sanctioning and rewarding mechanism, i.e. unlike this work we do not assume that agents can be directly punished or rewarded.",
                "Finally, the FSM-like structure of the DS transition systems in combination with agent communication is reminiscent of work on electronic institutions [5], but there the focus is on providing different means of communication in different scenes of the interaction process (e.g. different protocols for different phases of market-based interaction) whereas we focus on different semantic variants that are to be used in the same interaction context. 5.",
                "CONCLUSION This paper introduces dynamic semantics for ACLs as a method for dealing with some fundamental problems of agent communication in open systems, the simple underlying idea being that different courses of agent behaviour can give rise to different interpretations of meaning of the messages exchanged among agents.",
                "Based on a common framework of commitment-based semantics, we presented a notion of grounding for commitments based on notions of compliant and expected behaviour.",
                "We then defined dynamic semantics as state transition systems over different semantic states that can be viewed as different versions of ACL semantics in the traditional sense, and can be easily associated with a planning-based view of reasoning about communication.",
                "Thereby, our focus was on simplicity and on providing mechanisms for tracking semantic evolution in a down-toearth, algorithmic fashion to ensure applicability to many different agent designs.",
                "We discussed the properties of our framework showing how it can be used as a powerful communication-inherent mechanism for rewarding and sanctioning agent behaviour in open systems without compromising agent autonomy, discussed its integration with agents planning processes, complexity issues, and presented a list of desiderata for the design of ACLs with such semantics.",
                "Currently, we are working on fully-fledged specifications of dynamic semantics for more complex languages and on extending our approach to mentalistic semantics where we view statements about mental states as commitments regarding the rational implications of these mental states (a simple example for this is that an agent commits itself to dropping an ostensible intention that it is claiming to maintain if that intention turns out to be unachievable).",
                "In this context, we are particularly interested in appropriate mechanisms to detect and respond to lying by interrogating suspicious agents and forcing them to commit themselves to (sets of) mental states publicly while sanctioning them when these are inconsistent with their actions. 6.",
                "REFERENCES [1] G. Boella, R. Damiano, J. Hulstijn, and L. van der Torre.",
                "ACL Semantics between Social Commitments and Mental Attitudes.",
                "In Proceedings of the International Workshop on Agent Communication , 2006. [2] W. Brauer, M. Nickles, M. Rovatsos, G. Weiß, and K. F. Lorentzen.",
                "Expectation-Oriented Analysis and Design.",
                "In Proceedings of the 2nd Workshop on Agent-Oriented Software Engineering , LNCS 2222, 2001.",
                "Springer-Verlag, Berlin. [3] P. R. Cohen and H. J. Levesque.",
                "Communicative actions for artificial agents.",
                "In Proceedings of the First International Conference on Multi-Agent Systems, pages 65-72, 1995. [4] P. R. Cohen and C. R. Perrault.",
                "Elements of a Plan-Based Theory of Speech Acts.",
                "Cognitive Science, 3:177-212, 1979. [5] M. Esteva, J. Rodriguez, J. Arcos, C. Sierra, and P. Garcia.",
                "Formalising Agent Mediated Electronic Institutions.",
                "In Catalan Congres on AI, pages 29-38, 2000. [6] N. Fornara and M. Colombetti.",
                "Operational specification of a commitment-based agent communication language.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems, pages 536-542, Bologna, Italy, 2002.",
                "ACM Press. [7] B. Gaudou, A. Herzig, D. Longin, and M. Nickles.",
                "A New Semantics for the FIPA Agent Communication Language based on Social Attitudes.",
                "In Proceedings of the 17th European Conference on Artificial Intelligence, Riva del Garda, Italy, 2006.",
                "IOS Press. [8] F. Guerin and J. Pitt.",
                "Denotational Semantics for Agent Communication Languages.",
                "In Proceedings of the Fifth International Conference on Autonomous Agents, pages 497-504.",
                "ACM Press, 2001. [9] M. Nickles, M. Rovatsos, and G. Weiss.",
                "EmpiricalRational Semantics of Agent Communication.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, New York, NY, 2004. [10] J. Pitt and A. Mamdani.",
                "Some Remarks on the Semantics of FIPAs Agent Communication Language.",
                "Autonomous Agents and Multi-Agent Systems, 2:333-356, 1999. [11] M. Rovatsos, M. Nickles, and G. Weiß.",
                "Interaction is Meaning: A New Model for Communication in Open Systems.",
                "In Proceedings of the Second International Joint Conference on Autonomous Agents and Multiagent Systems, Melbourne, Australia, 2003. [12] M. D. Sadek.",
                "Dialogue acts are rational plans.",
                "In Proceedings of the ESCA/ETRW Workshop on the Structure of Multimodal Dialogue, pages 1-29, 1991. [13] M. Singh.",
                "Agent communication languages: Rethinking the principles.",
                "IEEE Computer, 31(12):55-61, 1998. [14] M. Singh.",
                "A social semantics for agent communication languages.",
                "In Proceedings of the IJCAI Workshop on Agent Communication Languages, 2000. [15] M. P. Singh.",
                "A semantics for speech acts.",
                "Annals of Mathematics and Artificial Intelligence, 8(1-2):47-71, 1993. [16] G. Weiß, M. Nickles, M. Rovatsos, and F. Fischer.",
                "Specifying the Intertwining of Cooperation and Autonomy in Agent-based Systems.",
                "Journal of Networks and Computer Applications, 29, 2007. [17] M. J. Wooldridge.",
                "Verifiable semantics for agent communication languages.",
                "In Proceedings of the Third International Conference on Multi-Agent Systems, pages 349-356, Paris, France, 1998.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 107"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}