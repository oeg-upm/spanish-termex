{
    "id": "I-45",
    "original_text": "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust. Instead, messages are provided as a primitive building block. In this paper we consider one approach for modelling agent interactions: the commitment machines framework. This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions. We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages. The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1. INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems. Consequently, design and implementation of agent interaction is an important research topic. The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML. It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents. Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility). On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust. Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2]. There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11]. However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions. Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages. Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction. This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation. The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic. This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19]. In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN. We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this. We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2. BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches. A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state. This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional. A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p). This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question. For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid). A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true. For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid). The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time. For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true. In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14]. In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q). An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists. A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state. A final state is one that has no base-level commitments. One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM. For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt. The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made. As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans. Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances. One of these is chosen and is executed. We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL). This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16]. Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs. An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body. The plan body is built up from the following constructs. We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e). These can be sequenced (P; P). C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2. This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16]. The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set. In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}). More sophisticated belief management methods may be used, but are not considered here. We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention). We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ. Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q). The global message queue is a sequence of triplets of the form sender:recipient:message. A transition S0 −→ S1 specifies that executing S0 a single step yields S1. We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration. The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion. Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans. This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3. IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role). We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act. In section 4 we relax these assumptions. Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X. For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to. Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m). Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled. Handling the event involves sending a message to the other agent, and then doing nothing until a response is received. C: ı : true ← +accept; ↑sendAccept. M: ↓sendAccept : true ← +accept; ı. If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4). For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓sendReceipt : pay ← +receipt; ı. C: ↓sendReceipt : ¬pay ← . . . report error . . . . In addition to these plans, we also need plans to start and finish the interaction. An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . . An interaction is started by setting up an agents initial beliefs, and then having it begin to interact. Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file. A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction. Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı. Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol. For conciseness the error reporting plans are omitted. We now turn to refining the context conditions. There are three refinements that we consider. Firstly, we need to prevent performing actions that have no effect on the interaction state. Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold. For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property. Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely. For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action. For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO. For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı. Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı. Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı. Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4). When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions. One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans. This is clearly safe, since actions are not prevented, just considered in a different order. The third refinement of context conditions concerns the plans that terminate the interaction. In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue). However, only some of these final states are desirable final states. Which final states are considered to be desirable depends on the domain and the desired interaction outcome. In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt). In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done. Figure 4 shows the plans that are changed from figure 3. In order to support the realisation of CMs, we need to change SAAPL in a number of ways. These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive. We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language. The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO. Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt. Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics. Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g. Jason, 3APL, CAN). However, other agent platforms do require an extension. For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested. In the case of 3APL no change is needed to support this. Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15]. In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions. For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true. Similar rules apply for conditional commitments. These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5. The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules. For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact). The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2. To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)). B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added. Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments. The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5. For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment. One aspect that doesnt require a change is linking commitments and actions. This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments. Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 . In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator. There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done. One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages. In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event. However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6]. Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event. One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once. In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4. BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7]. In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption! For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept). The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act! Figure 7 shows the FSM for NetBill with alternating initiative. A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment. A general solution is to track whose turn it is to act. This can be done by working out which agents have actions that are able to be performed in the current state. If there is only a single active agent, then it is clearly that agents turn to act. However, if more than one agent is active then somehow the agents need to work out who should act next. Working this out by negotiation is not a particularly good solution for two reasons. Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this. Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule. It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts. An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section. The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states. This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM. The two specific issues that need to be addressed are: 1. Can agents end up in different final states? 2. Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message? We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions). By actions commute we mean that the state resulting from performing a sequence of actions A1 . . . An is the same, regardless of the order in which the actions are performed. This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions. This addresses the issue of ending up in different final states. We return to the possibility of errors occurring shortly. Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments. A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]). This assumes that both actions can be performed. However, it is possible for the performance of A1 to disable A2 from being done. For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order. We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false. Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ). This is because only P is used to determine whether another agent is able to perform the action. Thus monotonic CMs with preconditions that do not contain negations have actions that commute. However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic. If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic. Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic. Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state. Furthermore, no errors can occur. Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order. The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions. Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B. Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic. Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B. Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C? Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 . From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done. This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute). This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster. This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical. Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı. One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact. However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions. Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5. DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic. The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language. As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions. We have already discussed STAPLE [9, 10]. Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2]. Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3]. However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed. Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.) TCP. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation. However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents. Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself. Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation. Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated. Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed. Finally, there is a need to perform empirical evaluation. There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4]. It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6. REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors. Multi-Agent Programming: Languages, Platforms and Applications. Springer, 2005. [2] C. Cheong and M. Winikoff. Hermes: Designing goal-oriented agent interactions. In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff. Hermes: Implementing goal-oriented agent interactions. In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff. Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches. Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque. Teamwork. Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum. Communication for goal directed agents. In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk. Towards a testbed for multi-party dialogues. In Advances in Agent Communication, pages 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores. Using a performative subsumption lattice to support commitment-based conversations. In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121. ACM Press, 2005. [9] S. Kumar and P. R. Cohen. STAPLE: An agent programming language based on the joint intention theory. In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391. ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen. Representing and executing protocols as joint actions. In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002. ACM Press. [11] M. Tambe and W. Zhang. Towards flexible teamwork in persistent teams: Extended report. Journal of Autonomous Agents and Multi-agent Systems, 2000. Special issue on Best of ICMAS 98. [12] M. Winikoff. An AgentSpeak meta-interpreter and its applications. In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff. Designing commitment-based agent interactions. In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff. Implementing flexible and robust agent interactions using distributed commitment machines. Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland. Enhancing commitment machines. In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah. Declarative & procedural goals in intelligent agent systems. In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum. Towards design tools for protocol development. In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105. ACM Press, 2005. [18] P. Yolum and M. P. Singh. Flexible protocol specification and execution: Applying event calculus planning using commitments. In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh. Reasoning about commitments in the event calculus: An approach for specifying and executing protocols. Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)",
    "original_sentences": [
        "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
        "Instead, messages are provided as a primitive building block.",
        "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
        "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
        "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
        "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
        "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
        "Consequently, design and implementation of agent interaction is an important research topic.",
        "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
        "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
        "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
        "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
        "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
        "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
        "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
        "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
        "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
        "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
        "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
        "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
        "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
        "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
        "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
        "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
        "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
        "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
        "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
        "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
        "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
        "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
        "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
        "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
        "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
        "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
        "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
        "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
        "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
        "A final state is one that has no base-level commitments.",
        "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
        "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
        "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
        "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
        "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
        "One of these is chosen and is executed.",
        "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
        "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
        "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
        "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
        "The plan body is built up from the following constructs.",
        "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
        "These can be sequenced (P; P).",
        "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
        "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
        "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
        "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
        "More sophisticated belief management methods may be used, but are not considered here.",
        "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
        "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
        "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
        "The global message queue is a sequence of triplets of the form sender:recipient:message.",
        "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
        "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
        "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
        "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
        "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
        "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
        "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
        "In section 4 we relax these assumptions.",
        "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
        "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
        "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
        "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
        "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
        "C: ı : true ← +accept; ↑sendAccept.",
        "M: ↓sendAccept : true ← +accept; ı.",
        "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
        "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
        "C: ↓sendReceipt : pay ← +receipt; ı.",
        "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
        "In addition to these plans, we also need plans to start and finish the interaction.",
        "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
        "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
        "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
        "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
        "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
        "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
        "For conciseness the error reporting plans are omitted.",
        "We now turn to refining the context conditions.",
        "There are three refinements that we consider.",
        "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
        "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
        "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
        "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
        "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
        "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
        "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
        "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
        "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
        "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
        "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
        "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
        "This is clearly safe, since actions are not prevented, just considered in a different order.",
        "The third refinement of context conditions concerns the plans that terminate the interaction.",
        "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
        "However, only some of these final states are desirable final states.",
        "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
        "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
        "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
        "Figure 4 shows the plans that are changed from figure 3.",
        "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
        "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
        "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
        "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
        "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
        "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
        "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
        "Jason, 3APL, CAN).",
        "However, other agent platforms do require an extension.",
        "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
        "In the case of 3APL no change is needed to support this.",
        "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
        "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
        "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
        "Similar rules apply for conditional commitments.",
        "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
        "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
        "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
        "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
        "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
        "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
        "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
        "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
        "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
        "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
        "One aspect that doesnt require a change is linking commitments and actions.",
        "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
        "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
        "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
        "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
        "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
        "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
        "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
        "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
        "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
        "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
        "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
        "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
        "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
        "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
        "Figure 7 shows the FSM for NetBill with alternating initiative.",
        "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
        "A general solution is to track whose turn it is to act.",
        "This can be done by working out which agents have actions that are able to be performed in the current state.",
        "If there is only a single active agent, then it is clearly that agents turn to act.",
        "However, if more than one agent is active then somehow the agents need to work out who should act next.",
        "Working this out by negotiation is not a particularly good solution for two reasons.",
        "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
        "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
        "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
        "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
        "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
        "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
        "The two specific issues that need to be addressed are: 1.",
        "Can agents end up in different final states? 2.",
        "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
        "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
        "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
        "An is the same, regardless of the order in which the actions are performed.",
        "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
        "This addresses the issue of ending up in different final states.",
        "We return to the possibility of errors occurring shortly.",
        "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
        "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
        "This assumes that both actions can be performed.",
        "However, it is possible for the performance of A1 to disable A2 from being done.",
        "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
        "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
        "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
        "This is because only P is used to determine whether another agent is able to perform the action.",
        "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
        "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
        "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
        "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
        "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
        "Furthermore, no errors can occur.",
        "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
        "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
        "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
        "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
        "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
        "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
        "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
        "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
        "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
        "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
        "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
        "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
        "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
        "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
        "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
        "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
        "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
        "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
        "We have already discussed STAPLE [9, 10].",
        "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
        "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
        "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
        "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
        "TCP.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
        "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
        "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
        "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
        "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
        "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
        "Finally, there is a need to perform empirical evaluation.",
        "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
        "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
        "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
        "Multi-Agent Programming: Languages, Platforms and Applications.",
        "Springer, 2005. [2] C. Cheong and M. Winikoff.",
        "Hermes: Designing goal-oriented agent interactions.",
        "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
        "Hermes: Implementing goal-oriented agent interactions.",
        "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
        "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
        "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
        "Teamwork.",
        "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
        "Communication for goal directed agents.",
        "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
        "Towards a testbed for multi-party dialogues.",
        "In Advances in Agent Communication, pages 212-230.",
        "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
        "Using a performative subsumption lattice to support commitment-based conversations.",
        "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
        "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
        "STAPLE: An agent programming language based on the joint intention theory.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
        "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
        "Representing and executing protocols as joint actions.",
        "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
        "ACM Press. [11] M. Tambe and W. Zhang.",
        "Towards flexible teamwork in persistent teams: Extended report.",
        "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
        "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
        "An AgentSpeak meta-interpreter and its applications.",
        "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
        "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
        "Designing commitment-based agent interactions.",
        "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
        "Implementing flexible and robust agent interactions using distributed commitment machines.",
        "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
        "Enhancing commitment machines.",
        "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
        "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
        "Declarative & procedural goals in intelligent agent systems.",
        "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
        "Towards design tools for protocol development.",
        "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
        "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
        "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
        "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
        "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
        "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "translated_text_sentences": [
        "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta.",
        "En cambio, los mensajes se proporcionan como un bloque de construcción primitivo.",
        "En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso.",
        "Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles.",
        "Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales.",
        "Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1.",
        "Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente.",
        "Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante.",
        "El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML.",
        "Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes.",
        "Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad).",
        "Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos.",
        "Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2].",
        "También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11].",
        "Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones.",
        "Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes.",
        "De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes.",
        "Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta.",
        "El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal.",
        "Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19].",
        "En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN.",
        "Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto.",
        "Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2.",
        "ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes.",
        "Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción.",
        "Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales.",
        "Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p).",
        "Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión.",
        "Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado).",
        "Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero.",
        "Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes).",
        "La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo.",
        "Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero.",
        "En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14].",
        "En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q).",
        "Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación.",
        "Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final.",
        "Un estado final es aquel que no tiene compromisos a nivel base.",
        "Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM.",
        "Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo.",
        "El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago.",
        "Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes.",
        "Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables.",
        "Uno de ellos es elegido y es ejecutado.",
        "Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL).",
        "Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16].",
        "Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs.",
        "Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan.",
        "El cuerpo del plan se construye a partir de los siguientes elementos.",
        "Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e).",
        "Estos pueden ser secuenciados (P; P).",
        "La semántica formal para este lenguaje se da en la figura 2.",
        "Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16].",
        "La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias.",
        "En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}).",
        "Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí.",
        "Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención).",
        "También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ.",
        "Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q).",
        "La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje.",
        "Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1.",
        "Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS.",
        "La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión.",
        "Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables.",
        "Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3.",
        "IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol).",
        "Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos.",
        "En la sección 4 relajamos estas suposiciones.",
        "Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X.",
        "Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan.",
        "Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m).",
        "El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado.",
        "Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta.",
        "C: ı : verdadero ← +aceptar; ↑enviarAceptar.",
        "M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı.",
        "Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4).",
        "Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt.",
        "C: ↓enviarRecibo : pagar ← +recibo; ı.",
        "C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . .",
        "Además de estos planes, también necesitamos planes para empezar y terminar la interacción.",
        "Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . .",
        "Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar.",
        "Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo.",
        "Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción.",
        "Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı.",
        "La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill.",
        "Por concisión, se omiten los planes de informe de errores.",
        "Ahora pasamos a refinar las condiciones del contexto.",
        "Hay tres refinamientos que consideramos.",
        "En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción.",
        "En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales.",
        "Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos.",
        "En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente.",
        "Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción.",
        "Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO.",
        "Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı.",
        "Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı.",
        "Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı.",
        "Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4).",
        "Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales.",
        "Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes.",
        "Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente.",
        "La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción.",
        "En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar).",
        "Sin embargo, solo algunos de estos estados finales son estados finales deseables.",
        "Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado.",
        "En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo).",
        "Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho.",
        "La figura 4 muestra los planes que han sido modificados respecto a la figura 3.",
        "Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras.",
        "Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso.",
        "Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL.",
        "Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO.",
        "Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo.",
        "Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos.",
        "Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...).",
        "Jason, 3APL, CAN.",
        "Sin embargo, otras plataformas de agentes sí requieren una extensión.",
        "Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados.",
        "En el caso de 3APL no se necesita ningún cambio para respaldar esto.",
        "Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15].",
        "En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones.",
        "Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero.",
        "Se aplican reglas similares para compromisos condicionales.",
        "Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5.",
        "La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas.",
        "Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
        "La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho).",
        "Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2.",
        "Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)).",
        "La última modificación es actualizar los compromisos cuando se agrega una creencia.",
        "Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos.",
        "La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5.",
        "Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base.",
        "Un aspecto que no requiere un cambio es vincular compromisos y acciones.",
        "Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base).",
        "La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill.",
        "Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador.",
        "Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado.",
        "Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes.",
        "En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento.",
        "Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6].",
        "Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento.",
        "Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez.",
        "En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4.",
        "MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7].",
        "De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable!",
        "Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación).",
        "El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar!",
        "La Figura 7 muestra el MEF para NetBill con iniciativa alternante.",
        "Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso.",
        "Una solución general es llevar un registro de quién debe actuar en cada turno.",
        "Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual.",
        "Si solo hay un agente activo, entonces está claro que los agentes deben actuar.",
        "Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación.",
        "Resolver esto mediante negociación no es una solución especialmente buena por dos razones.",
        "En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo.",
        "En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria.",
        "También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa.",
        "Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección.",
        "El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes.",
        "Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF.",
        "Los dos problemas específicos que deben abordarse son: 1.",
        "¿Pueden los agentes terminar en diferentes estados finales? 2.",
        "¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido?",
        "Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones).",
        "Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1...",
        "\"Un es lo mismo, independientemente del orden en que se realicen las acciones.\"",
        "Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones.",
        "Esto aborda el problema de terminar en diferentes estados finales.",
        "Regresamos a la posibilidad de que ocurran errores pronto.",
        "Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso.",
        "Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]).",
        "Esto asume que ambas acciones pueden ser realizadas.",
        "Sin embargo, es posible que el rendimiento de A1 impida que se realice A2.",
        "Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden.",
        "Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa.",
        "Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ).",
        "Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción.",
        "Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan.",
        "Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas.",
        "Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas.",
        "Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas.",
        "Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado.",
        "Además, no pueden ocurrir errores.",
        "Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente.",
        "La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción.",
        "Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B.",
        "Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas.",
        "Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B.",
        "Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C?",
        "Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada.",
        "Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado.",
        "Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan).",
        "Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre.",
        "Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos.",
        "Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı.",
        "Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando.",
        "Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones.",
        "La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5.",
        "DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono.",
        "Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI.",
        "Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas.",
        "Ya hemos discutido STAPLE [9, 10].",
        "Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2].",
        "Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3].",
        "Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse.",
        "Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo).",
        "TCP.",
        "El Sexto Internacional.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación.",
        "Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes.",
        "Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma.",
        "Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación.",
        "Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente.",
        "Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten.",
        "Finalmente, es necesario realizar una evaluación empírica.",
        "Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4].",
        "Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6.",
        "REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores.",
        "Programación multiagente: lenguajes, plataformas y aplicaciones.",
        "Springer, 2005. [2] C. Cheong y M. Winikoff.",
        "Hermes: Diseñando interacciones de agentes orientadas a objetivos.",
        "En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff.",
        "Hermes: Implementando interacciones de agentes orientadas a objetivos.",
        "En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff.",
        "Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes.",
        "Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque.",
        "Trabajo en equipo.",
        "Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum.",
        "Comunicación para agentes dirigidos por objetivos.",
        "En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk.",
        "Hacia un banco de pruebas para diálogos de múltiples partes.",
        "En Avances en Comunicación de Agentes, páginas 212-230.",
        "Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores.",
        "Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos.",
        "En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121.",
        "ACM Press, 2005. [9] S. Kumar y P. R. Cohen.",
        "STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta.",
        "En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391.",
        "ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen.",
        "Representando y ejecutando protocolos como acciones conjuntas.",
        "En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002.",
        "ACM Press. [11] M. Tambe y W. Zhang.",
        "Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado.",
        "Revista de Agentes Autónomos y Sistemas Multiagente, 2000.",
        "Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff.",
        "Un meta-intérprete de AgentSpeak y sus aplicaciones.",
        "En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138.",
        "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff.",
        "Diseñando interacciones de agentes basadas en compromisos.",
        "En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff.",
        "Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas.",
        "Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland.",
        "Mejorando máquinas de compromiso.",
        "En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220.",
        "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah.",
        "Objetivos declarativos y procedimentales en sistemas de agentes inteligentes.",
        "En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum.",
        "Hacia herramientas de diseño para el desarrollo de protocolos.",
        "En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105.",
        "ACM Press, 2005. [18] P. Yolum y M. P. Singh.",
        "Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos.",
        "En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh.",
        "Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos.",
        "Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)"
    ],
    "error_count": 9,
    "keys": {
        "commitment-based interaction": {
            "translated_key": "Interacción basada en el compromiso",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "messagecentric approach": {
            "translated_key": "enfoques centrados en mensajes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and <br>messagecentric approach</br>es to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and <br>messagecentric approach</br>es to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust."
            ],
            "translated_annotated_samples": [
                "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los <br>enfoques centrados en mensajes</br> para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los <br>enfoques centrados en mensajes</br> para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "agent-oriented programming language": {
            "translated_key": "lenguajes de programación orientados a agentes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present <br>agent-oriented programming language</br>s do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional <br>agent-oriented programming language</br>s.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present <br>agent-oriented programming language</br>s do not provide support for implementing agent interaction that is flexible and robust.",
                "We investigate how commitmentbased interactions can be implemented in conventional <br>agent-oriented programming language</br>s."
            ],
            "translated_annotated_samples": [
                "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los <br>lenguajes de programación orientados a agentes</br> actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta.",
                "Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en <br>lenguajes de programación orientados a agentes</br> convencionales."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los <br>lenguajes de programación orientados a agentes</br> actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en <br>lenguajes de programación orientados a agentes</br> convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "agent interaction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although <br>agent interaction</br> plays a vital role in MAS, and messagecentric approaches to <br>agent interaction</br> have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and <br>agent interaction</br> plays a vital role in multiagent systems.",
                "Consequently, design and implementation of <br>agent interaction</br> is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing <br>agent interaction</br>.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust <br>agent interaction</br> implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust <br>agent interaction</br>, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two <br>agent interaction</br> design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although <br>agent interaction</br> plays a vital role in MAS, and messagecentric approaches to <br>agent interaction</br> have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "INTRODUCTION Agents are social, and <br>agent interaction</br> plays a vital role in multiagent systems.",
                "Consequently, design and implementation of <br>agent interaction</br> is an important research topic.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing <br>agent interaction</br>.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust <br>agent interaction</br> implementation."
            ],
            "translated_annotated_samples": [
                "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la <br>interacción entre agentes</br> juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la <br>interacción entre agentes</br> tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta.",
                "Los agentes son sociales, y la <br>interacción entre agentes</br> juega un papel vital en los sistemas multiagente.",
                "Por consiguiente, el diseño e implementación de la <br>interacción de agentes</br> es un tema de investigación importante.",
                "De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la <br>interacción entre agentes</br>.",
                "Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de <br>interacción de agentes</br> de alto nivel, flexible y robusta."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la <br>interacción entre agentes</br> juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la <br>interacción entre agentes</br> tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la <br>interacción entre agentes</br> juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la <br>interacción de agentes</br> es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la <br>interacción entre agentes</br>. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de <br>interacción de agentes</br> de alto nivel, flexible y robusta. ",
            "candidates": [],
            "error": [
                [
                    "interacción entre agentes",
                    "interacción entre agentes",
                    "interacción entre agentes",
                    "interacción de agentes",
                    "interacción entre agentes",
                    "interacción de agentes"
                ]
            ]
        },
        "commitment machine framework": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine framework</br> is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the <br>commitment machine framework</br> any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine framework</br> is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "In the <br>commitment machine framework</br> any state that has no base-level commitment is final, in that the interaction may end there (or it may continue)."
            ],
            "translated_annotated_samples": [
                "ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del <br>marco de las máquinas de compromiso</br> es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes.",
                "En el marco de la <br>Máquina de Compromiso</br>, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar)."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del <br>marco de las máquinas de compromiso</br> es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la <br>Máquina de Compromiso</br>, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    "marco de las máquinas de compromiso",
                    "Máquina de Compromiso"
                ]
            ]
        },
        "bdi-style plan": {
            "translated_key": "plan de estilo BDI",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "social commitment": {
            "translated_key": "compromiso social",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level <br>social commitment</br> is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional <br>social commitment</br> is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "A base-level <br>social commitment</br> is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "A conditional <br>social commitment</br> is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true."
            ],
            "translated_annotated_samples": [
                "Un <br>compromiso social</br> de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p).",
                "Un <br>compromiso social</br> condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un <br>compromiso social</br> de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un <br>compromiso social</br> condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "interaction goal": {
            "translated_key": "metas de interacción",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or <br>interaction goal</br>s [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or <br>interaction goal</br>s [2]."
            ],
            "translated_annotated_samples": [
                "Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o <br>metas de interacción</br> [2]."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o <br>metas de interacción</br> [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "turn tracking": {
            "translated_key": "seguimiento de turnos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including <br>turn tracking</br> [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "We then extend our scheme to address a range of issues concerned with distribution, including <br>turn tracking</br> [7], and race conditions. 2."
            ],
            "translated_annotated_samples": [
                "Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el <br>seguimiento de turnos</br> [7] y las condiciones de carrera. 2."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el <br>seguimiento de turnos</br> [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "race condition": {
            "translated_key": "condiciones de carrera",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and <br>race condition</br>s) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and <br>race condition</br>s. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and <br>race condition</br>s) and solutions to these problems.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and <br>race condition</br>s. 2."
            ],
            "translated_annotated_samples": [
                "Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y <br>condiciones de carrera</br>) y soluciones a estos problemas.",
                "Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las <br>condiciones de carrera</br>. 2."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y <br>condiciones de carrera</br>) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las <br>condiciones de carrera</br>. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "belief management method": {
            "translated_key": "gestión de creencias",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated <br>belief management method</br>s may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "More sophisticated <br>belief management method</br>s may be used, but are not considered here."
            ],
            "translated_annotated_samples": [
                "Se pueden utilizar métodos más sofisticados de <br>gestión de creencias</br>, pero no se consideran aquí."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de <br>gestión de creencias</br>, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la interacción de NetBill utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "herme design": {
            "translated_key": "diseño hermético",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "netbill interaction": {
            "translated_key": "interacción de NetBill",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the <br>netbill interaction</br> using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Although we have implemented the <br>netbill interaction</br> using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself."
            ],
            "translated_annotated_samples": [
                "Aunque hemos implementado la <br>interacción de NetBill</br> utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la máquina de compromisos (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la tradición BDI (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (BDI) (SAAPL). Este lenguaje está destinado a ser una abstracción que se encuentra en el subconjunto común de lenguajes como Jason [1, Capítulo 1], 3APL [1, Capítulo 2] y CAN [16]. Por lo tanto, está intencionalmente incompleto en algunas áreas, por ejemplo, no se compromete con un mecanismo particular para tratar el fracaso del plan, ya que diferentes mecanismos son utilizados por diferentes AOPLs. Un programa de agente (denotado por Π) consiste en una colección de cláusulas de plan de la forma e : C ← P donde e es un evento, C es una condición de contexto (una fórmula lógica sobre las creencias de los agentes) y P es el cuerpo del plan. El cuerpo del plan se construye a partir de los siguientes elementos. Tenemos el paso vacío que siempre tiene éxito y no hace nada, operaciones para agregar (+b) y eliminar (−b) creencias, enviar un mensaje m al agente N (↑N m), y publicar un evento4 (e). Estos pueden ser secuenciados (P; P). La semántica formal para este lenguaje se da en la figura 2. Esta semántica se basa en la semántica para AgentSpeak dada por [12], la cual a su vez se basa en la semántica para CAN [16]. La semántica es al estilo de la Semántica Operacional Estructural de Plotkin, y asume que existen operaciones que verifican si una condición 4 Utilizamos ↓N m como abreviatura para el evento correspondiente a recibir el mensaje m del agente N. 874 El Sexto Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Figura 1: Máquina de Estados Finitos para NetBill (sombras = estados finales) sigue de un conjunto de creencias, que añade una creencia a un conjunto de creencias, y que elimina una creencia de un conjunto de creencias. En el caso de que las creencias sean un conjunto de átomos fundamentales, estas operaciones son respectivamente verificación de consecuencias (B |= C), y adición de conjunto (B ∪ {b}) y eliminación (B \\ {b}). Se pueden utilizar métodos más sofisticados de gestión de creencias, pero no se consideran aquí. Definimos una configuración básica S = Q, N, B, P donde Q es una cola de mensajes (global) (modelada como una secuencia donde los mensajes se agregan en un extremo y se eliminan en el otro extremo), N es el nombre del agente, B son las creencias del agente y P es el cuerpo del plan que se está ejecutando (es decir, la intención). También definimos una configuración de agente, donde en lugar de un único cuerpo de plan P hay un conjunto de instancias de plan, Γ. Finalmente, un MAS completo es un par Q, As de una cola de mensajes global Q y un conjunto de configuraciones de agentes (sin la cola, Q). La cola de mensajes global es una secuencia de tríos de la forma remitente:destinatario:mensaje. Una transición S0 −→ S1 especifica que ejecutar S0 en un solo paso produce S1. Anotamos la flecha con una indicación de si la configuración en cuestión es básica, una configuración de agente o una configuración de MAS. La relación de transición se define utilizando reglas de la forma S −→ S o de la forma S −→ Sr S −→ Sr; estas últimas son condicionales, donde el numerador es la premisa y el denominador es la conclusión. Ten en cuenta que hay no determinismo en SAAPL, por ejemplo, la elección del plan a ejecutar de un conjunto de planes aplicables. Esto se resuelve utilizando funciones de selección: SO selecciona una de las instancias de plan aplicables para manejar un evento dado, SI selecciona cuál de las instancias de plan que pueden ejecutarse debe ejecutarse a continuación, y SA selecciona qué agente debe ejecutar (un paso) a continuación. 3. IMPLEMENTANDO INTERACCIONES BASADAS EN COMPROMISOS En esta sección presentamos un mapeo de una máquina de compromisos a una colección de programas SAAPL (uno para cada rol). Comenzamos considerando el caso simple de dos agentes interactuantes, y el operador + se utiliza para denotar la concatenación de secuencias. Supongamos que los agentes actúan por turnos. En la sección 4 relajamos estas suposiciones. Cada acción A(X) : P ⇒ E se asigna a una serie de planes: hay un plan (para el agente X) con condición de contexto P que realiza la acción (es decir, aplica los efectos E a las creencias del agente) y envía un mensaje al otro agente, y un plan (para el otro agente) que actualiza su estado cuando recibe un mensaje de X. Por ejemplo, dado la acción sendAccept(C) ⇒ accept tenemos los siguientes planes, donde cada plan está precedido por M: o C: para indicar a qué agente pertenece ese plan. Ten en cuenta que cuando la identidad del remitente (o destinatario) es obvia, es decir, el otro agente, abreviamos ↑N m a ↑m (o ↓N m a ↓m). El intercambio de turnos se captura a través del evento ı (abreviatura de interactuar): el agente que está activo tiene un evento ı que está siendo manejado. Manejar el evento implica enviar un mensaje al otro agente y luego no hacer nada hasta recibir una respuesta. C: ı : verdadero ← +aceptar; ↑enviarAceptar. M: ↓sendAccept : true ← +accept; ı.\nM: ↓enviarAceptar : verdadero ← +aceptar; ı. Si la acción tiene una condición previa no trivial, entonces hay dos planes en el receptor: uno para realizar la acción (si es posible) y otro para informar un error si la condición previa de la acción no se cumple (volvemos a esto en la sección 4). Por ejemplo, la acción sendReceipt(M) : pay ⇒ receipt genera los siguientes planes: M: ı : pay ← +receipt; ↑sendReceipt. C: ↓enviarRecibo : pagar ← +recibo; ı. C: ↓enviarRecibo : ¬pagar ← . . . informar error . . . . Además de estos planes, también necesitamos planes para empezar y terminar la interacción. Una interacción puede completarse cuando no hay compromisos a nivel base, por lo que ambos agentes tienen los siguientes planes: ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓hecho : ∃p.C(p) ← . . . informar error . . . . Una interacción se inicia configurando las creencias iniciales de un agente y luego haciéndolo comenzar a interactuar. Exactamente cómo hacer esto depende de la plataforma del agente: por ejemplo, la plataforma del agente en cuestión puede ofrecer una forma sencilla de cargar creencias desde un archivo. Un enfoque genérico que es un poco engorroso, pero es portátil, es enviar a cada uno de los agentes involucrados en la interacción una secuencia de mensajes de inicio, cada uno El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 875 Q, N, B, +b Básico −→ Q, N, B ∪ {b}, Q, N, B, −b Básico −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Básico −→ Q, N, B, SO(Δ) Q, N, B, P1 Básico −→ Q, N, B, P Q, N, B, P1; P2 Básico −→ Q, N, B, P; P2 Q, N, B, ; P Básico −→ Q, N, B, P Q, N, B, ↑NB m Básico −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agente −→ Q, N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Básico −→ Q, N, B, P Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) ∪ {P} P = SI(Γ) P = Q, N, B, Γ Agente −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agente −→ Q, N, B, Γ Q, As MAS −→ Q, (As ∪ {N, B, Γ}) \\ {N, B, Γ} Figura 2: Semántica Operacional para SAAPL que contiene una creencia a añadir; y luego enviar a uno de los agentes un mensaje de inicio que comienza la interacción. Ambos agentes tienen los siguientes dos planes: ↓init(B) : verdadero ← +B. ↓start : verdadero ← ı. La Figura 3 muestra los programas SAAPL tanto para el comerciante como para el cliente que implementan el protocolo NetBill. Por concisión, se omiten los planes de informe de errores. Ahora pasamos a refinar las condiciones del contexto. Hay tres refinamientos que consideramos. En primer lugar, debemos evitar realizar acciones que no tengan efecto en el estado de interacción. En segundo lugar, un agente puede querer especificar que ciertas acciones que puede realizar no deben llevarse a cabo a menos que se cumplan condiciones adicionales. Por ejemplo, el cliente puede no querer aceptar la oferta del comerciante a menos que los bienes tengan un precio o propiedad específicos. En tercer lugar, las condiciones de contexto de los planes que finalizan la interacción deben ser refinadas para evitar finalizar la interacción prematuramente. Para cada plan de la forma ı : P ← +E; ↑m, reemplazamos la condición de contexto P con la condición mejorada P ∧ P ∧ ¬E donde P son cualquier condiciones adicionales que el agente desee imponer, y ¬E es la negación de los efectos de la acción. Por ejemplo, el plan de pago de los clientes se convierte en (asumiendo que no hay condiciones adicionales, es decir, no P): ı : bienes ∧ ¬pagar ← +pagar; ↑enviarEPO. Para cada plan de la forma ↓m : P ← +E; ı podríamos agregar ¬E a la precondición, pero esto es redundante, ya que ya es verificado por el ejecutor de la acción, y si la acción no tiene efecto entonces los planes de los clientes: ı : true ← +solicitud; ↑enviarSolicitud. ı : true ← +aceptar; ↑enviarAceptación. ı : mercancías ← +pagar; ↑enviarEPO. ↓enviarCotización : true ← +prometerMercancías; +prometerRecibo; ı. ↓enviarMercancías : true ← +prometerRecibo; +mercancías; ı. ↓enviarRecibo : pagar ← +recibo; ı. Planes de los comerciantes: ı : true ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : true ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ← +recibo; ↑enviarRecibo. ↓enviarSolicitud : true ← +solicitud; ı. ↓enviarAceptación : true ← +aceptar; ı. ↓enviarEPO : mercancías ← +pagar; ı. Planes compartidos (es decir, planes de ambos agentes): ı : ¬∃p.C(p) ← ↑hecho. ↓hecho : ¬∃p.C(p) ← . ↓init(B) : verdadero ← +B. ↓inicio : verdadero ← ı. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 3: Implementación de SAAPL de NetBill el remitente no lo llevará a cabo y enviará el mensaje (ver también la discusión en la sección 4). Al especificar condiciones adicionales (P), es necesario tener cuidado para evitar situaciones en las que no se pueda avanzar porque la única(s) acción(es) posible(s) está(n) impedida(s) por las condiciones adicionales. Una forma de indicar preferencia entre acciones (en muchas plataformas de agentes) es reorganizar los planes de los agentes. Esto es claramente seguro, ya que las acciones no se impiden, simplemente se consideran en un orden diferente. La tercera refinación de las condiciones de contexto se refiere a los planes que terminan la interacción. En el marco de la Máquina de Compromiso, cualquier estado que no tenga un compromiso a nivel base es final, en el sentido de que la interacción puede terminar allí (o puede continuar). Sin embargo, solo algunos de estos estados finales son estados finales deseables. Qué estados finales se consideran deseables depende del dominio y del resultado de interacción deseado. En el ejemplo de NetBill, el estado final deseable es aquel en el que los bienes han sido enviados y pagados, y se ha emitido un recibo (es decir, bienes ∧ pago ∧ recibo). Para evitar que un agente termine la interacción demasiado pronto, agregamos esto como una condición previa al plan de terminación: ı : bienes ∧ pago ∧ recibo ∧ ¬∃p.C(p) ← ↑hecho. La figura 4 muestra los planes que han sido modificados respecto a la figura 3. Para apoyar la realización de los CM, necesitamos cambiar SAAPL de varias maneras. Estos cambios, que se discuten a continuación, pueden aplicarse a los lenguajes BDI existentes para hacerlos compatibles con máquinas de compromiso. Presentamos los tres cambios, explicamos en qué consisten y, para cada cambio, explicamos cómo se implementó el cambio utilizando el lenguaje de programación orientado a agentes 3APL. Las tres modificaciones son: 1. extender las creencias del agente para que puedan contener compromisos; 876 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Planes de los clientes: ı : ¬solicitud ← +solicitud; ↑enviarSolicitud. ı : ¬aceptar ← +aceptar; ↑enviarAceptación. ı : mercancías ∧ ¬pagar ← +pagar; ↑enviarEPO. Planes de los comerciantes: ı : ¬ofrecer ← +promesaMercancías; +promesaRecibo; ↑enviarCotización. ı : ¬(promesaRecibo ∧ mercancías) ← +promesaRecibo; +mercancías; ↑enviarMercancías. ı : pagar ∧ ¬recibo ← +recibo; ↑enviarRecibo. Donde aceptar ≡ CC(bienes pagados) promesaBienes ≡ CC(aceptar bienes) promesaRecibo ≡ CC(pagar recibo) oferta ≡ promesaBienes ∧ promesaRecibo Figura 4: Implementación de SAAPL de NetBill con condiciones de contexto refinadas (solo planes cambiados) 2. cambiando la definición de |= para abarcar compromisos implícitos; y 3. cada vez que se agrega una creencia, actualizando compromisos existentes, de acuerdo con las reglas de dinámica de compromisos. Extender la noción de creencias para abarcar compromisos de hecho no requiere ningún cambio en las plataformas de agentes que son similares a Prolog y admiten términos como creencias (por ejemplo, ...). Jason, 3APL, CAN. Sin embargo, otras plataformas de agentes sí requieren una extensión. Por ejemplo, JACK, que es una extensión de Java, requeriría cambios para admitir compromisos que pueden estar anidados. En el caso de 3APL no se necesita ningún cambio para respaldar esto. Cuando una condición de contexto contiene compromisos, determinar si la condición de contexto está implícita en las creencias de los agentes (B |= C) requiere tener en cuenta la noción de compromisos implícitos [15]. En resumen, se puede considerar que un compromiso sigue de un conjunto de creencias B si el compromiso está en el conjunto de creencias (C ∈ B), pero también bajo otras condiciones. Por ejemplo, un compromiso de pago C(pay) puede considerarse implícito en un conjunto de creencias que contenga pay porque el compromiso pudo haberse mantenido y cumplido cuando pay se hizo verdadero. Se aplican reglas similares para compromisos condicionales. Estas reglas, que fueron introducidas en [15], fueron posteriormente reformuladas en una forma más simple por [14], lo que resultó en las cuatro reglas de inferencia en la parte inferior de la figura 5. La modificación que se necesita hacer en SAAPL para respaldar las implementaciones de máquinas de compromiso es extender la definición de |= para incluir estas cuatro reglas. Para 3APL esto se logró al hacer que cada agente incluyera las siguientes cláusulas de Prolog: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)). La primera cláusula simplemente dice que cualquier cosa es válida si está en las creencias de los agentes (la cláusula(X, verdadero) es verdadera si X es un hecho). Las cuatro cláusulas restantes corresponden respectivamente a las reglas de inferencia C1, C2, CC1 y CC2. Para utilizar estas reglas, modificamos las condiciones de contexto en nuestro programa para que en lugar de escribir, por ejemplo, cc(m,c, pagar, recibo), escribamos holds(cc(m,c, pagar, recibo)). La última modificación es actualizar los compromisos cuando se agrega una creencia. Formalmente, esto se hace modificando la regla semántica para la adición de creencias de manera que aplique un algoritmo para actualizar compromisos. La regla y algoritmo modificados (que reflejan la definición de norma en [14]) se pueden encontrar en la parte superior de la figura 5. Para 3APL, este cambio final se logró insertando manualmente update() después de actualizar creencias, y definiendo las siguientes reglas para update(): update() <- c(P) Y holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) Y holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) Y holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) Y holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip donde Deletec y Deletecc eliminan respectivamente un compromiso de nivel base y un compromiso condicional, y Addc agrega un compromiso de nivel base. Un aspecto que no requiere un cambio es vincular compromisos y acciones. Esto se debe a que los compromisos no activan acciones directamente: pueden activar acciones de forma indirecta, pero en general su efecto es prevenir la finalización de una interacción mientras existan compromisos pendientes (a nivel base). La Figura 6 muestra las secuencias de mensajes de varias ejecuciones de una implementación de 3APL de la máquina de compromiso NetBill. Para ilustrar las diferentes interacciones posibles, el código fue modificado para que cada agente seleccionara aleatoriamente entre las acciones que podía realizar, y se realizaron una serie de ejecuciones con el cliente como iniciador, y luego con el comerciante como iniciador. Hay otras posibles secuencias de mensajes, no mostradas, 6 El código fuente está disponible en http://www.winikoff.net/CM La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 877 Figura 6: Ejecuciones de muestra de la implementación de 3APL (turnos alternados) incluyendo la obvia: solicitud, cotización, aceptación, bienes, pago, recibo y luego finalizado. Una pequeña diferencia entre la implementación de 3APL y SAAPL concierne a la semántica de los mensajes. En la semántica de SAAPL (y de la mayoría de los AOPLs), recibir un mensaje se trata como un evento. Sin embargo, en 3APL, recibir un mensaje se modela como la adición a las creencias de los agentes de un hecho que indica que el mensaje fue recibido [6]. Por lo tanto, en la implementación de 3APL tenemos reglas de PG que son activadas por estas creencias, en lugar de por cualquier evento. Un problema con este enfoque es que la creencia permanece allí, por lo que necesitamos asegurarnos de que la creencia en cuestión sea eliminada una vez resuelta, o que modifiquemos las precondiciones de los planes para evitar manejarla más de una vez. En nuestra implementación eliminamos estas creencias recibidas una vez que son procesadas, para evitar el manejo duplicado de mensajes. 4. MÁS ALLÁ DE DOS PARTICIPANTES Generalizar a más de dos participantes en la interacción requiere volver a examinar cómo se gestiona el turno, ya que ya no es posible asumir turnos alternados [7]. De hecho, quizás sorprendentemente, ¡incluso en el escenario de dos participantes, un sistema de turnos alternados es una suposición poco razonable! Por ejemplo, considera el camino (en la figura 1) desde el estado 1 al 15 (enviarMercancía) y luego al estado 12 (enviarAceptación). El resultado, en una configuración de turno alternado, es un callejón sin salida: solo hay una acción posible en el estado 12, que es enviar EPO, pero esta acción la realiza el cliente, ¡y es el turno del comerciante de actuar! La Figura 7 muestra el MEF para NetBill con iniciativa alternante. Una solución a este problema que funciona en este ejemplo, pero no se generaliza, es debilitar el régimen de toma de turnos alternados al permitir que un agente actúe dos veces seguidas si su segunda acción está motivada por un compromiso. Una solución general es llevar un registro de quién debe actuar en cada turno. Esto se puede lograr al determinar qué agentes tienen acciones que pueden ser realizadas en el estado actual. Si solo hay un agente activo, entonces está claro que los agentes deben actuar. Sin embargo, si más de un agente está activo, de alguna manera los agentes deben determinar quién debe actuar a continuación. Resolver esto mediante negociación no es una solución especialmente buena por dos razones. En primer lugar, esta negociación debe realizarse en cada paso de la interacción en la que más de un agente esté activo (en NetBill, esto se aplica a siete de dieciséis estados), por lo que es altamente deseable contar con un mecanismo ligero para hacerlo. En segundo lugar, no está claro cómo la negociación puede evitar una situación de regresión infinita (tú primero, no, tú primero, ...) sin imponer alguna regla arbitraria. También es posible resolver quién debe actuar imponiendo una regla arbitraria, por ejemplo, que el cliente siempre actúe en preferencia al comerciante, o que cada agente tenga una prioridad numérica (quizás determinada por el orden en el que se unieron a la interacción) que determine quién actúa. Una solución alternativa, que explota las propiedades simétricas de las máquinas de compromiso, es no intentar gestionar el turno. Consideremos las acciones A1(C) ⇒ p, A2(C) ⇒ q y A3(M) : p ∧ q ⇒ r. En lugar de rastrear y controlar de quién es el turno, simplemente permitimos que los agentes actúen libremente y confiamos en las propiedades del espacio de interacción para garantizar que las cosas funcionen, una noción que precisaremos y demostraremos en el resto de esta sección. El problema de tener múltiples agentes activos simultáneamente es que en lugar de que todos los agentes estén de acuerdo en el estado de interacción actual, los agentes pueden estar en estados diferentes. Esto se puede visualizar como cada agente teniendo su propia copia de la MEF por la que navega, donde es posible que los agentes sigan diferentes caminos a través de la MEF. Los dos problemas específicos que deben abordarse son: 1. ¿Pueden los agentes terminar en diferentes estados finales? 2. ¿Puede un agente encontrarse en una posición en la que se produce un error porque no puede realizar una acción correspondiente a un mensaje recibido? Mostraremos que, debido a que las acciones conmutan bajo ciertas suposiciones, los agentes no pueden terminar en diferentes estados finales, y además, que los errores no pueden ocurrir (de nuevo, bajo ciertas suposiciones). Por acciones conmutativas nos referimos al estado resultante de realizar una secuencia de acciones A1... \"Un es lo mismo, independientemente del orden en que se realicen las acciones.\" Esto significa que incluso si los agentes siguen diferentes caminos a través del FSM, aún terminan en el mismo estado resultante, porque una vez que todos los mensajes han sido procesados, todos los agentes habrán realizado el mismo conjunto de acciones. Esto aborda el problema de terminar en diferentes estados finales. Regresamos a la posibilidad de que ocurran errores pronto. Definición 1 (Monotonía): Una acción es monótona si no elimina ningún fluente o compromiso. Una Máquina de Compromisos es aquella que elimina directamente, está bien liberar compromisos agregando fluents/compromisos. 878 La Sexta Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es monótona si todas sus acciones son monótonas. (Adaptado de [14, Definición 6]) Teorema 1: Si A1 y A2 son acciones monótonas, entonces realizar A1 seguido de A2 tiene el mismo efecto en las creencias de los agentes que realizar A2 seguido de A1. (Adaptado de [14, Teorema 2]). Esto asume que ambas acciones pueden ser realizadas. Sin embargo, es posible que el rendimiento de A1 impida que se realice A2. Por ejemplo, si A1 tiene el efecto +p, y A2 tiene la precondición ¬p, entonces aunque ambas acciones pueden estar habilitadas en el estado inicial, no pueden realizarse en ningún orden. Podemos prevenir esto asegurándonos de que las condiciones previas de las acciones no contengan negaciones (o implicaciones), ya que una acción monótona no puede hacer que una condición previa libre de negaciones se vuelva falsa. Ten en cuenta que esta restricción solo se aplica a la precondición de acción original, P, no a cualquier precondición adicional impuesta por el agente (P ). Esto se debe a que solo P se utiliza para determinar si otro agente es capaz de realizar la acción. Por lo tanto, los CMs monótonos con precondiciones que no contienen negaciones tienen acciones que conmutan. Sin embargo, de hecho, la restricción a los CM monótonos es innecesariamente fuerte: todo lo que se necesita es que cuando haya una elección de agente que pueda actuar, entonces las acciones posibles sean monótonas. Si solo hay un agente que puede actuar, entonces no se necesita ninguna restricción en las acciones: pueden ser o no monótonas. Definición 2 (Localmente Monótona): Una máquina de compromiso es localmente monótona si, para cualquier estado S, o bien (a) solo un agente tiene acciones que pueden realizarse; o (b) todas las acciones que pueden realizarse en S son monótonas. Teorema 2 En un CM localmente monótono, una vez que todos los mensajes hayan sido procesados, todos los agentes estarán en el mismo estado. Además, no pueden ocurrir errores. Prueba: Una vez que todos los mensajes hayan sido procesados, tendremos que todos los agentes habrán realizado el mismo conjunto de acciones, quizás en un orden diferente. La esencia de la prueba es argumentar que mientras los agentes no hayan convergido al mismo estado, todas las acciones deben ser monótonas, por lo tanto, estas acciones son conmutativas y no pueden deshabilitar ninguna otra acción. Considera el primer punto de divergencia, donde un agente realiza la acción A y al mismo tiempo otro agente (llamémoslo XB) realiza la acción B. Claramente, este estado tiene acciones de más de un agente habilitadas, por lo tanto, dado que el CM es localmente monótono, las acciones relevantes deben ser monótonas. Por lo tanto, después de realizar A, la acción B aún debe estar habilitada, y así el mensaje para hacer B puede ser procesado actualizando las creencias de los agentes receptores con los efectos de B. Además, dado que las acciones monótonas conmutan, el resultado de hacer A antes que B es el mismo que hacer B antes que A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB Sin embargo, ¿qué sucede si la siguiente acción después de A no es B, sino C? Dado que B está habilitado, y C no es realizado por el agente XB (ver abajo), debemos tener que C también es monótono, y por lo tanto (a) el resultado de hacer A y B y C es el mismo independientemente del orden en que se realicen las tres acciones; y (b) C no deshabilita a B, por lo que B aún puede hacerse después de C. La razón por la que C no puede ser realizado por XB es que los mensajes se procesan en el orden de su llegada. Desde la perspectiva de XB, la acción B se realizó antes que C, y por lo tanto, desde la perspectiva de cualquier otro agente, el mensaje que indica que B se realizó debe ser recibido (y procesado) antes que un mensaje que indique que C se ha completado. Este argumento se puede extender para demostrar que una vez que los agentes comienzan a tomar diferentes caminos a través del FSM, todas las acciones tomadas hasta el punto en el que convergen en un solo estado deben ser monótonas, y por lo tanto siempre es posible converger (porque las acciones no están deshabilitadas), por lo que la interacción es libre de errores; y el estado resultante una vez que ocurre la convergencia es el mismo (porque las acciones monótonas conmutan). Este teorema proporciona una garantía teórica sólida de que no gestionar los turnos no conducirá a un desastre. Esto es análogo a demostrar que deshabilitar todos los semáforos no provocaría ningún accidente, y solo es posible porque los axiomas refinados de CM son simétricos. Basándose en este teorema, la transformación genérica de CM a código debería permitir a los agentes actuar libremente, lo cual se logra simplemente cambiando ı : P ∧ P ∧ ¬E ← +E; ↑A a ı : P ∧ P ∧ ¬E ← +E; ↑A; ı. Por ejemplo, en lugar de ı : ¬request ← +request; ↑sendRequest tenemos ı : ¬request ← +request; ↑sendRequest; ı. Una consecuencia del teorema es que no es necesario asegurarse de que los agentes procesen los mensajes antes de continuar interactuando. Sin embargo, para evitar un paralelismo innecesario, que puede dificultar la depuración, aún puede ser deseable procesar los mensajes antes de realizar acciones. La Figura 8 muestra una serie de ejecuciones de la implementación de 3APL que ha sido modificada para permitir interacción libre, no alternante. 5. DISCUSIÓN Hemos presentado un esquema para mapear máquinas de compromiso a plataformas BDI (utilizando SAAPL como ejemplo), identificado tres cambios que debían hacerse en SAAPL para respaldar la interacción basada en CM, y demostrado que la gestión de turnos puede evitarse en la interacción basada en CM, siempre que el CM sea localmente monótono. Las tres modificaciones a SAAPL y el esquema de traducción de máquina de compromiso a planes BDI son aplicables a cualquier lenguaje BDI. Como hemos mencionado en la sección 1, ha habido cierto trabajo en el diseño de interacciones de agentes flexibles y robustas, pero prácticamente no hay trabajo en la implementación de interacciones flexibles y robustas. Ya hemos discutido STAPLE [9, 10]. Otra pieza de trabajo relevante es el trabajo de Cheong y Winikoff sobre su metodología Hermes [2]. Aunque el enfoque principal de su trabajo es una metodología de diseño pragmática, también proporcionan pautas para implementar diseños de Hermes utilizando plataformas BDI (específicamente Jadex) [3]. Sin embargo, dado que Hermes no produce un diseño formal, solo es posible generar un código esquelético que luego debe completarse. Además, no abordan el problema de tomar turnos: cómo decidir qué agente actúa cuando más de un agente puede actuar. También asumimos que el medio de comunicación no entrega mensajes fuera de orden, como es el caso de (por ejemplo). TCP. El Sexto Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 879 Figura 8: Ejecuciones de muestra de la implementación de 3APL (turnos no alternantes). El trabajo de Kremer y Flores (por ejemplo, [8]) también utiliza compromisos y aborda la implementación. Sin embargo, ofrecen soporte de infraestructura (CASA) en lugar de un lenguaje de programación, y no parecen brindar asistencia a un programador que busque implementar agentes. Aunque hemos implementado la <br>interacción de NetBill</br> utilizando 3APL, los cambios en la semántica se realizaron modificando nuestro programa de NetBill 3APL, en lugar de modificar la implementación de 3APL en sí misma. Claramente, sería deseable modificar la semántica de 3APL (o de otro lenguaje) directamente, cambiando la implementación. Además, aunque no lo hayamos hecho, debería quedar claro que la traducción de un CM a su implementación podría automatizarse fácilmente. Otra área para futuros trabajos es examinar cómo se pueden relajar las suposiciones necesarias para garantizar que las acciones conmuten. Finalmente, es necesario realizar una evaluación empírica. Ya se ha realizado algo de trabajo comparando Hermes con un enfoque convencional centrado en mensajes para diseñar interacciones, y esto ha demostrado que el uso de Hermes resulta en diseños significativamente más flexibles y robustos [4]. Sería interesante comparar las máquinas de compromiso con Hermes, pero, dado que las máquinas de compromiso son un marco de trabajo, no una metodología de diseño, necesitamos comparar Hermes con una metodología para diseñar interacciones que resulte en máquinas de compromiso [13, 17]. 6. REFERENCIAS [1] R. H. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores. Programación multiagente: lenguajes, plataformas y aplicaciones. Springer, 2005. [2] C. Cheong y M. Winikoff. Hermes: Diseñando interacciones de agentes orientadas a objetivos. En Actas del 6º Taller Internacional de Ingeniería de Software Orientada a Agentes (AOSE-2005), julio de 2005. [3] C. Cheong y M. Winikoff. Hermes: Implementando interacciones de agentes orientadas a objetivos. En Actas del Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), julio de 2005. [4] C. Cheong y M. Winikoff. Hermes versus Prometeo: Una evaluación comparativa de dos enfoques de diseño de interacción de agentes. Presentado para su publicación, 2007. [5] P. R. Cohen y H. J. Levesque. Trabajo en equipo. Nosotros, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham y F. Dignum. Comunicación para agentes dirigidos por objetivos. En Actas del Taller de Lenguajes de Comunicación de Agentes y Políticas de Conversación, 2002. [7] F. P. Dignum y G. A. Vreeswijk. Hacia un banco de pruebas para diálogos de múltiples partes. En Avances en Comunicación de Agentes, páginas 212-230. Springer, LNCS 2922, 2004. [8] R. Kremer y R. Flores. Utilizando una retícula de subsumición performativa para apoyar conversaciones basadas en compromisos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 114-121. ACM Press, 2005. [9] S. Kumar y P. R. Cohen. STAPLE: Un lenguaje de programación de agentes basado en la teoría de la intención conjunta. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 2004), páginas 1390-1391. ACM Press, julio de 2004. [10] S. Kumar, M. J. Huber y P. R. Cohen. Representando y ejecutando protocolos como acciones conjuntas. En Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 543 - 550, Bolonia, Italia, 15 - 19 de julio de 2002. ACM Press. [11] M. Tambe y W. Zhang. Hacia un trabajo en equipo flexible en equipos persistentes: Informe ampliado. Revista de Agentes Autónomos y Sistemas Multiagente, 2000. Número especial sobre lo mejor de ICMAS 98. [12] M. Winikoff. Un meta-intérprete de AgentSpeak y sus aplicaciones. En el Tercer Taller Internacional sobre Programación de Sistemas Multiagente (ProMAS), páginas 123-138. Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.\nSpringer, LNCS 3862 (actas posteriores, 2006), 2005. [13] M. Winikoff. Diseñando interacciones de agentes basadas en compromisos. En Actas de la Conferencia Internacional de Tecnología de Agentes Inteligentes (IAT-06) de IEEE/WIC/ACM de 2006. [14] M. Winikoff. Implementando interacciones de agentes flexibles y robustas utilizando máquinas de compromiso distribuidas. Sistemas Multiagente y de Red, 2(4), 2006. [15] M. Winikoff, W. Liu y J. Harland. Mejorando máquinas de compromiso. En J. Leite, A. Omicini, P. Torroni y P. Yolum, editores, Declarative Agent Languages and Technologies II, número 3476 en las Notas de Conferencias en Inteligencia Artificial (LNAI), páginas 198-220. Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Actas de la Octava Conferencia Internacional sobre Principios de Representación del Conocimiento y Razonamiento (KR2002), Toulouse, Francia, 2002. [17] P. Yolum. Hacia herramientas de diseño para el desarrollo de protocolos. En F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh y M. Wooldridge, editores, Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 99-105. ACM Press, 2005. [18] P. Yolum y M. P. Singh. Especificación y ejecución flexible del protocolo: Aplicación de la planificación del cálculo de eventos utilizando compromisos. En Actas de la 1ª Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS), páginas 527-534, 2002. [19] P. Yolum y M. P. Singh. Razonamiento sobre compromisos en el cálculo de eventos: Un enfoque para especificar y ejecutar protocolos. Anales de Matemáticas e Inteligencia Artificial (AMAI), 2004. 880 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "commitment machine": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a <br>commitment machine</br> to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs <br>commitment machine</br> (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine</br> framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A <br>commitment machine</br> (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A <br>commitment machine</br> (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given <br>commitment machine</br> is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] <br>commitment machine</br>: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a <br>commitment machine</br> to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the <br>commitment machine</br> framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them <br>commitment machine</br> supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support <br>commitment machine</br> implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A <br>commitment machine</br> is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A <br>commitment machine</br> is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from <br>commitment machine</br> to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "The contributions of this paper are: a mapping from a <br>commitment machine</br> to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs <br>commitment machine</br> (CM) framework [19].",
                "BACKGROUND 2.1 Commitment Machines The aim of the <br>commitment machine</br> framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A <br>commitment machine</br> (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "A <br>commitment machine</br> (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state."
            ],
            "translated_annotated_samples": [
                "Las contribuciones de este artículo son: un mapeo de una <br>máquina de compromiso</br> a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas.",
                "Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la <br>máquina de compromisos</br> (CM) de Yolum & Singh [19].",
                "ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las <br>máquinas de compromiso</br> es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes.",
                "Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción.",
                "Una <br>máquina de compromiso</br> (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una <br>máquina de compromiso</br> a una colección de planes de estilo BDI; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la <br>máquina de compromisos</br> (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los AOPLs BDI que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las <br>máquinas de compromiso</br> es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una <br>máquina de compromiso</br> (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. ",
            "candidates": [],
            "error": [
                [
                    "máquina de compromiso",
                    "máquina de compromisos",
                    "máquinas de compromiso",
                    "máquina de compromiso"
                ]
            ]
        },
        "agent orient program language": {
            "translated_key": "programa orientado a agentes",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "belief desire intention": {
            "translated_key": "creencia deseo intención",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of BDI-style plans; extensions to the semantics of BDI programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending BDI-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of BDI AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the BDI tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (BDI) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing BDI languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to BDI platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to BDI plans are both applicable to any BDI language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using BDI platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "bdi": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Implementing Commitment-Based Interactions∗ Michael Winikoff School of Computer Science and IT RMIT University Melbourne, Australia michael.winikoff@rmit.edu.au ABSTRACT Although agent interaction plays a vital role in MAS, and messagecentric approaches to agent interaction have their drawbacks, present agent-oriented programming languages do not provide support for implementing agent interaction that is flexible and robust.",
                "Instead, messages are provided as a primitive building block.",
                "In this paper we consider one approach for modelling agent interactions: the commitment machines framework.",
                "This framework supports modelling interactions at a higher level (using social commitments), resulting in more flexible interactions.",
                "We investigate how commitmentbased interactions can be implemented in conventional agent-oriented programming languages.",
                "The contributions of this paper are: a mapping from a commitment machine to a collection of <br>bdi</br>-style plans; extensions to the semantics of <br>bdi</br> programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent systems; I.2.5 [Artificial Intelligence]: Programming Languages and Software General Terms Design 1.",
                "INTRODUCTION Agents are social, and agent interaction plays a vital role in multiagent systems.",
                "Consequently, design and implementation of agent interaction is an important research topic.",
                "The standard approach for designing agent interactions is messagecentric: interactions are defined by interaction protocols that give the permissible sequences of messages, specified using notations such as finite state machines, Petri nets, or Agent UML.",
                "It has been argued that this message-centric approach to interaction design is not a good match for intelligent agents.",
                "Intelligent agents should exhibit the ability to persist in achieving their goals in the face of failure (robustness) by trying different approaches (flexibility).",
                "On the other hand, when following an interaction protocol, an agent has limited flexibility and robustness: the ability to persistently try alternative means to achieving the interactions aim is limited to those options that the protocols designer provided, and in practice, message-centric design processes do not tend to lead to protocols that are flexible or robust.",
                "Recognising these limitations of the traditional approach to designing agent interactions, a number of approaches have been proposed in recent years that move away from message-centric interaction protocols, and instead consider designing agent interactions using higher-level concepts such as social commitments [8, 10, 18] or interaction goals [2].",
                "There has also been work on richer forms of interaction in specific settings, such as teams of cooperative agents [5, 11].",
                "However, although there has been work on designing flexible and robust agent interactions, there has been virtually no work on providing programming language support for implementing such interactions.",
                "Current Agent Oriented Programming Languages (AOPLs) do not provide support for implementing flexible and robust agent interactions using higher-level concepts than messages.",
                "Indeed, modern AOPLs [1], with virtually no exceptions, provide only simple message sending as the basis for implementing agent interaction.",
                "This paper presents what, to the best of our knowledge, is the second AOPL to support high-level, flexible, and robust agent interaction implementation.",
                "The first such language, STAPLE, was proposed a few years ago [9], but is not described in detail, and is arguably impractical for use by non-specialists, due to its logical basis and heavy reliance on temporal and modal logic.",
                "This paper presents a scheme for extending <br>bdi</br>-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of <br>bdi</br> AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "We then present a scheme for translating commitment machines to this language, and indicate how the language needs to be extended to support this.",
                "We then extend our scheme to address a range of issues concerned with distribution, including turn tracking [7], and race conditions. 2.",
                "BACKGROUND 2.1 Commitment Machines The aim of the commitment machine framework is to allow for the definition of interactions that are more flexible than traditional message-centric approaches.",
                "A Commitment Machine (CM) [19] specifies an interaction between entities (e.g. agents, services, processes) in terms of actions that change the interaction state.",
                "This interact state consists of fluents (predicates that change value over time), but also social commitments, both base-level and conditional.",
                "A base-level social commitment is an undertaking by debtor A to creditor B to bring about condition p, denoted C(A, B, p).",
                "This is sometimes abbreviated to C(p), where it is not important to specify the identities of the entities in question.",
                "For example, a commitment by customer C to merchant M to make the fluent paid true would be written as C(C, M, paid).",
                "A conditional social commitment is an undertaking by debtor A to creditor B that should condition q become true, A will then commit to bringing about condition p. This is denoted by CC(A, B, q, p), and, where the identity of the entities involved is unimportant (or obvious), is abbreviated to CC(q p) where the arrow is a reminder of the causal link between q becoming true and the creation of a commitment to make p true.",
                "For example, a commitment to make the fluent paid true once goods have been received would be written CC(goods paid).",
                "The semantics of commitments (both base-level and conditional) is defined with rules that specify how commitments change over time.",
                "For example, the commitment C(p) (or CC(q p)) is discharged when p becomes true; and the commitment CC(q p) is replaced by C(p) when q becomes true.",
                "In this paper we use the more symmetric semantics proposed by [15] and subsequently reformalised by [14].",
                "In brief, these semantics deal with a number of more complex cases, such as where commitments are created when conditions already hold: if p holds when CC(p q) is meant to be created, then C(q) is created instead of CC(p q).",
                "An interaction is defined by specifying the entities involved, the possible contents of the interaction state (both fluents and commitments), and (most importantly) the actions that each entity can perform along with the preconditions and effects of each action, specified as add and delete lists.",
                "A commitment machine (CM) defines a range of possible interactions that each start in some state1 , and perform actions until reaching a final state.",
                "A final state is one that has no base-level commitments.",
                "One way of visualising the interactions that are possible with a given commitment machine is to generate the finite state machine corresponding to the CM.",
                "For example, figure 1 gives the FSM2 corresponding to the NetBill [18] commitment machine: a simple CM where a customer (C) and merchant (M) attempt to trade using the following actions3 : 1 Unlike standard interaction protocols, or finite state machines, there is no designated initial state for the interaction. 2 The finite state machine is software-generated: the nodes and connections were computed by an implementation of the axioms (available from http://www.winikoff.net/CM) and were then laid out by graphviz (http://www.graphviz.org/). 3 We use the notation A(X) : P ⇒ E to indicate that action A is performed by entity X, has precondition P (with : P omitted if empty) and effect E. • sendRequest(C) ⇒ request • sendQuote(M) ⇒ offer where offer ≡ promiseGoods ∧ promiseReceipt and promiseGoods ≡ CC(M, C, accept, goods) and promiseReceipt ≡ CC(M, C, pay, receipt) • sendAccept(C) ⇒ accept where accept ≡ CC(C, M, goods, pay) • sendGoods(M) ⇒ promiseReceipt ∧ goods where promiseReceipt ≡ CC(M, C, pay, receipt) • sendEPO(C) : goods ⇒ pay • sendReceipt(M) : pay ⇒ receipt.",
                "The commitment accept is the customers promise to pay once goods have been sent, promiseGoods is the merchants promise to send the goods once the customer accepts, and promiseReceipt is the merchants promise to send a receipt once payment has been made.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the <br>bdi</br> tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "Given a collection of plans and an event e that has been posted the agent first collects all plans types that are triggered by that event (the relevant plans), then evaluates the context conditions of these plans to obtain a set of applicable plan instances.",
                "One of these is chosen and is executed.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (<br>bdi</br>) Agent Programming Language (SAAPL).",
                "This language is intended to be an abstraction that is in the common subset of such languages as Jason [1, Chapter 1], 3APL [1, Chapter 2], and CAN [16].",
                "Thus, it is intentionally incomplete in some areas, for instance it doesnt commit to a particular mechanism for dealing with plan failure, since different mechanisms are used by different AOPLs.",
                "An agent program (denoted by Π) consists of a collection of plan clauses of the form e : C ← P where e is an event, C is a context condition (a logical formula over the agents beliefs), and P is the plan body.",
                "The plan body is built up from the following constructs.",
                "We have the empty step which always succeeds and does nothing, operations to add (+b) and delete (−b) beliefs, sending a message m to agent N (↑N m), and posting an event4 (e).",
                "These can be sequenced (P; P).",
                "C ::= b | C ∧ C | C ∨ C | ¬C | ∃x.C P ::= | +b | −b | e | ↑N m | P; P Formal semantics for this language is given in figure 2.",
                "This semantics is based on the semantics for AgentSpeak given by [12], which in turn is based on the semantics for CAN [16].",
                "The semantics is in the style of Plotkins Structural Operational Semantics, and assumes that operations exist that check whether a condition 4 We use ↓N m as short hand for the event corresponding to receiving message m from agent N. 874 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Figure 1: Finite State Machine for NetBill (shaded = final states) follows from a belief set, that add a belief to a belief set, and that delete a belief from a belief set.",
                "In the case of beliefs being a set of ground atoms these operations are respectively consequence checking (B |= C), and set addition (B ∪ {b}) and deletion (B \\ {b}).",
                "More sophisticated belief management methods may be used, but are not considered here.",
                "We define a basic configuration S = Q, N, B, P where Q is a (global) message queue (modelled as a sequence5 where messages are added at one end and removed from the other end), N is the name of the agent, B is the beliefs of the agent and P is the plan body being executed (i.e. the intention).",
                "We also define an agent configuration, where instead of a single plan body P there is a set of plan instances, Γ.",
                "Finally, a complete MAS is a pair Q, As of a global message queue Q and a set of agent configurations (without the queue, Q).",
                "The global message queue is a sequence of triplets of the form sender:recipient:message.",
                "A transition S0 −→ S1 specifies that executing S0 a single step yields S1.",
                "We annotate the arrow with an indication of whether the configuration in question is basic, an agent configuration, or a MAS configuration.",
                "The transition relation is defined using rules of the form S −→ S or of the form S −→ Sr S −→ Sr ; the latter are conditional with the top (numerator) being the premise and the bottom (denominator) being the conclusion.",
                "Note that there is non-determinism in SAAPL, e.g. the choice of plan to execute from a set of applicable plans.",
                "This is resolved by using selection functions: SO selects one of the applicable plan instances to handle a given event, SI selects which of the plan instances that can be executed should be executed next, and SA selects which agent should execute (a step) next. 3.",
                "IMPLEMENTING COMMITMENT-BASED INTERACTIONS In this section we present a mapping from a commitment machine to a collection of SAAPL programs (one for each role).",
                "We begin by considering the simple case of two interacting agents, and 5 The + operator is used to denote sequence concatenation. assume that the agents take turns to act.",
                "In section 4 we relax these assumptions.",
                "Each action A(X) : P ⇒ E is mapped to a number of plans: there is a plan (for agent X) with context condition P that performs the action (i.e. applies the effects E to the agents beliefs) and sends a message to the other agent, and a plan (for the other agent) that updates its state when a message is received from X.",
                "For example, given the action sendAccept(C) ⇒ accept we have the following plans, where each plan is preceded by M: or C: to indicate which agent that plan belongs to.",
                "Note that where the identify of the sender (respectively recipient) is obvious, i.e. the other agent, we abbreviate ↑N m to ↑m (resp. ↓N m to ↓m).",
                "Turn taking is captured through the event ı (short for interact): the agent that is active has an ı event that is being handled.",
                "Handling the event involves sending a message to the other agent, and then doing nothing until a response is received.",
                "C: ı : true ← +accept; ↑sendAccept.",
                "M: ↓sendAccept : true ← +accept; ı.",
                "If the action has a non-trivial precondition then there are two plans in the recipient: one to perform the action (if possible), and another to report an error if the actions precondition doesnt hold (we return to this in section 4).",
                "For example, the action sendReceipt(M) : pay ⇒ receipt generates the following plans: M: ı : pay ← +receipt; ↑sendReceipt.",
                "C: ↓sendReceipt : pay ← +receipt; ı.",
                "C: ↓sendReceipt : ¬pay ← . . . report error . . . .",
                "In addition to these plans, we also need plans to start and finish the interaction.",
                "An interaction can be completed whenever there are no base-level commitments, so both agents have the following plans: ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓done : ∃p.C(p) ← . . . report error . . . .",
                "An interaction is started by setting up an agents initial beliefs, and then having it begin to interact.",
                "Exactly how to do this depends on the agent platform: e.g. the agent platform in question may offer a simple way to load beliefs from a file.",
                "A generic approach that is a little cumbersome, but is portable, is to send each of the agents involved in the interaction a sequence of init messages, each The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 875 Q, N, B, +b Basic −→ Q, N, B ∪ {b}, Q, N, B, −b Basic −→ Q, N, B \\ {b}, Δ = {Piθ|(ti : ci ← Pi) ∈ Π ∧ tiθ = e ∧ B |= ciθ} Q, N, B, e Basic −→ Q, N, B, SO(Δ) Q, N, B, P1 Basic −→ Q , N, B , P Q, N, B, P1; P2 Basic −→ Q , N, B , P ; P2 Q, N, B, ; P Basic −→ Q, N, B, P Q, N, B, ↑NB m Basic −→ Q + N:NB:m, N, B, Q = NA:N:m + Q Q, N, B, Γ Agent −→ Q , N, B, Γ ∪ {↓NA m} P = SI(Γ) Q, N, B, P Basic −→ Q , N, B , P Q, N, B, Γ Agent −→ Q , N, B , (Γ \\ {P}) ∪ {P } P = SI(Γ) P = Q, N, B, Γ Agent −→ Q, N, B, (Γ \\ {P}) N, B, Γ = SA(As) Q, N, B, Γ Agent −→ Q , N, B , Γ Q, As MAS −→ Q , (As ∪ { N, B , Γ }) \\ { N, B, Γ } Figure 2: Operational Semantics for SAAPL containing a belief to be added; and then send one of the agents a start message which begins the interaction.",
                "Both agents thus have the following two plans: ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Figure 3 gives the SAAPL programs for both merchant and customer that implement the NetBill protocol.",
                "For conciseness the error reporting plans are omitted.",
                "We now turn to refining the context conditions.",
                "There are three refinements that we consider.",
                "Firstly, we need to prevent performing actions that have no effect on the interaction state.",
                "Secondly, an agent may want to specify that certain actions that it is able to perform should not be performed unless additional conditions hold.",
                "For example, the customer may not want to agree to the merchants offer unless the goods have a certain price or property.",
                "Thirdly, the context conditions of the plans that terminate the interaction need to be refined in order to avoid terminating the interaction prematurely.",
                "For each plan of the form ı : P ← +E; ↑m we replace the context condition P with the enhanced condition P ∧ P ∧ ¬E where P is any additional conditions that the agent wishes to impose, and ¬E is the negation of the effects of the action.",
                "For example, the customers payment plan becomes (assuming no additional conditions, i.e. no P ): ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "For each plan of the form ↓m : P ← +E; ı we could add ¬E to the precondition, but this is redundant, since it is already checked by the performer of the action, and if the action has no effect then Customers plans: ı : true ← +request; ↑sendRequest. ı : true ← +accept; ↑sendAccept. ı : goods ← +pay; ↑sendEPO. ↓sendQuote : true ← +promiseGoods; +promiseReceipt; ı. ↓sendGoods : true ← +promiseReceipt; +goods; ı. ↓sendReceipt : pay ← +receipt; ı.",
                "Merchants plans: ı : true ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : true ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ← +receipt; ↑sendReceipt. ↓sendRequest : true ← +request; ı. ↓sendAccept : true ← +accept; ı. ↓sendEPO : goods ← +pay; ı.",
                "Shared plans (i.e. plans of both agents): ı : ¬∃p.C(p) ← ↑done. ↓done : ¬∃p.C(p) ← . ↓init(B) : true ← +B. ↓start : true ← ı.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 3: SAAPL Implementation of NetBill the sender wont perform it and send the message (see also the discussion in section 4).",
                "When specifying additional conditions (P ), some care needs to be taken to avoid situations where progress cannot be made because the only action(s) possible are prevented by additional conditions.",
                "One way of indicating preference between actions (in many agent platforms) is to reorder the agents plans.",
                "This is clearly safe, since actions are not prevented, just considered in a different order.",
                "The third refinement of context conditions concerns the plans that terminate the interaction.",
                "In the Commitment Machine framework any state that has no base-level commitment is final, in that the interaction may end there (or it may continue).",
                "However, only some of these final states are desirable final states.",
                "Which final states are considered to be desirable depends on the domain and the desired interaction outcome.",
                "In the NetBill example, the desirable final state is one where the goods have been sent and paid for, and a receipt issued (i.e. goods ∧ pay ∧ receipt).",
                "In order to prevent an agent from terminating the interaction too early we add this as a precondition to the termination plan: ı : goods ∧ pay ∧ receipt ∧ ¬∃p.C(p) ← ↑done.",
                "Figure 4 shows the plans that are changed from figure 3.",
                "In order to support the realisation of CMs, we need to change SAAPL in a number of ways.",
                "These changes, which are discussed below, can be applied to existing <br>bdi</br> languages to make them commitment machine supportive.",
                "We present the three changes, explain what they involve, and for each change explain how the change was implemented using the 3APL agent oriented programming language.",
                "The three changes are: 1. extending the beliefs of the agent so that they can contain commitments; 876 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Customers plans: ı : ¬request ← +request; ↑sendRequest. ı : ¬accept ← +accept; ↑sendAccept. ı : goods ∧ ¬pay ← +pay; ↑sendEPO.",
                "Merchants plans: ı : ¬offer ← +promiseGoods; +promiseReceipt; ↑sendQuote. ı : ¬(promiseReceipt ∧ goods) ← +promiseReceipt; +goods; ↑sendGoods. ı : pay ∧ ¬receipt ← +receipt; ↑sendReceipt.",
                "Where accept ≡ CC(goods pay) promiseGoods ≡ CC(accept goods) promiseReceipt ≡ CC(pay receipt) offer ≡ promiseGoods ∧ promiseReceipt Figure 4: SAAPL Implementation of NetBill with refined context conditions (changed plans only) 2. changing the definition of |= to encompass implied commitments; and 3. whenever a belief is added, updating existing commitments, according to the rules of commitment dynamics.",
                "Extending the notion of beliefs to encompass commitments in fact requires no change in agent platforms that are prolog-like and support terms as beliefs (e.g.",
                "Jason, 3APL, CAN).",
                "However, other agent platforms do require an extension.",
                "For example, JACK, which is an extension of Java, would require changes to support commitments that can be nested.",
                "In the case of 3APL no change is needed to support this.",
                "Whenever a context condition contains commitments, determining whether the context condition is implied by the agents beliefs (B |= C) needs to take into account the notion of implied commitments [15].",
                "In brief, a commitment can be considered to follow from a belief set B if the commitment is in the belief set (C ∈ B), but also under other conditions.",
                "For example, a commitment to pay C(pay) can be considered to be implied by a belief set containing pay because the commitment may have held and been discharged when pay was made true.",
                "Similar rules apply for conditional commitments.",
                "These rules, which were introduced in [15] were subsequently re-formalised in a simpler form by [14] resulting in the four inference rules in the bottom part of figure 5.",
                "The change that needs to be made to SAAPL to support commitment machine implementations is to extend the definition of |= to include these four rules.",
                "For 3APL this was realised by having each agent include the following Prolog clauses: holds(X) :- clause(X,true). holds(c(P)) :- holds(P). holds(c(P)) :- clause(cc(Q,P),true), holds(Q). holds(cc(_,Q)) :- holds(Q). holds(cc(_,Q)) :- holds(c(Q)).",
                "The first clause simply says that anything holds if it is in agents beliefs (clause(X,true) is true if X is a fact).",
                "The remaining four clauses correspond respectively to the inference rules C1, C2, CC1 and CC2.",
                "To use these rules we then modify context conditions in our program so that instead of writing, for example, cc(m,c, pay, receipt) we write holds(cc(m,c, pay, receipt)).",
                "B = norm(B ∪ {b}) Q, N, B, +b −→ Q, N, B , function norm(B) B ← B for each b ∈ B do if b = C(p) ∧ B |= p then B ← B \\ {b} elseif b = CC(p q) then if B |= q then B ← B \\ {b} elseif B |= p then B ← (B \\ {b}) ∪ {C(q)} elseif B |= C(q) then B ← B \\ {b} endif endif endfor return B end function B |= P B |= C(P) C1 CC(Q P) ∈ B B |= Q B |= P C2 B |= CC(P Q) B |= Q CC1 B |= C(Q) B |= CC(P Q) CC2 Figure 5: New Operational Semantics The final change is to update commitments when a belief is added.",
                "Formally, this is done by modifying the semantic rule for belief addition so that it applies an algorithm to update commitments.",
                "The modified rule and algorithm (which mirrors the definition of norm in [14]) can be found in the top part of figure 5.",
                "For 3APL this final change was achieved by manually inserting update() after updating beliefs, and defining the following rules for update(): update() <- c(P) AND holds(P) | {Deletec(P) ; update()}, update() <- cc(P,Q) AND holds(Q) | {Deletecc(P,Q) ; update()}, update() <- cc(P,Q) AND holds(P) | {Deletecc(P,Q) ; Addc(Q) ; update()}, update() <- cc(P,Q) AND holds(c(Q)) | {Deletecc(P,Q) ; update()}, update() <- true | Skip where Deletec and Deletecc delete respectively a base-level and conditional commitment, and Addc adds a base-level commitment.",
                "One aspect that doesnt require a change is linking commitments and actions.",
                "This is because commitments dont trigger actions directly: they may trigger actions indirectly, but in general their effect is to prevent completion of an interaction while there are outstanding (base level) commitments.",
                "Figure 6 shows the message sequences from a number of runs of a 3APL implementation of the NetBill commitment machine6 .",
                "In order to illustrate the different possible interactions the code was modified so that each agent selected randomly from the actions that it could perform, and a number of runs were made with the customer as the initiator, and then with the merchant as the initiator.",
                "There are other possible sequences of messages, not shown, 6 Source code is available from http://www.winikoff.net/CM The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 877 Figure 6: Sample runs from 3APL implementation (alternating turns) including the obvious one: request, quote, accept, goods, payment, receipt, and then done.",
                "One minor difference between the 3APL implementation and SAAPL concerns the semantics of messages.",
                "In the semantics of SAAPL (and of most AOPLs), receiving a message is treated as an event.",
                "However, in 3APL, receiving a message is modelled as the addition to the agents beliefs of a fact indicating that the message was received [6].",
                "Thus in the 3APL implementation we have PG rules that are triggered by these beliefs, rather than by any event.",
                "One issue with this approach is that the belief remains there, so we need to ensure that the belief in question is either deleted once handled, or that we modify preconditions of plans to avoid handling it more than once.",
                "In our implementation we delete these received beliefs when they are handled, to avoid duplicate handling of messages. 4.",
                "BEYOND TWO PARTICIPANTS Generalising to more than two interaction participants requires revisiting how turn management is done, since it is no longer possible to assume alternating turns [7].",
                "In fact, perhaps surprisingly, even in the two participant setting, an alternating turn setup is an unreasonable assumption!",
                "For example, consider the path (in figure 1) from state 1 to 15 (sendGoods) then to state 12 (sendAccept).",
                "The result, in an alternating turn setup, is a dead-end: there is only a single possible action in state 12, namely sendEPO, but this action is done by the customer, and it is the merchants turn to act!",
                "Figure 7 shows the FSM for NetBill with alternating initiative.",
                "A solution to this problem that works in this example, but doesnt generalise7 , is to weaken the alternating turn taking regime by allowing an agent to act twice in a row if its second action is driven by a commitment.",
                "A general solution is to track whose turn it is to act.",
                "This can be done by working out which agents have actions that are able to be performed in the current state.",
                "If there is only a single active agent, then it is clearly that agents turn to act.",
                "However, if more than one agent is active then somehow the agents need to work out who should act next.",
                "Working this out by negotiation is not a particularly good solution for two reasons.",
                "Firstly, this negotiation has to be done at every step of the interaction where more than one agent is active (in the NetBill, this applies to seven out of sixteen states), so it is highly desirable to have a light-weight mechanism for doing this.",
                "Secondly, it is not clear how the negotiation can avoid an infinite regress situation (you go first, no, you go first, . ..) without imposing some arbitrary rule.",
                "It is also possible to resolve who should act by imposing an arbitrary rule, for example, that the customer always acts in preference to the merchant, or that each agent has a numerical priority (perhaps determined by the order in which they joined the interaction?) that determines who acts.",
                "An alternative solution, which exploits the symmetrical properties of commitment machines, is to not try and manage turn taking. 7 Consider actions A1(C) ⇒ p, A2(C) ⇒ q, and A3(M) : p ∧ q ⇒ r. Figure 7: NetBill with alternating initiative Instead of tracking and controlling whose turn it is, we simply allow the agents to act freely, and rely on the properties of the interaction space to ensure that things work out, a notion that we shall make precise, and prove, in the remainder of this section.",
                "The issue with having multiple agents be active simultaneously is that instead of all agents agreeing on the current interaction state, agents can be in different states.",
                "This can be visualised as each agent having its own copy of the FSM that it navigates through where it is possible for agents to follow different paths through the FSM.",
                "The two specific issues that need to be addressed are: 1.",
                "Can agents end up in different final states? 2.",
                "Can an agent be in a position where an error occurs because it cannot perform an action corresponding to a received message?",
                "We will show that, because actions commute under certain assumptions, agents cannot end up in different final states, and furthermore, that errors cannot occur (again, under certain assumptions).",
                "By actions commute we mean that the state resulting from performing a sequence of actions A1 . . .",
                "An is the same, regardless of the order in which the actions are performed.",
                "This means that even if agents take different paths through the FSM, they still end up in the same resulting state, because once all messages have been processed, all agents will have performed the same set of actions.",
                "This addresses the issue of ending up in different final states.",
                "We return to the possibility of errors occurring shortly.",
                "Definition 1 (Monotonicity) An action is monotonic if it does not delete8 any fluents or commitments.",
                "A Commitment Machine is 8 That is directly deletes, it is fine to discharge commitments by adding fluents/commitments. 878 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) monotonic if all of its actions are monotonic. (Adapted from [14, Definition 6]) Theorem 1 If A1 and A2 are monotonic actions, then performing A1 followed by A2 has the same effect on the agents beliefs as performing A2 followed by A1. (Adapted from [14, Theorem 2]).",
                "This assumes that both actions can be performed.",
                "However, it is possible for the performance of A1 to disable A2 from being done.",
                "For example, if A1 has the effect +p, and A2 has precondition ¬p, then although both actions may be enabled in the initial state, they cannot be performed in either order.",
                "We can prevent this by ensuring that actions preconditions do not contain negation (or implication), since a monotonic action cannot result in a precondition that is negation-free becoming false.",
                "Note that this restriction only applies to the original action precondition, P, not to any additional preconditions imposed by the agent (P ).",
                "This is because only P is used to determine whether another agent is able to perform the action.",
                "Thus monotonic CMs with preconditions that do not contain negations have actions that commute.",
                "However, in fact, the restriction to monotonic CMs is unnecessarily strong: all that is needed is that whenever there is a choice of agent that can act, then the possible actions are monotonic.",
                "If there is only a single agent that can act, then no restriction is needed on the actions: they may or may not be monotonic.",
                "Definition 2 (Locally Monotonic) A commitment machine is locally monotonic if for any state S either (a) only a single agent has actions that can be performed; or (b) all actions that can be performed in S are monotonic.",
                "Theorem 2 In a locally monotonic CM, once all messages have been processed, all agents will be in the same state.",
                "Furthermore, no errors can occur.",
                "Proof: Once all messages have been processed we have that all agents will have performed the same action set, perhaps in a different order.",
                "The essence of the proof is to argue that as long as agents havent yet converged to the same state, all actions must be monotonic, and hence that these actions commute, and cannot disable any other actions.",
                "Consider the first point of divergence, where an agent performs action A and at the same time another agent (call it XB) performs action B.",
                "Clearly, this state has actions of more than one agent enabled, so, since the CM is locally monotonic, the relevant actions must be monotonic.",
                "Therefore, after doing A, the action B must still be enabled, and so the message to do B can be processed by updating the recipient agents beliefs with the effects of B.",
                "Furthermore, because monotonic actions commute, the result of doing A before B is the same as doing B before A: S A −−−−−→ SA ? ? yB B ? ? y SB −−−−−→ A SAB However, what happens if the next action after A is not B, but C?",
                "Because B is enabled, and C is not done by agent XB (see below), we must have that C is also monotonic, and hence (a) the result of doing A and B and C is the same regardless of the order in which the three actions are done; and (b) C doesnt disable B, so B can still be done after C. S A −−−−−→ SA C −−−−−→ SAC ? ? yB B ? ? y B ? ? y SB −−−−−→ A SAB −−−−−→ C SABC The reason why C cannot be done by XB is that messages are processed in the order of their arrival9 .",
                "From the perspective of XB the action B was done before C, and therefore from any other agents perspective the message saying that B was done must be received (and processed) before a message saying that C is done.",
                "This argument can be extended to show that once agents start taking different paths through the FSM all actions taken until the point where they converge on a single state must be monotonic, and hence it is always possible to converge (because actions arent disabled), so the interaction is error free; and the resulting state once convergence occurs is the same (because monotonic actions commute).",
                "This theorem gives a strong theoretical guarantee that not doing turn management will not lead to disaster.",
                "This is analogous to proving that disabling all traffic lights would not lead to any accidents, and is only possible because the refined CM axioms are symmetrical.",
                "Based on this theorem the generic transformation from CM to code should allow agents to act freely, which is achieved by simply changing ı : P ∧ P ∧ ¬E ← +E; ↑A to ı : P ∧ P ∧ ¬E ← +E; ↑A; ı For example, instead of ı : ¬request ← +request; ↑sendRequest we have ı : ¬request ← +request; ↑sendRequest; ı.",
                "One consequence of the theorem is that it is not necessary to ensure that agents process messages before continuing to interact.",
                "However, in order to avoid unnecessary parallelism, which can make debugging harder, it may still be desirable to process messages before performing actions.",
                "Figure 8 shows a number of runs from the 3APL implementation that has been modified to allow free, non-alternating, interaction. 5.",
                "DISCUSSION We have presented a scheme for mapping commitment machines to <br>bdi</br> platforms (using SAAPL as an exemplar), identified three changes that needed to be made to SAAPL to support CM-based interaction, and shown that turn management can be avoided in CMbased interaction, provided the CM is locally monotonic.",
                "The three changes to SAAPL, and the translation scheme from commitment machine to <br>bdi</br> plans are both applicable to any <br>bdi</br> language.",
                "As we have mentioned in section 1, there has been some work on designing flexible and robust agent interaction, but virtually no work on implementing flexible and robust interactions.",
                "We have already discussed STAPLE [9, 10].",
                "Another piece of work that is relevant is the work by Cheong and Winikoff on their Hermes methodology [2].",
                "Although the main focus of their work is a pragmatic design methodology, they also provide guidelines for implementing Hermes designs using <br>bdi</br> platforms (specifically Jadex) [3].",
                "However, since Hermes does not yield a design that is formal, it is only possible to generate skeleton code that then needs to be completed.",
                "Also, they do not address the turn taking issue: how to decide which agent acts when more than one agent is able to act. 9 We also assume that the communication medium does not deliver messages out of order, which is the case for (e.g.)",
                "TCP.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 879 Figure 8: Sample runs from 3APL implementation (non-alternating turns) The work of Kremer and Flores (e.g. [8]) also uses commitments, and deals with implementation.",
                "However, they provide infrastructure support (CASA) rather than a programming language, and do not appear to provide assistance to a programmer seeking to implement agents.",
                "Although we have implemented the NetBill interaction using 3APL, the changes to the semantics were done by modifying our NetBill 3APL program, rather than by modifying the 3APL implementation itself.",
                "Clearly, it would be desirable to modify the semantics of 3APL (or of another language) directly, by changing the implementation.",
                "Also, although we have not done so, it should be clear that the translation from a CM to its implementation could easily be automated.",
                "Another area for further work is to look at how the assumptions required to ensure that actions commute can be relaxed.",
                "Finally, there is a need to perform empirical evaluation.",
                "There has already been some work on comparing Hermes with a conventional message-centric approach to designing interaction, and this has shown that using Hermes results in designs that are significantly more flexible and robust [4].",
                "It would be interesting to compare commitment machines with Hermes, but, since commitment machines are a framework, not a design methodology, we need to compare Hermes with a methodology for designing interactions that results in commitment machines [13, 17]. 6.",
                "REFERENCES [1] R. H. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors.",
                "Multi-Agent Programming: Languages, Platforms and Applications.",
                "Springer, 2005. [2] C. Cheong and M. Winikoff.",
                "Hermes: Designing goal-oriented agent interactions.",
                "In Proceedings of the 6th International Workshop on Agent-Oriented Software Engineering (AOSE-2005), July 2005. [3] C. Cheong and M. Winikoff.",
                "Hermes: Implementing goal-oriented agent interactions.",
                "In Proceedings of the Third international Workshop on Programming Multi-Agent Systems (ProMAS), July 2005. [4] C. Cheong and M. Winikoff.",
                "Hermes versus prometheus: A comparative evaluation of two agent interaction design approaches.",
                "Submitted for publication, 2007. [5] P. R. Cohen and H. J. Levesque.",
                "Teamwork.",
                "Nous, 25(4):487-512, 1991. [6] M. Dastani, J. van der Ham, and F. Dignum.",
                "Communication for goal directed agents.",
                "In Proceedings of the Agent Communication Languages and Conversation Policies Workshop, 2002. [7] F. P. Dignum and G. A. Vreeswijk.",
                "Towards a testbed for multi-party dialogues.",
                "In Advances in Agent Communication, pages 212-230.",
                "Springer, LNCS 2922, 2004. [8] R. Kremer and R. Flores.",
                "Using a performative subsumption lattice to support commitment-based conversations.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 114-121.",
                "ACM Press, 2005. [9] S. Kumar and P. R. Cohen.",
                "STAPLE: An agent programming language based on the joint intention theory.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents & Multi-Agent Systems (AAMAS 2004), pages 1390-1391.",
                "ACM Press, July 2004. [10] S. Kumar, M. J. Huber, and P. R. Cohen.",
                "Representing and executing protocols as joint actions.",
                "In Proceedings of the First International Joint Conference on Autonomous Agents and Multi-Agent Systems, pages 543 - 550, Bologna, Italy, 15 - 19 July 2002.",
                "ACM Press. [11] M. Tambe and W. Zhang.",
                "Towards flexible teamwork in persistent teams: Extended report.",
                "Journal of Autonomous Agents and Multi-agent Systems, 2000.",
                "Special issue on Best of ICMAS 98. [12] M. Winikoff.",
                "An AgentSpeak meta-interpreter and its applications.",
                "In Third International Workshop on Programming Multi-Agent Systems (ProMAS), pages 123-138.",
                "Springer, LNCS 3862 (post-proceedings, 2006), 2005. [13] M. Winikoff.",
                "Designing commitment-based agent interactions.",
                "In Proceedings of the 2006 IEEE/WIC/ACM International Conference on Intelligent Agent Technology (IAT-06), 2006. [14] M. Winikoff.",
                "Implementing flexible and robust agent interactions using distributed commitment machines.",
                "Multiagent and Grid Systems, 2(4), 2006. [15] M. Winikoff, W. Liu, and J. Harland.",
                "Enhancing commitment machines.",
                "In J. Leite, A. Omicini, P. Torroni, and P. Yolum, editors, Declarative Agent Languages and Technologies II, number 3476 in Lecture Notes in Artificial Intelligence (LNAI), pages 198-220.",
                "Springer, 2004. [16] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative & procedural goals in intelligent agent systems.",
                "In Proceedings of the Eighth International Conference on Principles of Knowledge Representation and Reasoning (KR2002), Toulouse, France, 2002. [17] P. Yolum.",
                "Towards design tools for protocol development.",
                "In F. Dignum, V. Dignum, S. Koenig, S. Kraus, M. P. Singh, and M. Wooldridge, editors, Autonomous Agents and Multi-Agent Systems (AAMAS), pages 99-105.",
                "ACM Press, 2005. [18] P. Yolum and M. P. Singh.",
                "Flexible protocol specification and execution: Applying event calculus planning using commitments.",
                "In Proceedings of the 1st Joint Conference on Autonomous Agents and MultiAgent Systems (AAMAS), pages 527-534, 2002. [19] P. Yolum and M. P. Singh.",
                "Reasoning about commitments in the event calculus: An approach for specifying and executing protocols.",
                "Annals of Mathematics and Artificial Intelligence (AMAI), 2004. 880 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "The contributions of this paper are: a mapping from a commitment machine to a collection of <br>bdi</br>-style plans; extensions to the semantics of <br>bdi</br> programming languages; and an examination of two issues that arise when distributing commitment machines (turn management and race conditions) and solutions to these problems.",
                "This paper presents a scheme for extending <br>bdi</br>-like AOPLs to support direct implementation of agent interactions that are designed using Yolum & Singhs commitment machine (CM) framework [19].",
                "In the remainder of this paper we briefly review commitment machines and present a simple abstraction of <br>bdi</br> AOPLs which lies in the common subset of languages such as Jason, 3APL, and CAN.",
                "As seen in figure 1, commitment machines can support a range of interaction sequences. 2.2 An Abstract Agent ProgrammingLanguage Agent programming languages in the <br>bdi</br> tradition (e.g. dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define agent behaviour in terms of event-triggered plans, where each plan specifies what it is triggered by, under what situations it can be considered to be applicable (defined using a so-called context condition), and a plan body: a sequence of steps that can include posting events which in turn triggers further plans.",
                "We now briefly define the formal syntax and semantics of a Simple Abstract (<br>bdi</br>) Agent Programming Language (SAAPL)."
            ],
            "translated_annotated_samples": [
                "Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de <br>estilo BDI</br>; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas.",
                "Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la <br>máquina de compromisos</br> (CM) de Yolum & Singh [19].",
                "En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los <br>AOPLs BDI</br> que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN.",
                "Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la <br>tradición BDI</br> (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes.",
                "Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (<br>BDI</br>) (SAAPL)."
            ],
            "translated_text": "Implementando Interacciones Basadas en Compromisos∗ Michael Winikoff Escuela de Ciencias de la Computación e Informática Universidad RMIT Melbourne, Australia michael.winikoff@rmit.edu.au RESUMEN Aunque la interacción entre agentes juega un papel vital en los Sistemas Multiagente, y los enfoques centrados en mensajes para la interacción entre agentes tienen sus inconvenientes, los lenguajes de programación orientados a agentes actuales no proporcionan soporte para implementar una interacción entre agentes que sea flexible y robusta. En cambio, los mensajes se proporcionan como un bloque de construcción primitivo. En este artículo consideramos un enfoque para modelar las interacciones entre agentes: el marco de las máquinas de compromiso. Este marco de trabajo soporta la modelización de interacciones a un nivel más alto (utilizando compromisos sociales), lo que resulta en interacciones más flexibles. Investigamos cómo las interacciones basadas en compromisos pueden ser implementadas en lenguajes de programación orientados a agentes convencionales. Las contribuciones de este artículo son: un mapeo de una máquina de compromiso a una colección de planes de <br>estilo BDI</br>; extensiones a la semántica de los lenguajes de programación BDI; y un examen de dos problemas que surgen al distribuir máquinas de compromiso (gestión de turnos y condiciones de carrera) y soluciones a estos problemas. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; I.2.5 [Inteligencia Artificial]: Lenguajes de Programación y Software Términos Generales de Diseño 1. Los agentes son sociales, y la interacción entre agentes juega un papel vital en los sistemas multiagente. Por consiguiente, el diseño e implementación de la interacción de agentes es un tema de investigación importante. El enfoque estándar para diseñar interacciones de agentes es centrado en mensajes: las interacciones se definen mediante protocolos de interacción que establecen las secuencias permitidas de mensajes, especificadas utilizando notaciones como máquinas de estados finitos, redes de Petri o Agent UML. Se ha argumentado que este enfoque centrado en el mensaje para el diseño de interacción no es adecuado para agentes inteligentes. Los agentes inteligentes deben mostrar la capacidad de persistir en la consecución de sus objetivos ante el fracaso (robustez) al intentar diferentes enfoques (flexibilidad). Por otro lado, al seguir un protocolo de interacción, un agente tiene una flexibilidad y robustez limitadas: la capacidad de intentar persistentemente medios alternativos para lograr el objetivo de la interacción está limitada a las opciones que el diseñador del protocolo proporcionó, y en la práctica, los procesos de diseño centrados en mensajes no suelen conducir a protocolos que sean flexibles o robustos. Reconociendo estas limitaciones del enfoque tradicional para diseñar interacciones entre agentes, en los últimos años se han propuesto varios enfoques que se alejan de los protocolos de interacción centrados en mensajes, y en su lugar consideran el diseño de interacciones entre agentes utilizando conceptos de nivel superior como compromisos sociales [8, 10, 18] o metas de interacción [2]. También se ha trabajado en formas más ricas de interacción en entornos específicos, como equipos de agentes cooperativos [5, 11]. Sin embargo, aunque ha habido trabajo en el diseño de interacciones de agentes flexibles y robustas, prácticamente no ha habido trabajo en proporcionar soporte de lenguaje de programación para implementar tales interacciones. Los lenguajes de programación orientados a agentes actuales (AOPLs) no proporcionan soporte para implementar interacciones de agentes flexibles y robustas utilizando conceptos de nivel superior que los mensajes. De hecho, los modernos AOPLs [1], prácticamente sin excepciones, solo proporcionan el envío de mensajes simples como base para implementar la interacción entre agentes. Este documento presenta lo que, según nuestro conocimiento, es el segundo AOPL que respalda la implementación de interacción de agentes de alto nivel, flexible y robusta. El primer lenguaje de este tipo, STAPLE, fue propuesto hace unos años [9], pero no está descrito en detalle y es discutiblemente impráctico para su uso por no especialistas, debido a su base lógica y su fuerte dependencia de la lógica temporal y modal. Este documento presenta un esquema para extender los AOPLs tipo BDI para soportar la implementación directa de interacciones entre agentes que están diseñadas utilizando el marco de trabajo de la <br>máquina de compromisos</br> (CM) de Yolum & Singh [19]. En el resto de este documento revisamos brevemente las máquinas de compromiso y presentamos una abstracción simple de los <br>AOPLs BDI</br> que se encuentra en el subconjunto común de lenguajes como Jason, 3APL y CAN. Luego presentamos un esquema para traducir máquinas de compromiso a este lenguaje, e indicamos cómo el lenguaje debe ser ampliado para soportar esto. Luego extendemos nuestro esquema para abordar una serie de problemas relacionados con la distribución, incluido el seguimiento de turnos [7] y las condiciones de carrera. 2. ANTECEDENTES 2.1 Máquinas de Compromiso El objetivo del marco de las máquinas de compromiso es permitir la definición de interacciones que sean más flexibles que los enfoques tradicionales centrados en mensajes. Una Máquina de Compromiso (CM) [19] especifica una interacción entre entidades (por ejemplo, agentes, servicios, procesos) en términos de acciones que cambian el estado de la interacción. Este estado interactivo consiste en fluents (predicados que cambian de valor con el tiempo), pero también en compromisos sociales, tanto a nivel base como condicionales. Un compromiso social de nivel base es un compromiso del deudor A con el acreedor B para lograr la condición p, denotado como C(A, B, p). Esto a veces se abrevia como C(p), cuando no es importante especificar las identidades de las entidades en cuestión. Por ejemplo, un compromiso del cliente C con el comerciante M para hacer que el pago sea verdadero se escribiría como C(C, M, pagado). Un compromiso social condicional es un compromiso del deudor A con el acreedor B que, en caso de que la condición q se cumpla, A se comprometerá a cumplir la condición p. Esto se denota como CC(A, B, q, p) y, cuando la identidad de las entidades involucradas no es importante (o es obvia), se abrevia como CC(q, p) donde la flecha es un recordatorio del vínculo causal entre q haciéndose realidad y la creación de un compromiso para hacer que p sea verdadero. Por ejemplo, un compromiso de hacer efectivo el pago una vez que se hayan recibido los bienes se escribiría CC(pago de bienes). La semántica de los compromisos (tanto a nivel base como condicional) se define con reglas que especifican cómo cambian los compromisos con el tiempo. Por ejemplo, el compromiso C(p) (o CC(q p)) se cumple cuando p se vuelve verdadero; y el compromiso CC(q p) es reemplazado por C(p) cuando q se vuelve verdadero. En este artículo utilizamos la semántica más simétrica propuesta por [15] y posteriormente reformulada por [14]. En resumen, esta semántica trata con una serie de casos más complejos, como cuando se crean compromisos cuando las condiciones ya se cumplen: si p se cumple cuando se supone que se debe crear CC(p q), entonces en lugar de crear CC(p q) se crea C(q). Una interacción se define especificando las entidades involucradas, los posibles contenidos del estado de interacción (tanto fluents como compromisos), y (lo más importante) las acciones que cada entidad puede realizar junto con las condiciones previas y efectos de cada acción, especificados como listas de adición y eliminación. Una máquina de compromiso (CM) define un rango de posibles interacciones que comienzan en un estado1, y realizan acciones hasta alcanzar un estado final. Un estado final es aquel que no tiene compromisos a nivel base. Una forma de visualizar las interacciones que son posibles con una máquina de compromiso dada es generar la máquina de estados finitos correspondiente a la CM. Por ejemplo, la figura 1 muestra el FSM2 correspondiente a la máquina de compromiso NetBill [18]: un CM simple donde un cliente (C) y un comerciante (M) intentan comerciar utilizando las siguientes acciones: 1 A diferencia de los protocolos de interacción estándar, o máquinas de estados finitos, no hay un estado inicial designado para la interacción. 2 La máquina de estados finitos es generada por software: los nodos y conexiones fueron calculados por una implementación de los axiomas (disponible en http://www.winikoff.net/CM) y luego se dispusieron con graphviz (http://www.graphviz.org). 3 Utilizamos la notación A(X) : P ⇒ E para indicar que la acción A es realizada por la entidad X, tiene una condición previa P (con : P omitido si está vacío) y un efecto E. • sendRequest(C) ⇒ solicitud • sendQuote(M) ⇒ oferta donde oferta ≡ promesaMercancías ∧ promesaRecibo y promesaMercancías ≡ CC(M, C, aceptar, mercancías) y promesaRecibo ≡ CC(M, C, pagar, recibo) • sendAccept(C) ⇒ aceptar donde aceptar ≡ CC(C, M, mercancías, pagar) • sendGoods(M) ⇒ promesaRecibo ∧ mercancías donde promesaRecibo ≡ CC(M, C, pagar, recibo) • sendEPO(C) : mercancías ⇒ pagar • sendReceipt(M) : pagar ⇒ recibo. El compromiso de aceptación es la promesa del cliente de pagar una vez que se hayan enviado los bienes, la promesa de bienes es la promesa del comerciante de enviar los bienes una vez que el cliente acepte, y la promesa de recibo es la promesa del comerciante de enviar un recibo una vez que se haya realizado el pago. Como se ve en la figura 1, las máquinas de compromiso pueden soportar una variedad de secuencias de interacción. 2.2 Un lenguaje de programación de agentes abstracto en la <br>tradición BDI</br> (por ejemplo, dMARS, JAM, PRS, UM-PRS, JACK, AgentSpeak(L), Jason, 3APL, CAN, Jadex) define el comportamiento del agente en términos de planes desencadenados por eventos, donde cada plan especifica por qué se desencadena, en qué situaciones se considera aplicable (definido usando una condición de contexto) y un cuerpo del plan: una secuencia de pasos que pueden incluir la publicación de eventos que a su vez desencadenan más planes. Dado un conjunto de planes y un evento e que ha sido publicado, el agente primero recopila todos los tipos de planes que son activados por ese evento (los planes relevantes), luego evalúa las condiciones de contexto de estos planes para obtener un conjunto de instancias de planes aplicables. Uno de ellos es elegido y es ejecutado. Ahora definimos brevemente la sintaxis formal y la semántica de un Lenguaje de Programación de Agentes Abstractos Simples (<br>BDI</br>) (SAAPL). ",
            "candidates": [],
            "error": [
                [
                    "estilo BDI",
                    "máquina de compromisos",
                    "AOPLs BDI",
                    "tradición BDI",
                    "BDI"
                ]
            ]
        }
    }
}