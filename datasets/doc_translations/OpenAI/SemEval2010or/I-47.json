{
    "id": "I-47",
    "original_text": "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms. Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions. The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core. In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions. Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions. The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1. INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15]. Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components. This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS. This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc.), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages. Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions. The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core. This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions. Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26]. To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17]. The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure. Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions. Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose. The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced. Next, the dynamics of social interactions will show how these entities and relationships evolve. Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2. SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1]. The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector. The attachment operation binds a component to the role of a given connector. The analysis of social interactions introduced in this section gives rise to a new kind of social connector. It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents. Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature. Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction. Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23]. Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources. In the following, we describe the basic entities involved in social interactions. Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state. Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed. The value v in the expression [v| ] : Queue[T] represents the head of the queue. The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective. Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces. This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn. Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . .. The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise. The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions. Lets consider an interaction representing a university course (e.g. on data structures). On the one hand, this interaction is actually a complex one, made up of lower-level interactions. For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on. Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions. A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ). On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction. Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society. The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 . The organizational and communicative interaction types identified above clearly differ in many ways. However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space. Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P). The event channel, to be described in the next section, allows the dispatching of local events to external interactions. The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil. The type SI Enum {open, closing, closed} represents the possible execution states of the interaction. Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent. The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2). The life-cycle of the interaction begins in the open state. Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment. Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants. The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something. The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 . The types of agents participating in a given interaction are primarily identified from their purposes. For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject. Other members of the course include lecturers and teaching assistants. The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise. The context of some agent is defined as the interaction in which it participates (def. 3). The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent. Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil). The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 . An agent may play roles at interactions within or outside the scope of its context. For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty). Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction. Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction. Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction. The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet. An agent may update its event queue by seeing the state of some entity of the community. The last field of the structure represents the obligations (O) of agents, to be described later. Eventually, the participation of some agent in the interaction will be over. This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction. In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise. The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities. For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction. Students may also create programs to satisfy the requirements of some assignment. Other types of computational resources put at the disposal of students by teachers include compilers and interpreters. The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting. This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol. The mandatory feature creator represents the agent who created this resource. Moreover, resources may have owners. The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment. Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties. For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students. The last operations feature represents the interface of the resource, consisting of a set of operations. A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol. The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics. The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols. Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions. Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.). Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose. Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction. Empowerments may only be exercised under certain circumstances - that permissions specify. Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field). For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects. Permission rules, in turn, specify that those students may only join the course in the admission stage. Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 . Secondly, protocols shall allow to determine the obligations of agents towards the interaction. Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction. These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked. The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated. Moreover, it returns for each agent a collection of events representing the changes in the obligation set. For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject. Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction. Corresponding rules shall establish the set of agents that must be awared of some event. For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles. Similarly, the admission stage is an additional boolean field of the structure for school interactions. The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course. Last, the protocol shall allow to control the state of the interaction as well as the states of its members. Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over. Thus, the function field finish returns true if the regulated interaction must finish its execution. If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9). Similarly, the function over returns true if the participation of the specified member must be over. Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 . For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted. It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3. SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions. This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action. The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped. The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions. These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members. This section will also describe the way in which these events are processed. The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously. Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action. This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution. Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section. Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing. This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer. As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction. If this condition is not met, the attempt will simply be ignored. Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts). If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage. For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked. If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue. Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section). If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject). If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2). Otherwise, the action is discharged and removed from the queue. Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications. Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed. The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps. Actions of the first kind are constructive ones such as set up and join. The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol. As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated. Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14). The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction). According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action. This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function). The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 . Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17). The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port. This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions. Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction. Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function. Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on. Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 . Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update. The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched. As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community. In this scenario, interactions would trigger themselves without requiring any explicit notification. On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5). Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty). Last, the event is removed from the queue and the auxiliary fields are re-set to nil. The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 . For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees. Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action. Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received. Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished. Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure. If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members. Otherwise, we can consider two possible scenarios. In the first one, the interaction has no members and no sub-interactions. In this case, the interaction can be inmediately closed down. As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel. According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction. In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself). As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port. According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8). Moreover, 12 This is essentially determined by the protocol rules of these interactions. The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage. This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed. Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function. When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function. If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose). The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23). Otherwise, the member enters the transient leaving state, thus preventing any action performance. Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly. When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update. For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member. Moreover, the event representing this change is added to the output channel of the department interaction. 4. DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components. In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions). Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25]. Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions. The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2]. Finally, bottom-level interactions may represent communicative actions. From this perspective, the member types of a CA include the speaker and possibly many listeners. The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA. The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20]. These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions. Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3]. Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6]. These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions. Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms. In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols. Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions. We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms. The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type. This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language). On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services. We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms. In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5. ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions. Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6. REFERENCES [1] R. Allen and D. Garlan. A Formal Basis for Architectural Connection. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodr´ıguez, and C. Sierra. Engineering open environments with electronic institutions. Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre. Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics. In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci. A survey of programming languages and platforms for multi-agent systems. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason and the golden fleece of agent-oriented programming. In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J. A. Padget. Specifying and analysing agent-based social institutions using answer set programming. In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum. Omni: Introducing social structure, norms and ontologies into agent organizations. In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra. ISLANDER: an electronic institutions editor. In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052. ACM Press, July 2002. [9] M. Esteva, B. Rosell, J. A. Rodr´ıguez-Aguilar, and J. L. Arcos. AMELI: An agent-based middleware for electronic institutions. In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel. From agents to organizations: An organizational view of multi-agent systems. In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents. FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J. A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos. Norm-oriented programming of electronic institutions. In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber. The MadKit agent platform architecture. Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE. The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott. Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing. AgentLink III, 2005. [16] P. McBurney and S. Parsons. A formal framework for inter-agent dialogues. In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke. Towards a taxonomy of software connectors. In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187. ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz. Agent oriented software engineering with ingenias. In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems. Springer Verlag, 2003. [19] B. C. Pierce. Types and Programming Languages. The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Voting in multi-agent systems. Feb. 27 2006. [21] G. Plotkin. A structural approach to operational semantics. Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle. Speech Acts. Cambridge University Press, 1969. [23] M. Sergot. A computational theory of normative positions. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Agent-based abstractions for software development. In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18. Kluwer, 2004. [25] S. Willmot and al. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Developing multiagent systems: The Gaia methodology. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)",
    "original_sentences": [
        "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
        "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
        "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
        "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
        "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
        "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
        "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
        "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
        "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
        "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
        "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
        "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
        "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
        "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
        "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
        "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
        "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
        "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
        "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
        "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
        "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
        "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
        "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
        "The attachment operation binds a component to the role of a given connector.",
        "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
        "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
        "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
        "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
        "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
        "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
        "In the following, we describe the basic entities involved in social interactions.",
        "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
        "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
        "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
        "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
        "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
        "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
        "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
        "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
        "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
        "Lets consider an interaction representing a university course (e.g. on data structures).",
        "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
        "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
        "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
        "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
        "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
        "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
        "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
        "The organizational and communicative interaction types identified above clearly differ in many ways.",
        "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
        "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
        "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
        "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
        "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
        "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
        "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
        "The life-cycle of the interaction begins in the open state.",
        "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
        "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
        "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
        "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
        "The types of agents participating in a given interaction are primarily identified from their purposes.",
        "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
        "Other members of the course include lecturers and teaching assistants.",
        "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
        "The context of some agent is defined as the interaction in which it participates (def. 3).",
        "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
        "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
        "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
        "An agent may play roles at interactions within or outside the scope of its context.",
        "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
        "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
        "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
        "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
        "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
        "An agent may update its event queue by seeing the state of some entity of the community.",
        "The last field of the structure represents the obligations (O) of agents, to be described later.",
        "Eventually, the participation of some agent in the interaction will be over.",
        "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
        "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
        "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
        "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
        "Students may also create programs to satisfy the requirements of some assignment.",
        "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
        "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
        "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
        "The mandatory feature creator represents the agent who created this resource.",
        "Moreover, resources may have owners.",
        "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
        "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
        "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
        "The last operations feature represents the interface of the resource, consisting of a set of operations.",
        "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
        "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
        "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
        "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
        "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
        "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
        "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
        "Empowerments may only be exercised under certain circumstances - that permissions specify.",
        "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
        "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
        "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
        "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
        "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
        "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
        "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
        "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
        "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
        "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
        "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
        "Corresponding rules shall establish the set of agents that must be awared of some event.",
        "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
        "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
        "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
        "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
        "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
        "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
        "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
        "Similarly, the function over returns true if the participation of the specified member must be over.",
        "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
        "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
        "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
        "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
        "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
        "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
        "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
        "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
        "This section will also describe the way in which these events are processed.",
        "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
        "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
        "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
        "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
        "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
        "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
        "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
        "If this condition is not met, the attempt will simply be ignored.",
        "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
        "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
        "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
        "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
        "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
        "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
        "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
        "Otherwise, the action is discharged and removed from the queue.",
        "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
        "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
        "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
        "Actions of the first kind are constructive ones such as set up and join.",
        "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
        "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
        "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
        "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
        "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
        "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
        "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
        "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
        "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
        "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
        "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
        "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
        "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
        "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
        "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
        "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
        "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
        "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
        "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
        "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
        "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
        "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
        "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
        "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
        "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
        "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
        "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
        "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
        "Otherwise, we can consider two possible scenarios.",
        "In the first one, the interaction has no members and no sub-interactions.",
        "In this case, the interaction can be inmediately closed down.",
        "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
        "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
        "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
        "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
        "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
        "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
        "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
        "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
        "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
        "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
        "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
        "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
        "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
        "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
        "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
        "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
        "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
        "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
        "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
        "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
        "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
        "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
        "Finally, bottom-level interactions may represent communicative actions.",
        "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
        "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
        "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
        "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
        "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
        "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
        "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
        "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
        "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
        "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
        "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
        "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
        "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
        "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
        "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
        "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
        "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
        "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
        "REFERENCES [1] R. Allen and D. Garlan.",
        "A Formal Basis for Architectural Connection.",
        "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
        "A. Rodr´ıguez, and C. Sierra.",
        "Engineering open environments with electronic institutions.",
        "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
        "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
        "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
        "A survey of programming languages and platforms for multi-agent systems.",
        "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
        "Jason and the golden fleece of agent-oriented programming.",
        "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
        "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
        "A. Padget.",
        "Specifying and analysing agent-based social institutions using answer set programming.",
        "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
        "Omni: Introducing social structure, norms and ontologies into agent organizations.",
        "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
        "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
        "ISLANDER: an electronic institutions editor.",
        "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
        "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
        "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
        "AMELI: An agent-based middleware for electronic institutions.",
        "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
        "From agents to organizations: An organizational view of multi-agent systems.",
        "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
        "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
        "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
        "Norm-oriented programming of electronic institutions.",
        "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
        "The MadKit agent platform architecture.",
        "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
        "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
        "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
        "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
        "A formal framework for inter-agent dialogues.",
        "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
        "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
        "Towards a taxonomy of software connectors.",
        "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
        "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
        "Agent oriented software engineering with ingenias.",
        "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
        "Springer Verlag, 2003. [19] B. C. Pierce.",
        "Types and Programming Languages.",
        "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
        "Voting in multi-agent systems.",
        "Feb. 27 2006. [21] G. Plotkin.",
        "A structural approach to operational semantics.",
        "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
        "Speech Acts.",
        "Cambridge University Press, 1969. [23] M. Sergot.",
        "A computational theory of normative positions.",
        "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
        "Agent-based abstractions for software development.",
        "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
        "Kluwer, 2004. [25] S. Willmot and al.",
        "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
        "Developing multiagent systems: The Gaia methodology.",
        "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "translated_text_sentences": [
        "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software.",
        "Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas.",
        "La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común.",
        "En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente.",
        "Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales.",
        "El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1.",
        "INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15].",
        "Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema.",
        "Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS).",
        "Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo.",
        "Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas.",
        "La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común.",
        "Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas.",
        "Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26].",
        "Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17].",
        "El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial.",
        "Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales).",
        "La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito.",
        "El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales.",
        "A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones.",
        "Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro.",
        "ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1].",
        "Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes.",
        "La operación de adjuntar vincula un componente al rol de un conector dado.",
        "El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social.",
        "Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes.",
        "Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad.",
        "A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción.",
        "Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23].",
        "Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales.",
        "En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales.",
        "Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado.",
        "Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados.",
        "El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola.",
        "El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta.",
        "Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos.",
        "Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn.",
        "Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . ..",
        "El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario.",
        "El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas.",
        "Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos).",
        "Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior.",
        "Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc.",
        "Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas.",
        "Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...).",
        "Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior.",
        "Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes.",
        "La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente.",
        "Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos.",
        "Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción.",
        "En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P).",
        "El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas.",
        "El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo.",
        "El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción.",
        "Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador.",
        "El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2).",
        "El ciclo de vida de la interacción comienza en el estado abierto.",
        "Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local.",
        "Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes.",
        "El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo.",
        "El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto.",
        "Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos.",
        "Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso.",
        "Otros miembros del curso incluyen profesores y asistentes de enseñanza.",
        "El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario.",
        "El contexto de algún agente se define como la interacción en la que participa (def. 3).",
        "El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente.",
        "Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo).",
        "Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5).",
        "Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto.",
        "Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad).",
        "Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción.",
        "Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción.",
        "Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción.",
        "Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados.",
        "Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad.",
        "El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante.",
        "Finalmente, la participación de algún agente en la interacción habrá terminado.",
        "Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción.",
        "En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido.",
        "El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas.",
        "Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso.",
        "Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea.",
        "Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes.",
        "El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social.",
        "Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo.",
        "El creador de la característica obligatoria representa al agente que creó este recurso.",
        "Además, los recursos pueden tener propietarios.",
        "La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno.",
        "Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades.",
        "Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes.",
        "La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones.",
        "Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones.",
        "El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica.",
        "La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos.",
        "En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones.",
        "En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.).",
        "Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito.",
        "Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción.",
        "Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos.",
        "Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido).",
        "Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas.",
        "Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión.",
        "Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente.",
        "En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción.",
        "Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada.",
        "Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada.",
        "La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado.",
        "Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones.",
        "Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso.",
        "En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción.",
        "Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento.",
        "Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles.",
        "De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares.",
        "Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso.",
        "Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros.",
        "Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente.",
        "Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución.",
        "Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9).",
        "De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar.",
        "Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7.",
        "Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo.",
        "También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3.",
        "DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones.",
        "Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna).",
        "La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida.",
        "El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones.",
        "Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros.",
        "Esta sección también describirá la forma en que estos eventos son procesados.",
        "La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente.",
        "Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada.",
        "Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa.",
        "En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección.",
        "Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento.",
        "Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado.",
        "Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo.",
        "Si esta condición no se cumple, el intento simplemente será ignorado.",
        "Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos).",
        "Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos.",
        "Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso.",
        "Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola.",
        "Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección).",
        "Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente).",
        "Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2).",
        "De lo contrario, la acción se descarta y se elimina de la cola.",
        "A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas.",
        "Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar.",
        "Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución.",
        "Las acciones del primer tipo son constructivas, como configurar y unir.",
        "El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción.",
        "Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar.",
        "Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14).",
        "El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso).",
        "Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre.",
        "Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización).",
        "La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después.",
        "En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc.",
        "El Sexto Internacional.",
        "La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17).",
        "La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida.",
        "Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones.",
        "Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales.",
        "Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos.",
        "Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante.",
        "Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento.",
        "En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones.",
        "El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados.",
        "Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples.",
        "En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita.",
        "Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5).",
        "Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos).",
        "Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo.",
        "La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos).",
        "Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares.",
        "En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción.",
        "Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento.",
        "Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse.",
        "Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre.",
        "Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción.",
        "De lo contrario, podemos considerar dos posibles escenarios.",
        "En el primero, la interacción no tiene miembros ni sub-interacciones.",
        "En este caso, la interacción se puede cerrar inmediatamente.",
        "Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida.",
        "Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción.",
        "En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí).",
        "Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida.",
        "Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8).",
        "Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones.",
        "La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl.",
        "En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro.",
        "Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada.",
        "Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función.",
        "Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos.",
        "Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito).",
        "El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23).",
        "De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento.",
        "Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia.",
        "Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción.",
        "Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro.",
        "Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4.",
        "DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados.",
        "En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas).",
        "Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25].",
        "Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel.",
        "Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2].",
        "Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas.",
        "Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes.",
        "El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA.",
        "El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20].",
        "Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes.",
        "De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3].",
        "Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6].",
        "Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales.",
        "Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción.",
        "A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos.",
        "A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción.",
        "Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción.",
        "El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo.",
        "Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes).",
        "Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web.",
        "También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas.",
        "En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5.",
        "AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias.",
        "Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03.",
        "REFERENCIAS [1] R. Allen y D. Garlan.",
        "Una Base Formal para la Conexión Arquitectónica.",
        "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
        "A. Rodríguez y C. Sierra.",
        "Ingeniería de entornos abiertos con instituciones electrónicas.",
        "Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre.",
        "Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales.",
        "En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci.",
        "Una encuesta de lenguajes de programación y plataformas para sistemas multiagente.",
        "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
        "Jason y el vellocino de oro de la programación orientada a agentes.",
        "En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1.",
        "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J.",
        "A. Padget.",
        "Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas.",
        "En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum.",
        "Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes.",
        "En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198.",
        "Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra.",
        "ISLANDER: un editor de instituciones electrónicas.",
        "En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052.",
        "ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J.",
        "A. Rodríguez-Aguilar y J. L. Arcos.",
        "AMELI: Un middleware basado en agentes para instituciones electrónicas.",
        "En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel.",
        "De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente.",
        "En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes.",
        "Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J.",
        "A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos.",
        "Programación orientada a normas de instituciones electrónicas.",
        "En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber.",
        "La arquitectura de la plataforma de agentes MadKit.",
        "Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE.",
        "La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott.",
        "Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes.",
        "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
        "Un marco formal para diálogos entre agentes.",
        "En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001.",
        "ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke.",
        "Hacia una taxonomía de conectores de software.",
        "En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187.",
        "ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz.",
        "Ingeniería de software orientada a agentes con Ingenias.",
        "En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este.",
        "Springer Verlag, 2003. [19] B. C. Pierce.",
        "Tipos y Lenguajes de Programación.",
        "The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
        "Votación en sistemas multiagente.",
        "27 de febrero de 2006.\n[21] G. Plotkin.",
        "Un enfoque estructural para la semántica operacional.",
        "Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle.",
        "Actos de habla.",
        "Cambridge University Press, 1969. [23] M. Sergot.",
        "Una teoría computacional de posiciones normativas.",
        "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
        "Abstracciones basadas en agentes para el desarrollo de software.",
        "En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18.",
        "Kluwer, 2004. [25] S. Willmot y otros.",
        "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
        "Desarrollo de sistemas multiagente: La metodología Gaia.",
        "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)"
    ],
    "error_count": 3,
    "keys": {
        "operational semantics": {
            "translated_key": "Semántica Operacional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>operational semantics</br> of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural <br>operational semantics</br> (SOS)[21], a common technique to specify the <br>operational semantics</br> of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to <br>operational semantics</br>.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "<br>operational semantics</br> of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Structural <br>operational semantics</br> (SOS)[21], a common technique to specify the <br>operational semantics</br> of programming languages, is used for this purpose.",
                "A structural approach to <br>operational semantics</br>."
            ],
            "translated_annotated_samples": [
                "<br>Semántica Operacional</br> de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software.",
                "La Semántica Operacional Estructural (SOS), una técnica común para especificar la <br>semántica operacional</br> de los lenguajes de programación, se utiliza con este propósito.",
                "Un enfoque estructural para la <br>semántica operacional</br>."
            ],
            "translated_text": "<br>Semántica Operacional</br> de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la <br>semántica operacional</br> de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la <br>semántica operacional</br>. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "multiagent interaction": {
            "translated_key": "interacciones multiagentes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of <br>multiagent interaction</br>s, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale <br>multiagent interaction</br>s such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Its first goal is to carry out a principled analysis of <br>multiagent interaction</br>s, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "The last levels of the interaction tree may represent small-scale <br>multiagent interaction</br>s such as those represented by interaction protocols [11], dialogue games [16], or scenes [2]."
            ],
            "translated_annotated_samples": [
                "Su primer objetivo es llevar a cabo un análisis fundamentado de las <br>interacciones multiagentes</br>, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26].",
                "Los últimos niveles del árbol de interacción pueden representar <br>interacciones multiagentes</br> a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las <br>interacciones multiagentes</br>, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar <br>interacciones multiagentes</br> a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "institutional framework": {
            "translated_key": "marcos institucionales",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by <br>institutional framework</br>s and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by <br>institutional framework</br>s [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by <br>institutional framework</br>s and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Particularly, the organizational or social stance advocated by <br>institutional framework</br>s [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components."
            ],
            "translated_annotated_samples": [
                "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por <br>marcos institucionales</br> y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software.",
                "Particularmente, la postura organizativa o social defendida por los <br>marcos institucionales</br> y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por <br>marcos institucionales</br> y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los <br>marcos institucionales</br> y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "pre-defined abstraction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, <br>pre-defined abstraction</br>s.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, <br>pre-defined abstraction</br>s.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, <br>pre-defined abstraction</br>s.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, <br>pre-defined abstraction</br>s."
            ],
            "translated_annotated_samples": [
                "Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de <br>abstracciones particulares y predefinidas</br>.",
                "Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de <br>abstracciones particulares predefinidas</br>."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de <br>abstracciones particulares y predefinidas</br>. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de <br>abstracciones particulares predefinidas</br>. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    "abstracciones particulares y predefinidas",
                    "abstracciones particulares predefinidas"
                ]
            ]
        },
        "organizational and communicative abstraction": {
            "translated_key": "abstracciones organizativas y comunicativas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of <br>organizational and communicative abstraction</br>s which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of <br>organizational and communicative abstraction</br>s, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new <br>organizational and communicative abstraction</br>s obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of <br>organizational and communicative abstraction</br>s which have found currency in several programming frameworks and software platforms.",
                "This approach has resulted in a wide spectrum of <br>organizational and communicative abstraction</br>s, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "These analyses shall result in new <br>organizational and communicative abstraction</br>s obtained through a refinement and/or extension of the general model of social interactions."
            ],
            "translated_annotated_samples": [
                "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de <br>abstracciones organizativas y comunicativas</br> que han encontrado aceptación en varios marcos de programación y plataformas de software.",
                "Este enfoque ha dado lugar a un amplio espectro de <br>abstracciones organizativas y comunicativas</br>, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS).",
                "Estos análisis darán como resultado nuevas <br>abstracciones organizativas y comunicativas</br> obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de <br>abstracciones organizativas y comunicativas</br> que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de <br>abstracciones organizativas y comunicativas</br>, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas <br>abstracciones organizativas y comunicativas</br> obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "software architecture": {
            "translated_key": "arquitecturas de software",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of <br>software architecture</br>s, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of <br>software architecture</br>s [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of <br>software architecture</br>s, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "In the realm of <br>software architecture</br>s, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "To approach this issue, we draw on the notion of connector, put forward within the field of <br>software architecture</br>s [1, 17].",
                "In the realm of <br>software architecture</br>s, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions)."
            ],
            "translated_annotated_samples": [
                "En el ámbito de las <br>arquitecturas de software</br>, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente.",
                "Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las <br>arquitecturas de software</br> [1, 17].",
                "En el ámbito de las <br>arquitecturas de software</br>, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas)."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las <br>arquitecturas de software</br>, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las <br>arquitecturas de software</br> [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las <br>arquitecturas de software</br>, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "connector-based model of multi-agent interaction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a <br>connector-based model of multi-agent interaction</br>s which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a <br>connector-based model of multi-agent interaction</br>s between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "In the realm of software architectures, the paper proposes a <br>connector-based model of multi-agent interaction</br>s which attempts to identify the essential structure underlying multi-agent interactions.",
                "The outcome of this analysis will be a <br>connector-based model of multi-agent interaction</br>s between autonomous social and situated components, i.e. agents, attempting to identify their essential structure."
            ],
            "translated_annotated_samples": [
                "En el ámbito de las arquitecturas de software, el artículo propone un <br>modelo basado en conectores de interacciones multiagente</br> que intenta identificar la estructura esencial subyacente a las interacciones multiagente.",
                "El resultado de este análisis será un <br>modelo basado en conectores de interacciones multiagentes</br> entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un <br>modelo basado en conectores de interacciones multiagente</br> que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un <br>modelo basado en conectores de interacciones multiagentes</br> entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    "modelo basado en conectores de interacciones multiagente",
                    "modelo basado en conectores de interacciones multiagentes"
                ]
            ]
        },
        "multi-agent interaction connector-based model": {
            "translated_key": "Modelo basado en conectores de interacción multiagente",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "formal execution semantics": {
            "translated_key": "semántica de ejecución formal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a <br>formal execution semantics</br> which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a <br>formal execution semantics</br> which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Furthermore, the paper also provides this model with a <br>formal execution semantics</br> which describes the dynamics of social interactions.",
                "Furthermore, the paper also provides this model with a <br>formal execution semantics</br> which describes the dynamics of multi-agent (or social) interactions."
            ],
            "translated_annotated_samples": [
                "Además, el artículo también proporciona a este modelo una <br>semántica de ejecución formal</br> que describe la dinámica de las interacciones sociales.",
                "Además, el artículo también proporciona a este modelo una <br>semántica de ejecución formal</br> que describe la dinámica de las interacciones multiagente (o sociales)."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una <br>semántica de ejecución formal</br> que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una <br>semántica de ejecución formal</br> que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "organizational programming language": {
            "translated_key": "lenguaje de programación organizacional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an <br>organizational programming language</br> which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "The proposed model is intended as the abstract machine of an <br>organizational programming language</br> which allows programmers to accommodate an open set of interaction mechanisms."
            ],
            "translated_annotated_samples": [
                "El modelo propuesto está destinado a ser la máquina abstracta de un <br>lenguaje de programación organizacional</br> que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un <br>lenguaje de programación organizacional</br> que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "software connector": {
            "translated_key": "conectores de software",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in <br>software connector</br>s: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of <br>software connector</br>s.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in <br>software connector</br>s: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "Towards a taxonomy of <br>software connector</br>s."
            ],
            "translated_annotated_samples": [
                "ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en <br>conectores de software</br>: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1].",
                "Hacia una taxonomía de <br>conectores de software</br>."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en <br>conectores de software</br>: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de <br>conectores de software</br>. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "social interaction": {
            "translated_key": "interacción social",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "Structural Operational Semantics (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "<br>social interaction</br> STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a <br>social interaction</br>, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a <br>social interaction</br> may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a <br>social interaction</br> context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "<br>social interaction</br> DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "<br>social interaction</br> STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a <br>social interaction</br>, so-called agents.",
                "Basically, this means that software components counting as agents in a <br>social interaction</br> may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This means that resources are created, accessed and manipulated by agents in a <br>social interaction</br> context (def. 6), according to the rules specified by its protocol.",
                "<br>social interaction</br> DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions."
            ],
            "translated_annotated_samples": [
                "ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1].",
                "Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una <br>interacción social</br>, llamados agentes.",
                "Básicamente, esto significa que los componentes de software que cuentan como agentes en una <br>interacción social</br> pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos.",
                "Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de <br>interacción social</br> (def. 6), de acuerdo con las reglas especificadas por su protocolo.",
                "DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la semántica operacional de los lenguajes de programación, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una <br>interacción social</br>, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una <br>interacción social</br> pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de <br>interacción social</br> (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "structural operational semantics": {
            "translated_key": "semántica operacional de los lenguajes de programación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Operational Semantics of Multiagent Interactions Juan M. Serrano University Rey Juan Carlos C/Tulipan S/N Madrid, Spain juanmanuel.serrano@urjc.es Sergio Saugar University Rey Juan Carlos C/Tulipan S/N Madrid, Spain sergio.saugar@urjc.es ABSTRACT The social stance advocated by institutional frameworks and most multi-agent system methodologies has resulted in a wide spectrum of organizational and communicative abstractions which have found currency in several programming frameworks and software platforms.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "In the realm of software architectures, the paper proposes a connector-based model of multi-agent interactions which attempts to identify the essential structure underlying multi-agent interactions.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of social interactions.",
                "The proposed model is intended as the abstract machine of an organizational programming language which allows programmers to accommodate an open set of interaction mechanisms.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-multi-agent systems General Terms Languages, Theory, Design 1.",
                "INTRODUCTION The suitability of agent-based computing to manage the complex patterns of interactions naturally occurring in the development of large scale, open systems, has become one of its major assets over the last few years [26, 24, 15].",
                "Particularly, the organizational or social stance advocated by institutional frameworks [2] and most multi-agent system (MAS) methodologies [26, 10], provides an excellent basis to deal with the complexity and dynamism of the interactions among system components.",
                "This approach has resulted in a wide spectrum of organizational and communicative abstractions, such as institutions, normative positions, power relationships, organizations, groups, scenes, dialogue games, communicative actions (CAs), etc., to effectively model the interaction space of MAS.",
                "This wealth of computational abstractions has found currency in several programming frameworks and software platforms (AMELI [9], MadKit [13], INGENIAS toolkit [18], etc. ), which leverage multi-agent middlewares built upon raw ACL-based interaction mechanism [14], and minimize the gap between organizational metamodels and target implementation languages.",
                "Still, these tools and frameworks are designed to support a limited range of interaction capabilities that constrain developers to a fixed set of particular, pre-defined abstractions.",
                "The main hypothesis motivating this paper is that the variety of multi-agent interaction mechanisms - both, organizational and communicative, share a common semantic core.",
                "This paper thus focuses on the fundamental building blocks of multi-agent interactions: those which may be composed, extended or refined in order to define more complex organizational or communicative types of interactions.",
                "Its first goal is to carry out a principled analysis of multiagent interactions, departing from general features commonly ascribed to agent-based computing: autonomy, situatedness and sociality [26].",
                "To approach this issue, we draw on the notion of connector, put forward within the field of software architectures [1, 17].",
                "The outcome of this analysis will be a connector-based model of multi-agent interactions between autonomous social and situated components, i.e. agents, attempting to identify their essential structure.",
                "Furthermore, the paper also provides this model with a formal execution semantics which describes the dynamics of multi-agent (or social) interactions.",
                "<br>structural operational semantics</br> (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose.",
                "The paper is structured as follows: first, the major entities and relationships which constitute the structure of social interactions are introduced.",
                "Next, the dynamics of social interactions will show how these entities and relationships evolve.",
                "Last, relevant work in the literature is discussed 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS with respect to the proposal, limitations are addressed, and current and future work is described. 2.",
                "SOCIAL INTERACTION STRUCTURE From an architectural point of view, interactions between software components are embodied in software connectors: first-class entities defined on the basis of the different roles played by software components and the protocols that regulate their behaviour [1].",
                "The roles of a connector represent its participants, such as the caller and callee roles of an RPC connector, or the sender and receiver roles in a message passing connector.",
                "The attachment operation binds a component to the role of a given connector.",
                "The analysis of social interactions introduced in this section gives rise to a new kind of social connector.",
                "It refines the generic model in several respects, attending to the features commonly ascribed to agent-based computing: • According to the autonomy feature, we may distinguish a first kind of participant (i.e. role) in a social interaction, so-called agents.",
                "Basically, agents are those software components which will be regarded as autonomous within the scope of the interaction1 . • A second group of participants, so-called environmental resources, may be identified from the situatedness feature.",
                "Unlike agents, resources represent those nonautonomous components whose state may be externally controlled by other components (agents or resources) within the interaction.",
                "Moreover, the participation of resources in an interaction is not mandatory. • Last, according to the sociality of agents, the specification of social connector protocols - the glue linking agents among themselves and with resources, will rely on normative concepts such as permissions, obligations and empowerments [23].",
                "Besides agents, resources and social protocols, two other kinds of entities are of major relevance in our analysis of social interactions: actions, which represent the way in which agents alter the environmental and social state of the interaction; and events, which represent the changes in the interaction resulting from the performance of actions or the activity of environmental resources.",
                "In the following, we describe the basic entities involved in social interactions.",
                "Each kind of entity T will be specified as a record type T l1 : T1, . . . ln : Tn , possibly followed by a number of invariants, definitions, and the actions affecting their state.",
                "Instances or values v of a record type T will be represented as v = v1, . . . , vn : T. The type SetT represents a collection of values drawn from type T. The type QueueT represents a queue of values v : T waiting to be processed.",
                "The value v in the expression [v| ] : Queue[T] represents the head of the queue.",
                "The type Enum {v1, . . . , vn} 1 Note that we think of the autonomy feature in a relative, rather than absolute, perspective.",
                "Basically, this means that software components counting as agents in a social interaction may behave non-autonomously in other contexts, e.g. in their interactions through human-user interfaces.",
                "This conceptualization of agenthood resembles the way in which objects are understood in CORBA: as any kind of software component (C, Prolog, Cobol, etc.) attached to an ORB. represents an enumeration type whose values are v1, . . . , vn.",
                "Given some value v : T, the term vl refers to the value of the field l of a record type T. Given some labels l1, l2, . . . , the expression vl1,l2,... is syntactic sugar for ((vl1 )l2 ) . . ..",
                "The special term nil will be used to represent the absence of proper value for an optional field, so that vl = nil will be true in those cases and false otherwise.",
                "The formal model will be illustrated with several examples drawn from the design of a virtual organization to aid in the management of university courses. 2.1 Social Interactions Social interactions shall be considered as composite connectors [17], structured in terms of a tree of nested subinteractions.",
                "Lets consider an interaction representing a university course (e.g. on data structures).",
                "On the one hand, this interaction is actually a complex one, made up of lower-level interactions.",
                "For instance, within the scope of the course agents will participate in programming assignment groups, lectures, tutoring meetings, examinations and so on.",
                "Assignment groups, in turn, may hold a number of assignment submissions and test requests interactions.",
                "A test request may also be regarded as a complex interaction, ultimately decomposed in the atomic, or bottom-level interactions represented by communicative actions (e.g. request, agree, refuse, . . . ).",
                "On the other hand, courses are run within the scope of a particular degree (e.g. computer science), a higher-level interaction.",
                "Traversing upwards from a degree to its ancestors, we find its faculty, the university and, finally, the multi-agent community or agent society.",
                "The community is thus the top-level interaction which subsumes any other kind of multi-agent interaction2 .",
                "The organizational and communicative interaction types identified above clearly differ in many ways.",
                "However, we may identify four major components in all of them: the participating agents, the resources that agents manipulate, the protocol regulating the agent activities and the subinteraction space.",
                "Accordingly, we may specify the type I of social interactions, ranged over by the meta-variable i, as follows: I state : SI, ini : A, mem : Set A, env : Set R, sub : Set I, prot : P, ch : CH def. : (1) icontext = i1 ⇔ i ∈ isub 1 inv. : (2) iini = nil ⇔ icontext = nil act. : setUp, join, create, destroy where the member and environment fields represent the agents (A) and local resources (R) participating in the interaction; the sub-interaction field, its set of inner interactions; and the protocol field the rules that govern the interaction (P).",
                "The event channel, to be described in the next section, allows the dispatching of local events to external interactions.",
                "The context of some interaction is defined as its super-interaction (def. 1), so that the context of the toplevel interaction is nil.",
                "The type SI Enum {open, closing, closed} represents the possible execution states of the interaction.",
                "Any interaction, but the top-level one, is set up within the context of another interaction by an initiator agent.",
                "The initiator is 2 In the context of this application, a one-to-one mapping between human users and software components attached to the community as agents would be a right choice. 890 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) thus a mandatory feature for any interaction different to the community (inv. 2).",
                "The life-cycle of the interaction begins in the open state.",
                "Its sets of agent and resource participants, initially empty, vary as agents join and leave the interaction, and as they create and destroy resources from its local environment.",
                "Eventually, the interaction may come to an end (according to the protocols rules), or be explicitly closed by some agent, thus prematurely disabling the activity of its participants.",
                "The transient closing state will be described in the next section. 2.2 Agents Components attach themselves as agents in social interactions with the purpose of achieving something.",
                "The purpose declared by some agent when it joins an interaction shall be regarded as the institutional goal that it purports to satisfy within that context3 .",
                "The types of agents participating in a given interaction are primarily identified from their purposes.",
                "For instance, students are those agents participating in a course who purport to obtain a certificate in the courses subject.",
                "Other members of the course include lecturers and teaching assistants.",
                "The type A of agents, ranged over by meta-variable a, is defined as follows: A state : SA, player : A, purp : F, att : Queue ACT , ev : Queue E, obl : Set O def. : (3) acontext = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act. : see where the purpose is represented as a well-formed boolean formula, of a generic type F, which evaluates to true if the purpose is satisfied and false otherwise.",
                "The context of some agent is defined as the interaction in which it participates (def. 3).",
                "The type SA Enum {playing, leaving, succ, unsuc} represents the execution state of the agent.",
                "Its life-cycle begins in the playing state when its player agent joins the interaction, or some software component is attached as an agent to the multi-agent system (in this latter case, the player value is nil).",
                "The derived roles and partIn features represent the roles played by the agent and the contexts in which these roles are played (def. 4, 5)4 .",
                "An agent may play roles at interactions within or outside the scope of its context.",
                "For instance, students of a course are played by student agents belonging to the (undergraduate) degree, whereas lecturers may be played by teachers of a given department and the assistant role may be played by students of a Ph.D degree (both, the department and the Ph.D. degrees, are modelled as sub-interactions of the faculty).",
                "Components will normally attempt to perform different actions (e.g. to set up sub-interactions) in order to satisfy their purposes within some interaction.",
                "Moreover, components need to be aware of the current state of the interaction, so that they will also be capable of observing certain events from the interaction.",
                "Both, the visibility of the interaction 3 Thus, it may or may not correspond to actual internal goals or intentions of the component. 4 Free variables in the antecedents/consequents of implications shall be understood as universally/existentially quantified. and the attempts of members, are subject to the rules governing the interaction.",
                "The attempts and events fields of the agent structure represent the queues of attempts to execute some actions (ACT ), and the events (E) received by the agent which have not been observed yet.",
                "An agent may update its event queue by seeing the state of some entity of the community.",
                "The last field of the structure represents the obligations (O) of agents, to be described later.",
                "Eventually, the participation of some agent in the interaction will be over.",
                "This may either happen when certain conditions are met (specified by the protocol rules), or when the agent takes the explicit decision of leaving the interaction.",
                "In either case, the final state of the agent will be successful if its purpose was satisfied; unsuccessful otherwise.",
                "The transient leaving state will be described in the next section. 2.3 Resources Resources are software components which may represent different types of non-autonomous informational or computational entities.",
                "For instance, objectives, topics, assignments, grades and exams are different kinds of informational resources created by lecturers and assistants in the context of the course interaction.",
                "Students may also create programs to satisfy the requirements of some assignment.",
                "Other types of computational resources put at the disposal of students by teachers include compilers and interpreters.",
                "The type R of resources, ranged over by meta-variable r, can be specified by the following record type: R cr : A, owners : Set A, op : Set OP def. : (6) rcontext = i ⇔ r ∈ ienv act. : take, share, give, invoke Essentially, resources can be regarded as objects deployed in a social setting.",
                "This means that resources are created, accessed and manipulated by agents in a social interaction context (def. 6), according to the rules specified by its protocol.",
                "The mandatory feature creator represents the agent who created this resource.",
                "Moreover, resources may have owners.",
                "The ownership relationship between members and resources is considered as a normative device aimed at the simplification of the protocols rules that govern the interaction of agents and the environment.",
                "Members may gain ownership of some resource by taking it, and grant ownership to other agents by giving or sharing their own properties.",
                "For instance, the ownership of programs may be shared by several students if the assignment can be performed by groups of two or more students.",
                "The last operations feature represents the interface of the resource, consisting of a set of operations.",
                "A resource is structured around several public operations that participants may invoke, in accordance to the rules specified by the interactions protocol.",
                "The set of operations of a resource makes up its interface. 2.4 Protocols The protocol of any interaction is made up of the rules which govern its overall state and dynamics.",
                "The present specification abstracts away the particular formalism used to specify these rules, and focuses instead on several requirements concerning the structure and interface of protocols.",
                "Accordingly, the type P of protocols, ranged over by metaThe Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 891 variable p, is defined as follows5 : P emp : A × ACT → Boolean, perm : A × ACT → Boolean, obl :→ Set (A × Set O × Set E), monitor : E → Set A, finish :→ Boolean, over : A → Boolean def. : (7) pcontext = i ⇔ p = iprot inv. : (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor( a, α, ) act. : Close, Leave We demand from protocols four major kinds of functions.",
                "Firstly, protocols shall include rules to identify the empowerments and permissions of any agent attempting to alter the state of the interaction (e.g. its members, the environment, etc.) through the execution of some action (e.g. join, create, etc.).",
                "Empowerments shall be regarded as the institutional capabilities which some agent possesses in order to satisfy its purpose.",
                "Corresponding rules, encapsulated by the empowered function field, shall allow to determine whether some agent is capable to perform a given action over the interaction.",
                "Empowerments may only be exercised under certain circumstances - that permissions specify.",
                "Permission rules shall allow to determine whether the attempt of an empowered agent to perform some particular action is satisfied or not (cf. permitted field).",
                "For instance, the courses protocol specifies that the agents empowered to join the interaction as students are those students of the degree who have payed the fee established for the courses subject, and own the certificates corresponding to its prerequisite subjects.",
                "Permission rules, in turn, specify that those students may only join the course in the admission stage.",
                "Hence, even if some student has paid the fee, the attempt to join the course will fail if the course has not entered the corresponding stage6 .",
                "Secondly, protocols shall allow to determine the obligations of agents towards the interaction.",
                "Obligations represent a normative device of social enforcement, fully compatible with the autonomy of agents, used to bias their behaviour in a certain direction.",
                "These kinds of rules shall allow to determine whether some agent must perform an action of a given type, as well as if some obligation was fulfilled, violated or needs to be revoked.",
                "The function obligations of the protocol structure thus identifies the agents whose obligation set must be updated.",
                "Moreover, it returns for each agent a collection of events representing the changes in the obligation set.",
                "For instance, the courses protocol establishes that members of departments must join the course as teachers whenever they are assigned to the courses subject.",
                "Thirdly, the protocol shall allow to specify monitoring rules for the different events originating within the interaction.",
                "Corresponding rules shall establish the set of agents that must be awared of some event.",
                "For instance, this func5 The formalization assumes that protocols functions implicitly recieve as input the interaction being regulated. 6 The hasPaidFee relationship between (degree) students and subject resources is represented by an additional, application-dependent field of the agent structure for this kind of roles.",
                "Similarly, the admission stage is an additional boolean field of the structure for school interactions.",
                "The generic types I, A, R and P are thus extendable. tionality is exploited by teachers in order to monitor the enrollment of students to the course.",
                "Last, the protocol shall allow to control the state of the interaction as well as the states of its members.",
                "Corresponding rules identify the conditions under which some interaction will be automatically finished, and whether the participation of some member agent will be automatically over.",
                "Thus, the function field finish returns true if the regulated interaction must finish its execution.",
                "If so happens, a well-defined set of protocols must ensure that its sub-interactions and members are finished as well (inv. 8,9).",
                "Similarly, the function over returns true if the participation of the specified member must be over.",
                "Well-formed protocols must ensure the consistency between these functions across playing roles (inv. 10)7 .",
                "For instance, the courses protocol establishes that the participation of students is over when they gain ownership of the courses certificate or the chances to get it are exhausted.",
                "It also establishes that the course must be finished when the admission stage has passed and all the students finished their participation. 3.",
                "SOCIAL INTERACTION DYNAMICS The dynamics of the multi-agent community is influenced by the external actions executed by software components and the protocols governing their interactions.",
                "This section focuses on the dynamics resulting from a particular kind of external action: the attempt of some component, attached to the community as an agent, to execute a given (internal) action.",
                "The description of other external actions concerning agents (e.g. observe the events from its event queue, enter or exit from the community) and resources (e.g. a timer resource may signal the pass of time) will be skipped.",
                "The processing of some attempt may give rise to changes in the scope of the target interaction, such as the instantiation of new participants (agents or resources) or the setting up of new sub-interactions.",
                "These resulting events may cause further changes in the state of other interactions (the target one included), namely, in its execution state as well as in the execution state, obligations and visibility of their members.",
                "This section will also describe the way in which these events are processed.",
                "The resulting dynamics described bellow allows for actions and events corresponding to different agents and interactions to be processed simultaneously.",
                "Due to lack of space, we only include some of the operational rules that formalise the execution semantics. 3.1 Attempt processing An attempt is defined by the structure AT T perf : A, act : ACT , where the performer represents the agent in charge of executing the specified action.",
                "This action is intended to alter the state of some target interaction (possibly, the performers context itself), and notify a collection of addressees of the changes resulting from a successful execution.",
                "Accordingly, the type ACT of actions, ranged over by meta-variable α, is specified as follows: ACT state : SACT , target : I, add : Set A def. : (12) αperf = a ⇔ α ∈ aatt 7 The close and leave actions update the finish and over function fields as explained in the next section.",
                "Additional actions, such as permit, forbid, empower, etc., to update other protocols fields are yet to be identified in future work. 892 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) where: the performer is formally defined as the agent who stores the action in its queue of attempts, and the state field represents the current phase of processing.",
                "This process goes through four major phases, as specified by the enumeration type SACT Enum {emp, perm, exec} : empowerment checking, permission checking and action execution, described in the sequel. 3.1.1 Empowerment checking The post-condition of an attempt consists of inserting the action in the queue of attempts of the specified performer.",
                "As rule 1 specifies8 , this will only be possible if the performer is empowered to execute that action according to the rules that govern the state of the target interaction.",
                "If this condition is not met, the attempt will simply be ignored.",
                "Moreover, the performer agent must be in the playing state (this pre-condition is also required for any rule concerning the processing of attempts).",
                "If these pre-conditions are satisfied the rule is fired and the processing of the action continues in the permission checking stage.",
                "For instance, when the software component attached as a student in a degree attempts to join as a student the course in which some subject is teached, the empowerment rules of the course interaction are checked.",
                "If the (degree) student has passed the courses prerequisite subjects the join action will be inserted in its queue of attempts and considered for execution. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) W here : (α )state = perm (qACT ) = insert(α , qACT ) 3.1.2 Permissions checking The processing of the action resumes when the possible preceding actions in the performers queue of attempts are fully processed and removed from the queue.",
                "Moreover, there should be no pending events to be processed in the interaction, for these events may cause the member or the interaction to be finished (as will be shortly explained in the next sub-section).",
                "If these conditions are met the permissions to execute the given action (and notify the specified addressees) are checked (e.g. it will be checked whether the student paid the fee for the courses subject).",
                "If the protocol of the target interaction grants permission, the processing of the attempt moves to the action execution stage (rule 2).",
                "Otherwise, the action is discharged and removed from the queue.",
                "Unlike unempowered attempts, a forbidden one will cause an event to be generated and transfered to the event channel for further processing. αstate = perm ∧ acontext,ch,in,ev = ∅ ∧ αtarget,prot,perm(a, α) a = playing, , , [α| ], , −→ playing, , , [α | ], , (2) W here : (α )state = exec 8 Labels of record instances are omitted to allow for more compact specifications.",
                "Moreover, note that record updates in where clauses only affect the specified fields. 3.1.3 Action execution The transitions fired in this stage are classified according to the different types of actions to be executed.",
                "The intended effects of some actions may directly be achieved in a single step, while others will required an indirect approach and possibly several execution steps.",
                "Actions of the first kind are constructive ones such as set up and join.",
                "The second group of actions include those, such as close and leave, whose effects are indirectly achieved by updating the interaction protocol.",
                "As an example of constructive action, lets consider the execution of a set up action, whose type is defined as follows9 : SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open where the new field represents the new interaction to be initiated.",
                "Its sets of participants (agents and resources) and sub-interactions must be empty (inv. 13) and its state must be open (inv. 14).",
                "The setting up of the new interaction may thus affect its protocol and possible application-dependent fields (e.g. the subject of a course interaction).",
                "According to rule 3, the outcome of the execution is threefold: firstly, the performers attempt queue is updated so that the executing action is removed; secondly, the new interaction is added to the targets set of sub-interactions (moreover, its initiator field is set to the performer agent); last, the event representing this change (which includes a description of the change, the agent that caused it and the action performed) is inserted in the output port of the targets event channel. αstate = exec ∧ α : SetUp ∧ αnew = i a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , sI , c −→ open, , , , , sI ∪ i , c (3) W here : (i )ini = a (c )out,ev = insert( a, α, sub(αtarget , i ) , cout,ev ) Lets consider now the case of a close action.",
                "This action represents an attempt by the performer to force some interaction to finish, thus bypassing its current protocol rules (those concerning the finish function).",
                "The way to achieve this effect is to cause an update on the protocol so that the finish function returns true afterwards10 .",
                "Accordingly, we may specify this type of action as follows: Close ACT · upd : (→ Bool) → (→ Bool) inv. : (15) αtarget,state = open (16) αtarget,context = nil (17) αupd(αtarget,prot,finish)() where the inherited target field represents the interaction to be closed (which must be open and different to the topinteraction, according to invariants 15 and 16) and the new 9 The resulting type consists of the fields of the ACT record extended with an additional new field. 10 This strategy is also followed in the definition of leave and may also be used in the definition of other types of actions such as fire, permit, forbid, etc.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 893 update field represents a proper higher-order function to update the targets protocol (inv. 17).",
                "The transition which models the execution of this action, specified by rule 4, defines two effects in the target interaction: its protocol is updated and the event representing this change is inserted in its output port.",
                "This event will actually trigger the closing process of the interaction as described in the next subsection. αstate = exec ∧ α : Close a = playing, , , [α|qACT ], , −→ playing, , , qACT , , αtarget = open, , , , , p, c −→ open, , , , , p , c (4) W here : (p )finish = αupd (pfinish ) (c )out,ev = insert( a, α, finish(αtarget ) , cout,ev ) 3.2 Event Processing The processing of events is encapsulated in the event channels of interactions.",
                "Channels, ranged over by meta-variable c, are defined by two input and output ports, according to the following definition: CH out : OutP, in : InP inv. : (18) ccontext ∈ cout,disp( , , finish(ccontext) ) (19) ccontext ∈ cout,disp( , , over(a) ) (20) ccontext,sub ⊆ cout,disp(closing(ccontext)) (21) apartsIn ⊆ cout,disp(leaving(a)) (22) ccontext ∈ cout,disp(closed(i)) (23) {ccontext, aplayer,context} ⊆ cout,disp(left(a)) OutP ev : Queue E, disp : E → Set I, int : Set I, ag : Set A InP ev : Queue E, stage : Enum {int, mem, obl}, ag : Set A The output port stores and processes the events originated within the scope of the channels interaction.",
                "Its first purpose is to dispatch the local events to the agents identified by the protocols monitoring function.",
                "Moreover, since these events may influence the results of the finishing, over and obligation functions of certain protocols, they will also be dispatched to the input ports of the interactions identified through a dispatching function - whose invariants will be explained later on.",
                "Thus, input ports serve as a coordination mechanism which activate the re-evaluation of the above functios whenever some event is received11 .",
                "Accordingly, the processing of some event goes through four major stages: event dispatching, interaction state update, member state update and obligations update.",
                "The first one takes place in the output port of the interaction in which the event originated, whereas the other ones execute in separate control threads associated to the input ports of the interactions to which the event was dispatched. 3.2.1 Event dispatching The processing of some event stored in the output port is triggered when all its preceding events have been dispatched.",
                "As a first step, the auxiliary int and ag fields are initialised 11 Alternatively, we may have assumed that interactions are fully aware of any change in the multi-agent community.",
                "In this scenario, interactions would trigger themselves without requiring any explicit notification.",
                "On the contrary, we adhere to the more realistic assumption of limited awareness. with the returned values of the dispatching and protocols monitoring functions, respectively (rule 5).",
                "Then, additional rules simply iterate over these collections until all agents and interactions have been notified (i.e., both sets are empty).",
                "Last, the event is removed from the queue and the auxiliary fields are re-set to nil.",
                "The dispatching function shall identify the set of interactions (possibly, empty) that may be affected by the event (which may include the channels interaction itself)12 .",
                "For instance, according to the finishing rule of university courses mentioned in the last section, the event representing the end of the admission stage, originated within the scope of the school interaction, will be dispatched to every course of the schools degrees.",
                "Concerning the monitoring function, according to invariant 11 of protocols, if the event is generated as the result of an action performance, the agents to be notified will include the performer and addressees of that action.",
                "Thus, according to the monitoring rule of university courses, if a student of some degree joins a certain course and specifies a colleague as addressee of that action, the courses teachers and itself will also be notified of the successful execution. ccontext,state s = open ∧ ccontext,prot,monitor s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Interaction state update Input port activity is triggered when a new event is received.",
                "Irrespective of the kind of incoming event, the first processing action is to check whether the channels interaction must be finished.",
                "Thus, the dispatching of the finish event resulting from a close action (inv. 18) serves as a trigger of the closing procedure.",
                "If the interaction has not to be finished, the input port stage field is set to the member state update stage and the auxiliary ag field is initialised to the interaction members.",
                "Otherwise, we can consider two possible scenarios.",
                "In the first one, the interaction has no members and no sub-interactions.",
                "In this case, the interaction can be inmediately closed down.",
                "As rule 6 shows, the interaction is closed, removed from the contexts set of sub-interactions and a closed event is inserted in its output channel.",
                "According to invariant 22, this event will be later inserted to its input channel to allow for further treatment. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ closed, , , , , , (6) W here : (c )out,ev = insert(closed(i), cout,ev ) In the second scenario, the interaction has some member or sub-interaction.",
                "In this case, clean-up is required prior to the disposal of the interaction (e.g. if the admission period ends and no student has matriculated for the course, teachers has to be finished before finishing the course itself).",
                "As rule 7 shows, the interaction is moved to the transient closing state and a corresponding event is inserted in the output port.",
                "According to invariant 20, the closing event will be dispatched to every sub-interaction in order to activate its closing procedure (guaranteed by invariant 8).",
                "Moreover, 12 This is essentially determined by the protocol rules of these interactions.",
                "The way in which the dispatching function is initialised and updated is out of the scope of this paper. 894 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the stage and ag fields are properly initialised so that the process goes on in the next member state update stage.",
                "This stage will further initiate the leaving process of the members (according to invariant 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = open, , sA, , sI , p, c −→ closing, , sA, , sI , p, c (7) W here : (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventually, every member will leave the interaction and every sub-interaction will be closed.",
                "Corresponding events will be received by the interaction (according to invariants 23 and 22) so that the conditions of the first scenario will hold. 3.2.3 Member state update This stage simply iterates over the members of the interaction to check whether they must be finished according to the protocols over function.",
                "When all members have been checked, the stage field will be set to the next obligation update stage and the auxiliary ag field will be initalised with the agents identified by the protocols obligation update function.",
                "If some member has to end its participation in the interaction and it is not playing any role, it will be inmediately abandoned (successfully or unsuccessfully, according to the satisfaction of its purpose).",
                "The corresponding event will be forwarded to its interaction and to the interaction of its player agent to account for further changes (inv. 23).",
                "Otherwise, the member enters the transient leaving state, thus preventing any action performance.",
                "Then, it waits for the completion of the leaving procedures of its played roles, triggered by proper dispatching of the leaving event (inv. 21). 3.2.4 Obligations update In this stage, the obligations of agents (not necessaryly members of the interaction) towards the interaction are updated accordingly.",
                "When all the identified agents have been updated, the event is removed from the input queue and the stage field is set back to the interaction state update.",
                "For instance, when a course interaction receives an event representing the assignment of some department member to its subject, an obligation to join the course as a teacher is created for that member.",
                "Moreover, the event representing this change is added to the output channel of the department interaction. 4.",
                "DISCUSSION This paper has attempted to expose a possible semantic core underlying the wide spectrum of interaction types between autonomous, social and situated software components.",
                "In the realm of software architectures, this core has been formalised as an operational model of social connectors, intended to describe both the basic structure and dynamics of multi-agent interactions, from the largest (the agent society itself) down to the smallest ones (communicative actions).",
                "Thus, top-level interactions may represent the kind of agent-web pursued by large-scale initiatives such as the Agentcities/openNet one [25].",
                "Large-scale interactions, modelling complex aggregates of agent interactions such as those represented by e-institutions or virtual organizations [2, 26], are also amenable to be conceptualised as particular kinds of first-level social interactions.",
                "The last levels of the interaction tree may represent small-scale multiagent interactions such as those represented by interaction protocols [11], dialogue games [16], or scenes [2].",
                "Finally, bottom-level interactions may represent communicative actions.",
                "From this perspective, the member types of a CA include the speaker and possibly many listeners.",
                "The purpose of the speaker coincides with the illocutionary purpose of the CA [22], whereas the purpose of any listener is to declare that it (actually, the software component) successfully processed the meaning of the CA.",
                "The analysis of social interactions put forward in this paper draws upon current proposals of the literature in several general respects, such as the institutional and organizational character of multi-agent systems [2, 26, 10, 7] and the normative perspective on multi-agent protocols [12, 23, 20].",
                "These proposals as well as others focusing in relevant abstractions such as power relationships, contracts, trust and reputation mechanisms in organizational settings, etc., could be further exploited in order to characterize more accurately the organizational character of some multi-agent interactions.",
                "Similarly, the conceptualization of communicative actions as atomic interactions may similarly benefit from public semantics of communicative actions such as the one introduced in [3].",
                "Last, the abstract model of protocols may be refined taking into account existing operational models of norms [12, 6].",
                "These analyses shall result in new organizational and communicative abstractions obtained through a refinement and/or extension of the general model of social interactions.",
                "Thus, the proposed model is not intended to capture every organizational or communicative feature of multi-agent interactions, but to reveal their roots in basic interaction mechanisms.",
                "In turn, this would allow for the exploitation of common formalisms, particularly concerning protocols.",
                "Unlike the development of individual agents, which has greatly benefited from the design of several agent programming languages [4], societal features of multi-agent systems are mostly implemented in terms of visual modelling [8, 18] and a fixed set of interaction abstractions.",
                "We argue that the current field of multi-agent system programming may greatly benefit from multi-agent programming languages that allow programmers to accommodate an open set of interaction mechanisms.",
                "The model of social interactions put forward in this paper is intended as the abstract machine of a language of this type.",
                "This abstract machine would be independent of particular agent architectures and languages (i.e. software components may be programmed in a BDI language such as Jason [5] or in a non-agent oriented language).",
                "On top of the presented execution semantics, current and future work aims at the specification of the type system [19] which allows to program the abstract machine, the specification of the corresponding surface syntaxes (both textual and visual) and the design and implementation of a virtual machine over existing middleware technologies such as FIPA platforms or Web services.",
                "We also plan to study particular refinements and limitations to the proposed model, particularly with respect to the dispatching of events, semantics The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 895 of obligations, dynamic updates of protocols and rule formalisms.",
                "In this latter aspect, we plan to investigate the use of Answer Set Programming to specify the rules of protocols, attending to the role that incompleteness (rules may only specify either necessary or sufficient conditions, for instance), explicit negation (e.g. prohibitions) and defaults play in this domain. 5.",
                "ACKNOWLEDGMENTS The authors thank anonymous reviewers for their comments and suggestions.",
                "Research sponsored by the Spanish Ministry of Science and Education (MEC), project TIN200615455-C03-03. 6.",
                "REFERENCES [1] R. Allen and D. Garlan.",
                "A Formal Basis for Architectural Connection.",
                "ACM Transactions on Software Engineering and Methodology, 6(3):213-249, June 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J.",
                "A. Rodr´ıguez, and C. Sierra.",
                "Engineering open environments with electronic institutions.",
                "Journal on Engineering Applications of Artificial Intelligence, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn, and L. W. N. van der Torre.",
                "Role-based semantics for agent communication: embedding of the mental attitudes and social commitments semantics.",
                "In AAMAS, pages 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr, and A. Ricci.",
                "A survey of programming languages and platforms for multi-agent systems.",
                "Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira.",
                "Jason and the golden fleece of agent-oriented programming.",
                "In R. H. Bordini, D. M., J. Dix, and A. El Fallah Seghrouchni, editors, Multi-Agent Programming: Languages, Platforms and Applications, chapter 1.",
                "Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos, and J.",
                "A. Padget.",
                "Specifying and analysing agent-based social institutions using answer set programming.",
                "In EUMAS, pages 476-477, 2005. [7] V. Dignum, J. V´azquez-Salceda, and F. Dignum.",
                "Omni: Introducing social structure, norms and ontologies into agent organizations.",
                "In R. Bordini, M. Dastani, J. Dix, and A. Seghrouchni, editors, Programming Multi-Agent Systems Second International Workshop ProMAS 2004, volume 3346 of LNAI, pages 181-198.",
                "Springer, 2005. [8] M. Esteva, D. de la Cruz, and C. Sierra.",
                "ISLANDER: an electronic institutions editor.",
                "In M. Gini, T. Ishida, C. Castelfranchi, and W. L. Johnson, editors, Proceedings of the First International Joint Conference on Autonomous Agents and Multiagent Systems (AAMAS02), pages 1045-1052.",
                "ACM Press, July 2002. [9] M. Esteva, B. Rosell, J.",
                "A. Rodr´ıguez-Aguilar, and J. L. Arcos.",
                "AMELI: An agent-based middleware for electronic institutions.",
                "In Proceedings of the Third International Joint Conference on Autonomous Agents and Multiagent Systems, volume 1, pages 236-243, 2004. [10] J. Ferber, O. Gutknecht, and F. Michel.",
                "From agents to organizations: An organizational view of multi-agent systems.",
                "In AOSE, pages 214-230, 2003. [11] Foundation for Intelligent Physical Agents.",
                "FIPA Interaction Protocol Library Specification. http://www.fipa.org/repository/ips.html, 2003. [12] A. Garc´ıa-Camino, J.",
                "A. Rodr´ıguez-Aguilar, C. Sierra, and W. Vasconcelos.",
                "Norm-oriented programming of electronic institutions.",
                "In AAMAS, pages 670-672, 2006. [13] O. Gutknecht and J. Ferber.",
                "The MadKit agent platform architecture.",
                "Lecture Notes in Computer Science, 1887:48-55, 2001. [14] JADE.",
                "The JADE project home page. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory, and S. Willmott.",
                "Agent Technology: Computing as Interaction - A Roadmap for Agent-Based Computing.",
                "AgentLink III, 2005. [16] P. McBurney and S. Parsons.",
                "A formal framework for inter-agent dialogues.",
                "In J. P. M¨uller, E. Andre, S. Sen, and C. Frasson, editors, Proceedings of the Fifth International Conference on Autonomous Agents, pages 178-179, Montreal, Canada, May 2001.",
                "ACM Press. [17] N. R. Mehta, N. Medvidovic, and S. Phadke.",
                "Towards a taxonomy of software connectors.",
                "In Proceedings of the 22nd International Conference on Software Engineering, pages 178-187.",
                "ACM Press, June 2000. [18] J. Pav´on and J. G´omez-Sanz.",
                "Agent oriented software engineering with ingenias.",
                "In V. Marik, J. Muller, and M. Pechoucek, editors, Proceedings of the 3rd International Central and Eastern European Conference on Multi-Agent Systems.",
                "Springer Verlag, 2003. [19] B. C. Pierce.",
                "Types and Programming Languages.",
                "The MIT Press, Cambridge, MA, 2002. [20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis.",
                "Voting in multi-agent systems.",
                "Feb. 27 2006. [21] G. Plotkin.",
                "A structural approach to operational semantics.",
                "Technical Report DAIMI FN-19, Aarhus University, Sept. 1981. [22] J. Searle.",
                "Speech Acts.",
                "Cambridge University Press, 1969. [23] M. Sergot.",
                "A computational theory of normative positions.",
                "ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh.",
                "Agent-based abstractions for software development.",
                "In F. Bergenti, M.-P. Gleizes, and F. Zambonelli, editors, Methodologies and Software Engineering for Agent Systems, chapter 1, pages 5-18.",
                "Kluwer, 2004. [25] S. Willmot and al.",
                "Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge.",
                "Developing multiagent systems: The Gaia methodology.",
                "ACM Transactions on Software Engineering and Methodology, 12(3):317-370, July 2003. 896 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "<br>structural operational semantics</br> (SOS)[21], a common technique to specify the operational semantics of programming languages, is used for this purpose."
            ],
            "translated_annotated_samples": [
                "La Semántica Operacional Estructural (SOS), una técnica común para especificar la <br>semántica operacional de los lenguajes de programación</br>, se utiliza con este propósito."
            ],
            "translated_text": "Semántica Operacional de Interacciones Multiagente\nJuan M. Serrano\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\njuanmanuel.serrano@urjc.es\nSergio Saugar\nUniversidad Rey Juan Carlos C/Tulipán S/N Madrid, España\nsergio.saugar@urjc.es\nRESUMEN\nLa postura social defendida por marcos institucionales y la mayoría de las metodologías de sistemas multiagente ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas que han encontrado aceptación en varios marcos de programación y plataformas de software. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares y predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. En el ámbito de las arquitecturas de software, el artículo propone un modelo basado en conectores de interacciones multiagente que intenta identificar la estructura esencial subyacente a las interacciones multiagente. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones sociales. El modelo propuesto está destinado a ser la máquina abstracta de un lenguaje de programación organizacional que permite a los programadores adaptar un conjunto abierto de mecanismos de interacción. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-sistemas multiagente Términos Generales Lenguajes, Teoría, Diseño 1. INTRODUCCIÓN La idoneidad de la computación basada en agentes para gestionar los complejos patrones de interacciones que ocurren naturalmente en el desarrollo de sistemas abiertos a gran escala, se ha convertido en uno de sus principales activos en los últimos años [26, 24, 15]. Particularmente, la postura organizativa o social defendida por los marcos institucionales y la mayoría de las metodologías de sistemas multiagentes (MAS) proporciona una excelente base para abordar la complejidad y dinamismo de las interacciones entre los componentes del sistema. Este enfoque ha dado lugar a un amplio espectro de abstracciones organizativas y comunicativas, como instituciones, posiciones normativas, relaciones de poder, organizaciones, grupos, escenas, juegos de diálogo, acciones comunicativas (CAs), etc., para modelar de manera efectiva el espacio de interacción de los Sistemas Multiagente (MAS). Esta riqueza de abstracciones computacionales ha encontrado aceptación en varios marcos de programación y plataformas de software (AMELI [9], MadKit [13], kit de herramientas INGENIAS [18], etc.), que aprovechan middleware multiagente construido sobre un mecanismo de interacción basado en ACL crudo [14], y minimizan la brecha entre los metamodelos organizativos y los lenguajes de implementación objetivo. Sin embargo, estas herramientas y marcos están diseñados para soportar un rango limitado de capacidades de interacción que restringen a los desarrolladores a un conjunto fijo de abstracciones particulares predefinidas. La hipótesis principal que motiva este artículo es que la variedad de mecanismos de interacción multiagente, tanto organizativos como comunicativos, comparten un núcleo semántico común. Este artículo se centra en los bloques de construcción fundamentales de las interacciones multiagentes: aquellos que pueden ser compuestos, extendidos o refinados para definir tipos de interacciones organizativas o comunicativas más complejas. Su primer objetivo es llevar a cabo un análisis fundamentado de las interacciones multiagentes, partiendo de las características generales comúnmente atribuidas a la computación basada en agentes: autonomía, ubicuidad y socialidad [26]. Para abordar este problema, recurrimos a la noción de conector, propuesta dentro del campo de las arquitecturas de software [1, 17]. El resultado de este análisis será un modelo basado en conectores de interacciones multiagentes entre componentes sociales y situados autónomos, es decir, agentes, que intentan identificar su estructura esencial. Además, el artículo también proporciona a este modelo una semántica de ejecución formal que describe la dinámica de las interacciones multiagente (o sociales). La Semántica Operacional Estructural (SOS), una técnica común para especificar la <br>semántica operacional de los lenguajes de programación</br>, se utiliza con este propósito. El documento está estructurado de la siguiente manera: primero, se presentan las entidades principales y las relaciones que constituyen la estructura de las interacciones sociales. A continuación, la dinámica de las interacciones sociales mostrará cómo evolucionan estas entidades y relaciones. Por último, se discute el trabajo relevante en la literatura 889 978-81-904262-7-5 (RPS) c 2007 IFAAMAS con respecto a la propuesta, se abordan las limitaciones, y se describe el trabajo actual y futuro. ESTRUCTURA DE INTERACCIÓN SOCIAL Desde un punto de vista arquitectónico, las interacciones entre los componentes de software se materializan en conectores de software: entidades de primera clase definidas en función de los diferentes roles desempeñados por los componentes de software y los protocolos que regulan su comportamiento [1]. Los roles de un conector representan a sus participantes, como los roles de llamante y llamado de un conector RPC, o los roles de emisor y receptor en un conector de paso de mensajes. La operación de adjuntar vincula un componente al rol de un conector dado. El análisis de las interacciones sociales introducido en esta sección da lugar a un nuevo tipo de conector social. Refina el modelo genérico en varios aspectos, atendiendo a las características comúnmente atribuidas a la computación basada en agentes: • Según la característica de autonomía, podemos distinguir un primer tipo de participante (es decir, rol) en una interacción social, llamados agentes. Básicamente, los agentes son esos componentes de software que serán considerados autónomos dentro del alcance de la interacción. • Un segundo grupo de participantes, llamados recursos ambientales, pueden ser identificados a partir de la característica de ubicuidad. A diferencia de los agentes, los recursos representan aquellos componentes no autónomos cuyo estado puede ser controlado externamente por otros componentes (agentes o recursos) dentro de la interacción. Además, la participación de recursos en una interacción no es obligatoria.\nPor último, de acuerdo con la socialidad de los agentes, la especificación de los protocolos de conexión social, el pegamento que une a los agentes entre sí y con los recursos, se basará en conceptos normativos como permisos, obligaciones y empoderamientos [23]. Además de agentes, recursos y protocolos sociales, otros dos tipos de entidades son de gran relevancia en nuestro análisis de las interacciones sociales: las acciones, que representan la forma en que los agentes alteran el estado ambiental y social de la interacción; y los eventos, que representan los cambios en la interacción resultantes de la realización de acciones o la actividad de los recursos ambientales. En lo siguiente, describimos las entidades básicas involucradas en las interacciones sociales. Cada tipo de entidad T se especificará como un tipo de registro T l1: T1, . . . ln: Tn, posiblemente seguido por un número de invariantes, definiciones y las acciones que afectan su estado. Las instancias o valores v de un tipo de registro T se representarán como v = v1, . . . , vn : T. El tipo SetT representa una colección de valores extraídos del tipo T. El tipo QueueT representa una cola de valores v : T esperando ser procesados. El valor v en la expresión [v| ] : Queue[T] representa la cabeza de la cola. El tipo Enum {v1, . . . , vn}\n1\nNota que pensamos en la característica de autonomía desde una perspectiva relativa, en lugar de absoluta. Básicamente, esto significa que los componentes de software que cuentan como agentes en una interacción social pueden comportarse de manera no autónoma en otros contextos, por ejemplo, en sus interacciones a través de interfaces con usuarios humanos. Esta conceptualización de la agencia se asemeja a la forma en que se entienden los objetos en CORBA: como cualquier tipo de componente de software (C, Prolog, Cobol, etc.) adjunto a un ORB. representa un tipo de enumeración cuyos valores son v1, . . . , vn. Dado un valor v: T, el término vl se refiere al valor del campo l de un tipo de registro T. Dados algunos etiquetas l1, l2, ..., la expresión vl1, l2, ... es azúcar sintáctico para ((vl1) l2) . . .. El término especial nil se utilizará para representar la ausencia de un valor adecuado para un campo opcional, de modo que vl = nil será verdadero en esos casos y falso en caso contrario. El modelo formal será ilustrado con varios ejemplos extraídos del diseño de una organización virtual para ayudar en la gestión de cursos universitarios.  \nInteracciones Sociales Las interacciones sociales se considerarán como conectores compuestos [17], estructurados en términos de un árbol de subinteracciones anidadas. Consideremos una interacción que represente un curso universitario (por ejemplo, sobre estructuras de datos). Por un lado, esta interacción es en realidad una compleja, compuesta por interacciones de nivel inferior. Por ejemplo, dentro del alcance del curso, los agentes participarán en grupos de tareas de programación, conferencias, reuniones de tutoría, exámenes, etc. Los grupos de asignaciones, a su vez, pueden contener un número de entregas de asignaciones e interacciones de solicitudes de pruebas. Una solicitud de prueba también puede ser considerada como una interacción compleja, que en última instancia se descompone en las interacciones atómicas, o de nivel inferior, representadas por acciones comunicativas (por ejemplo, solicitud, acuerdo, rechazo, ...). Por otro lado, los cursos se imparten dentro del ámbito de un grado en particular (por ejemplo, informática), una interacción de nivel superior. Al ascender desde un grado hasta sus ancestros, encontramos su facultad, la universidad y, finalmente, la comunidad multiagente o sociedad de agentes. La comunidad es, por lo tanto, la interacción de nivel superior que subsume cualquier otro tipo de interacción multiagente. Los tipos de interacción organizativa y comunicativa identificados anteriormente claramente difieren en muchos aspectos. Sin embargo, podemos identificar cuatro componentes principales en todos ellos: los agentes participantes, los recursos que los agentes manipulan, el protocolo que regula las actividades de los agentes y el espacio de subinteracción. En consecuencia, podemos especificar el tipo I de interacciones sociales, abarcado por la meta-variable i, de la siguiente manera: I estado: SI, ini: A, mem: Conjunto A, env: Conjunto R, sub: Conjunto I, prot: P, ch: CH def.: (1) icontexto = i1 ⇔ i ∈ isub 1 inv.: (2) iini = nil ⇔ icontexto = nil act.: setUp, join, create, destroy donde los campos miembro y entorno representan a los agentes (A) y recursos locales (R) que participan en la interacción; el campo de sub-interacción, su conjunto de interacciones internas; y el campo de protocolo las reglas que rigen la interacción (P). El canal de eventos, que se describirá en la siguiente sección, permite el envío de eventos locales a interacciones externas. El contexto de alguna interacción se define como su super-interacción (def. 1), de modo que el contexto de la interacción de nivel superior es nulo. El tipo SI Enum {abierto, cerrando, cerrado} representa los posibles estados de ejecución de la interacción. Cualquier interacción, excepto la de nivel superior, se establece dentro del contexto de otra interacción por un agente iniciador. El iniciador es 2 En el contexto de esta aplicación, un mapeo uno a uno entre usuarios humanos y componentes de software adjuntos a la comunidad como agentes sería la elección correcta. 890 The Sixth Intl. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) es, por lo tanto, una característica obligatoria para cualquier interacción diferente a la comunidad (inv. 2). El ciclo de vida de la interacción comienza en el estado abierto. Sus conjuntos de participantes agentes y recursos, inicialmente vacíos, varían a medida que los agentes se unen y abandonan la interacción, y a medida que crean y destruyen recursos de su entorno local. Eventualmente, la interacción puede llegar a su fin (de acuerdo con las reglas del protocolo), o ser cerrada explícitamente por algún agente, deshabilitando prematuramente la actividad de sus participantes. El estado de cierre transitorio se describirá en la siguiente sección.\nLos componentes de los agentes se adhieren como agentes en interacciones sociales con el propósito de lograr algo. El propósito declarado por algún agente al unirse a una interacción deberá ser considerado como el objetivo institucional que pretende satisfacer dentro de ese contexto. Los tipos de agentes que participan en una interacción dada se identifican principalmente por sus propósitos. Por ejemplo, los estudiantes son aquellos agentes que participan en un curso y pretenden obtener un certificado en el tema del curso. Otros miembros del curso incluyen profesores y asistentes de enseñanza. El tipo A de agentes, abarcado por la meta-variable a, se define de la siguiente manera: Un estado: SA, jugador: A, propósito: F, act: Cola ACT, ev: Cola E, obl: Conjunto O def.: (3) acontexto = i ⇔ a ∈ imem (4) a1 ∈ aroles ⇔ aplayer 1 = a (5) i ∈ apartIn ⇔ a1 ∈ imem ∧ a1 ∈ aroles act.: ver donde el propósito está representado como una fórmula booleana bien formada, de un tipo genérico F, que evalúa a verdadero si el propósito se cumple y falso en caso contrario. El contexto de algún agente se define como la interacción en la que participa (def. 3). El tipo SA Enum {playing, leaving, succ, unsuc} representa el estado de ejecución del agente. Su ciclo de vida comienza en el estado de juego cuando su agente jugador se une a la interacción, o algún componente de software se adjunta como agente al sistema multiagente (en este último caso, el valor del jugador es nulo). Los roles derivados y las características de las partes representan los roles desempeñados por el agente y los contextos en los que se desempeñan estos roles (def. 4, 5). Un agente puede desempeñar roles en interacciones dentro o fuera del alcance de su contexto. Por ejemplo, los estudiantes de un curso son representados por agentes estudiantiles pertenecientes al grado (de pregrado), mientras que los profesores pueden ser representados por docentes de un departamento dado y el rol de asistente puede ser representado por estudiantes de un grado de doctorado (tanto el departamento como los grados de doctorado se modelan como sub-interacciones de la facultad). Los componentes normalmente intentarán realizar diferentes acciones (por ejemplo, configurar sub-interacciones) para satisfacer sus propósitos dentro de alguna interacción. Además, los componentes deben estar al tanto del estado actual de la interacción, para que también sean capaces de observar ciertos eventos de la interacción. Tanto la visibilidad de la interacción\nPor lo tanto, puede o no corresponder a los objetivos internos reales o intenciones del componente.\nLas variables libres en los antecedentes/consecuentes de las implicaciones se entenderán como cuantificadas universalmente/existencialmente.\ny los intentos de los miembros, están sujetos a las reglas que rigen la interacción. Los campos de intentos y eventos de la estructura del agente representan las colas de intentos para ejecutar algunas acciones (ACT), y los eventos (E) recibidos por el agente que aún no han sido observados. Un agente puede actualizar su cola de eventos al observar el estado de alguna entidad de la comunidad. El último campo de la estructura representa las obligaciones (O) de los agentes, que se describirán más adelante. Finalmente, la participación de algún agente en la interacción habrá terminado. Esto puede ocurrir cuando se cumplen ciertas condiciones (especificadas por las reglas del protocolo), o cuando el agente toma la decisión explícita de abandonar la interacción. En cualquier caso, el estado final del agente será exitoso si su propósito fue satisfecho; de lo contrario, será fallido. El estado de salida transitorio se describirá en la siguiente sección.\nRecursos son componentes de software que pueden representar diferentes tipos de entidades informativas o computacionales no autónomas. Por ejemplo, los objetivos, temas, tareas, calificaciones y exámenes son diferentes tipos de recursos informativos creados por los profesores y asistentes en el contexto de la interacción del curso. Los estudiantes también pueden crear programas para cumplir con los requisitos de alguna tarea. Otros tipos de recursos computacionales puestos a disposición de los estudiantes por los profesores incluyen compiladores e intérpretes. El tipo R de recursos, representado por la meta-variable r, puede ser especificado por el siguiente tipo de registro: R cr: A, owners: Conjunto A, op: Conjunto OP def.: (6) rcontext = i ⇔ r ∈ ienv act.: tomar, compartir, dar, invocar Esencialmente, los recursos pueden ser considerados como objetos desplegados en un entorno social. Esto significa que los recursos son creados, accedidos y manipulados por agentes en un contexto de interacción social (def. 6), de acuerdo con las reglas especificadas por su protocolo. El creador de la característica obligatoria representa al agente que creó este recurso. Además, los recursos pueden tener propietarios. La relación de propiedad entre los miembros y los recursos se considera como un dispositivo normativo destinado a la simplificación de las reglas de protocolo que rigen la interacción de los agentes y el entorno. Los miembros pueden adquirir la propiedad de algún recurso tomando posesión de él, y otorgar la propiedad a otros agentes al dar o compartir sus propiedades. Por ejemplo, la propiedad de los programas puede ser compartida por varios estudiantes si la tarea puede ser realizada por grupos de dos o más estudiantes. La característica de las últimas operaciones representa la interfaz del recurso, que consiste en un conjunto de operaciones. Un recurso está estructurado en torno a varias operaciones públicas que los participantes pueden invocar, de acuerdo con las reglas especificadas por el protocolo de interacciones. El conjunto de operaciones de un recurso conforma su interfaz.\nLos protocolos de cualquier interacción están compuestos por las reglas que rigen su estado general y dinámica. La presente especificación abstrae la formalidad particular utilizada para especificar estas reglas, y se centra en cambio en varios requisitos relacionados con la estructura y la interfaz de los protocolos. En consecuencia, el tipo P de protocolos, abarcado por metaThe Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 891 variable p, se define de la siguiente manera: P emp: A × ACT → Boolean, perm: A × ACT → Boolean, obl: → Conjunto (A × Conjunto O × Conjunto E), monitor: E → Conjunto A, finish: → Boolean def.: (7) pcontext = i ⇔ p = iprot inv.: (8) pfinish() ∧ s ∈ pcontext,sub ⇒ sprot,finish() (9) pfinish() ∧ a ∈ pcontext,mem ⇒ pover(a) (10) pover(a) ∧ ai ∈ aroles ⇒ acontext,prot,over i (ai) (11) αadd ∪ {a} ⊆ pmonitor(a, α, ) act.: Cerrar, Salir Exigimos de los protocolos cuatro tipos principales de funciones. En primer lugar, los protocolos deben incluir reglas para identificar los empoderamientos y permisos de cualquier agente que intente alterar el estado de la interacción (por ejemplo, sus miembros, el entorno, etc.) a través de la ejecución de alguna acción (por ejemplo, unirse, crear, etc.). Los empoderamientos serán considerados como las capacidades institucionales que algún agente posee para satisfacer su propósito. Las reglas correspondientes, encapsuladas por el campo de función habilitado, permitirán determinar si algún agente es capaz de realizar una acción dada sobre la interacción. Los empoderamientos solo se pueden ejercer bajo ciertas circunstancias, que especifiquen los permisos. Las reglas de permiso permitirán determinar si el intento de un agente autorizado de realizar alguna acción en particular se cumple o no (cf. campo permitido). Por ejemplo, el protocolo de los cursos especifica que los agentes autorizados para unirse a la interacción como estudiantes son aquellos estudiantes del grado que han pagado la tarifa establecida para la asignatura del curso, y que poseen los certificados correspondientes a sus asignaturas previas. Las reglas de permiso, a su vez, especifican que esos estudiantes solo pueden unirse al curso en la etapa de admisión. Por lo tanto, incluso si algún estudiante ha pagado la tarifa, el intento de unirse al curso fallará si el curso no ha ingresado a la etapa correspondiente. En segundo lugar, los protocolos deben permitir determinar las obligaciones de los agentes hacia la interacción. Las obligaciones representan un dispositivo normativo de cumplimiento social, totalmente compatible con la autonomía de los agentes, utilizado para sesgar su comportamiento en una dirección determinada. Estos tipos de reglas permitirán determinar si algún agente debe realizar una acción de un tipo dado, así como si alguna obligación fue cumplida, violada o necesita ser revocada. La función obligaciones de la estructura del protocolo identifica así a los agentes cuyo conjunto de obligaciones debe ser actualizado. Además, devuelve para cada agente una colección de eventos que representan los cambios en el conjunto de obligaciones. Por ejemplo, el protocolo de los cursos establece que los miembros de los departamentos deben unirse al curso como docentes cada vez que se les asigne la materia del curso. En tercer lugar, el protocolo permitirá especificar reglas de monitoreo para los diferentes eventos que se originen dentro de la interacción. Las reglas correspondientes establecerán el conjunto de agentes que deben ser informados sobre algún evento. Por ejemplo, esta func5. La formalización asume que los protocolos funciones reciben implícitamente como entrada la interacción que se está regulando. La relación haPagadoCuota entre los estudiantes (de grado) y los recursos de la materia está representada por un campo adicional, dependiente de la aplicación, de la estructura del agente para este tipo de roles. De manera similar, la etapa de admisión es un campo booleano adicional de la estructura para las interacciones escolares. Los tipos genéricos I, A, R y P son por lo tanto ampliables. cionalidad es aprovechada por los profesores para monitorear la inscripción de los estudiantes en el curso. Por último, el protocolo permitirá controlar el estado de la interacción, así como los estados de sus miembros. Las reglas correspondientes identifican las condiciones bajo las cuales alguna interacción se dará por finalizada automáticamente, y si la participación de algún agente miembro se dará por terminada automáticamente. Por lo tanto, la función field finish devuelve true si la interacción regulada debe finalizar su ejecución. Si esto sucede, un conjunto bien definido de protocolos debe asegurar que sus sub-interacciones y miembros también se completen (inv. 8,9). De manera similar, la función \"over\" devuelve verdadero si la participación del miembro especificado debe finalizar. Los protocolos bien formados deben garantizar la consistencia entre estas funciones en los roles de juego (inv. 10)7. Por ejemplo, el protocolo de los cursos establece que la participación de los estudiantes finaliza cuando obtienen la propiedad del certificado del curso o se agotan las oportunidades de obtenerlo. También establece que el curso debe finalizarse cuando haya pasado la etapa de admisión y todos los estudiantes hayan completado su participación. 3. DINÁMICA DE INTERACCIÓN SOCIAL La dinámica de la comunidad de múltiples agentes está influenciada por las acciones externas ejecutadas por los componentes de software y los protocolos que rigen sus interacciones. Esta sección se centra en la dinámica resultante de un tipo particular de acción externa: el intento de algún componente, unido a la comunidad como agente, de ejecutar una acción dada (interna). La descripción de otras acciones externas relacionadas con agentes (por ejemplo, observar los eventos de su cola de eventos, entrar o salir de la comunidad) y recursos (por ejemplo, un recurso de temporizador puede señalar el paso del tiempo) será omitida. El procesamiento de un intento puede dar lugar a cambios en el alcance de la interacción objetivo, como la instanciación de nuevos participantes (agentes o recursos) o el establecimiento de nuevas sub-interacciones. Estos eventos resultantes pueden causar más cambios en el estado de otras interacciones (incluida la objetivo), es decir, en su estado de ejecución, así como en el estado de ejecución, obligaciones y visibilidad de sus miembros. Esta sección también describirá la forma en que estos eventos son procesados. La dinámica resultante descrita abajo permite que las acciones y eventos correspondientes a diferentes agentes e interacciones se procesen simultáneamente. Debido a la falta de espacio, solo incluimos algunas de las reglas operativas que formalizan la semántica de ejecución. 3.1 Procesamiento de intentos Un intento se define por la estructura AT T perf: A, act: ACT, donde el intérprete representa al agente a cargo de ejecutar la acción especificada. Esta acción tiene la intención de alterar el estado de alguna interacción objetivo (posiblemente, el propio contexto de los ejecutantes) y notificar a una colección de destinatarios sobre los cambios resultantes de una ejecución exitosa. En consecuencia, el tipo ACT de acciones, abarcado por la meta-variable α, se especifica de la siguiente manera: ACT estado: SACT, objetivo: I, añadir: Conjunto A def.: (12) αperf = a ⇔ α ∈ aatt. Las acciones de cerrar y abandonar actualizan los campos de función de finalización y de finalización, como se explica en la siguiente sección. Acciones adicionales, como permitir, prohibir, habilitar, etc., para actualizar otros campos de protocolos aún deben ser identificadas en trabajos futuros. 892 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) donde: el ejecutante se define formalmente como el agente que almacena la acción en su cola de intentos, y el campo de estado representa la fase actual de procesamiento. Este proceso pasa por cuatro fases principales, según lo especificado por el tipo de enumeración SACT Enum {emp, perm, exec}: verificación de empoderamiento, verificación de permisos y ejecución de acciones, descritas a continuación. 3.1.1 Verificación de empoderamiento La postcondición de un intento consiste en insertar la acción en la cola de intentos del ejecutante especificado. Como especifica la regla 1, esto solo será posible si el intérprete tiene la autoridad para llevar a cabo esa acción de acuerdo con las reglas que rigen el estado de la interacción objetivo. Si esta condición no se cumple, el intento simplemente será ignorado. Además, el agente intérprete debe estar en estado de reproducción (esta precondición también es necesaria para cualquier regla relacionada con el procesamiento de intentos). Si se cumplen estas precondiciones, la regla se activa y el procesamiento de la acción continúa en la etapa de verificación de permisos. Por ejemplo, cuando el componente de software adjunto como estudiante en un programa intenta unirse como estudiante al curso en el que se imparte alguna asignatura, se verifican las reglas de empoderamiento de la interacción del curso. Si el estudiante ha aprobado las asignaturas prerrequisito, la acción de unirse se insertará en su cola de intentos y se considerará para su ejecución. αtarget,prot,emp(a, α) a = playing, , , qACT , , a,α :AT T −→ playing, , , qACT , , (1) Donde: (α )estado = perm (qACT ) = insert(α , qACT ) 3.1.2 Verificación de permisos El procesamiento de la acción se reanuda cuando las posibles acciones anteriores en la cola de intentos de los ejecutores se procesan por completo y se eliminan de la cola. Además, no debe haber eventos pendientes por procesar en la interacción, ya que estos eventos pueden hacer que el miembro o la interacción se finalicen (como se explicará brevemente en la próxima subsección). Si se cumplen estas condiciones, se verifican los permisos para ejecutar la acción indicada (y notificar a los destinatarios especificados) (por ejemplo, se verificará si el estudiante pagó la tarifa del curso correspondiente). Si el protocolo de la interacción objetivo otorga permiso, el procesamiento del intento se traslada a la etapa de ejecución de la acción (regla 2). De lo contrario, la acción se descarta y se elimina de la cola. A diferencia de los intentos sin autorización, uno prohibido causará que se genere un evento y se transfiera al canal de eventos para su procesamiento adicional. αestado = perm ∧ acontexto,ch,in,ev = ∅ ∧ αobjetivo,prot,perm(a, α) a = jugando, , , [α| ], , −→ jugando, , , [α | ], , (2) Donde: (α )estado = ejec 8 Las etiquetas de las instancias de registro se omiten para permitir especificaciones más compactas. Además, tenga en cuenta que las actualizaciones de registros en las cláusulas WHERE solo afectan a los campos especificados. 3.1.3 Ejecución de acciones Las transiciones disparadas en esta etapa se clasifican según los diferentes tipos de acciones a ejecutar. Los efectos previstos de algunas acciones pueden lograrse directamente en un solo paso, mientras que otras requerirán un enfoque indirecto y posiblemente varios pasos de ejecución. Las acciones del primer tipo son constructivas, como configurar y unir. El segundo grupo de acciones incluye aquellas, como cerrar y salir, cuyos efectos se logran de forma indirecta mediante la actualización del protocolo de interacción. Como ejemplo de acción constructiva, consideremos la ejecución de una acción de configuración, cuyo tipo se define de la siguiente manera: SetUp ACT · new : I inv. : (13) αnew,mem = αnew,res = αnew,sub = ∅ (14) αnew,state = open donde el campo new representa la nueva interacción a iniciar. Sus conjuntos de participantes (agentes y recursos) y sub-interacciones deben estar vacíos (inv. 13) y su estado debe ser abierto (inv. 14). El establecimiento de la nueva interacción puede afectar así su protocolo y campos dependientes de la aplicación posible (por ejemplo, el tema de una interacción de curso). Según la regla 3, el resultado de la ejecución es triple: en primer lugar, se actualiza la cola de intentos de los intérpretes para que la acción en ejecución sea eliminada; en segundo lugar, la nueva interacción se agrega al conjunto de objetivos de sub-interacciones (además, su campo iniciador se establece en el agente intérprete); por último, el evento que representa este cambio (que incluye una descripción del cambio, el agente que lo causó y la acción realizada) se inserta en el puerto de salida del canal de eventos de los objetivos. αestado = ejecución ∧ α : Configuración ∧ αnueva = i a = jugando, , , [α|qACT ], , −→ jugando, , , qACT , , αobjetivo = abierto, , , , , sI , c −→ abierto, , , , , sI ∪ i , c (3) Donde: (i) ini = a (c) out,ev = insertar(a, α, sub(αobjetivo, i), cout,ev) Consideremos ahora el caso de una acción de cierre. Esta acción representa un intento por parte del intérprete de forzar alguna interacción para finalizar, evitando así las reglas actuales del protocolo (aquellas relacionadas con la función de finalización). La forma de lograr este efecto es provocar una actualización en el protocolo para que la función de finalización devuelva verdadero después. En consecuencia, podemos especificar este tipo de acción de la siguiente manera: Cerrar ACT · upd: (→ Bool) → (→ Bool) inv.: (15) αtarget, estado = abierto (16) αtarget, contexto = nulo (17) αupd(αtarget, prot, final)() donde el campo objetivo heredado representa la interacción a cerrar (que debe estar abierta y ser diferente a la interacción superior, según las invariantes 15 y 16) y el nuevo tipo resultante consiste en los campos del registro ACT extendidos con un campo adicional nuevo. Esta estrategia también se sigue en la definición de leave y también puede ser utilizada en la definición de otros tipos de acciones como fire, permitir, prohibir, etc. El Sexto Internacional. La actualización del campo 893 de la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) representa una función de orden superior adecuada para actualizar el protocolo de objetivos (inv. 17). La transición que modela la ejecución de esta acción, especificada por la regla 4, define dos efectos en la interacción objetivo: su protocolo se actualiza y el evento que representa este cambio se inserta en su puerto de salida. Este evento en realidad desencadenará el proceso de cierre de la interacción como se describe en la siguiente subsección. αestado = ejecución ∧ α: Cerrar a = jugando, , , [α|qACT], , −→ jugando, , , qACT, , αobjetivo = abrir, , , , , p, c −→ abrir, , , , , p, c (4) Donde: (p)fin = αupd(pfin) (c)salida, ev = insertar(a, α, fin(αobjetivo), csalida, ev) 3.2 Procesamiento de Eventos El procesamiento de eventos está encapsulado en los canales de eventos de las interacciones. Los canales, abarcados por la meta-variable c, están definidos por dos puertos de entrada y salida, de acuerdo con la siguiente definición: CH out: OutP, in: InP inv.: (18) ccontext ∈ cout, disp( , , finish(ccontext) ) (19) ccontext ∈ cout, disp( , , over(a) ) (20) ccontext, sub ⊆ cout, disp(closing(ccontext)) (21) apartsIn ⊆ cout, disp(leaving(a)) (22) ccontext ∈ cout, disp(closed(i)) (23) {ccontext, aplayer, context} ⊆ cout, disp(left(a)) OutP ev: Cola E, disp: E → Conjunto I, int: Conjunto I, ag: Conjunto A InP ev: Cola E, etapa: Enum {int, mem, obl}, ag: Conjunto A El puerto de salida almacena y procesa los eventos originados dentro del alcance de la interacción de los canales. Su primer propósito es enviar los eventos locales a los agentes identificados por la función de monitoreo de protocolos. Además, dado que estos eventos pueden influir en los resultados del acabado, sobre y funciones de obligación de ciertos protocolos, también serán enviados a los puertos de entrada de las interacciones identificadas a través de una función de despacho, cuyos invariancia se explicarán más adelante. Por lo tanto, los puertos de entrada sirven como un mecanismo de coordinación que activa la reevaluación de las funciones anteriores cada vez que se recibe algún evento. En consecuencia, el procesamiento de algún evento pasa por cuatro etapas principales: despacho de eventos, actualización del estado de interacción, actualización del estado de los miembros y actualización de obligaciones. El primero tiene lugar en el puerto de salida de la interacción en la que se originó el evento, mientras que los otros se ejecutan en hilos de control separados asociados a los puertos de entrada de las interacciones a las que se envió el evento. 3.2.1 Despacho de eventos El procesamiento de algún evento almacenado en el puerto de salida se activa cuando todos sus eventos anteriores han sido despachados. Como primer paso, los campos auxiliares int y ag se inicializan. Alternativamente, podríamos haber asumido que las interacciones están completamente conscientes de cualquier cambio en la comunidad de agentes múltiples. En este escenario, las interacciones se activarían por sí mismas sin necesidad de ninguna notificación explícita. Por el contrario, nos adherimos a la suposición más realista de conciencia limitada, con los valores devueltos de las funciones de despacho y monitoreo de protocolos, respectivamente (regla 5). Entonces, reglas adicionales simplemente iteran sobre estas colecciones hasta que todos los agentes e interacciones hayan sido notificados (es decir, ambos conjuntos estén vacíos). Por último, el evento se elimina de la cola y los campos auxiliares se restablecen a nulo. La función de despacho deberá identificar el conjunto de interacciones (posiblemente vacío) que pueden verse afectadas por el evento (que puede incluir la interacción de los canales en sí mismos). Por ejemplo, según la regla de finalización de los cursos universitarios mencionada en la última sección, el evento que representa el final de la etapa de admisión, originado dentro del ámbito de la interacción escolar, se enviará a todos los cursos de los grados escolares. En cuanto a la función de monitoreo, según el invariante 11 de los protocolos, si el evento se genera como resultado de una acción realizada, los agentes a ser notificados incluirán al ejecutante y a los destinatarios de esa acción. Por lo tanto, según la regla de monitoreo de cursos universitarios, si un estudiante de cierto grado se une a un curso específico y especifica a un colega como destinatario de esa acción, los profesores del curso y él mismo también serán notificados de la ejecución exitosa. ccontext, estado s = abierto ∧ ccontext, prot, monitoreo s = mon cs = [e| ], d, nil, nil , −→ [e| ], , d(e), mon(e) , (5) 3.2.2 Actualización del estado de interacción La actividad del puerto de entrada se desencadena cuando se recibe un nuevo evento. Independientemente del tipo de evento entrante, la primera acción de procesamiento es verificar si la interacción de los canales debe finalizarse. Por lo tanto, el envío del evento de finalización resultante de una acción de cierre (inv. 18) sirve como un desencadenante del procedimiento de cierre. Si la interacción no ha finalizado, el campo de etapa del puerto de entrada se establece en la etapa de actualización del estado del miembro y el campo ag auxiliar se inicializa con los miembros de la interacción. De lo contrario, podemos considerar dos posibles escenarios. En el primero, la interacción no tiene miembros ni sub-interacciones. En este caso, la interacción se puede cerrar inmediatamente. Como muestra la regla 6, la interacción se cierra, se elimina del conjunto de contextos de sub-interacciones y se inserta un evento cerrado en su canal de salida. Según el invariante 22, este evento será posteriormente insertado en su canal de entrada para permitir un tratamiento adicional. cin,ev 1 = ∅ ∧ cin,stage 1 = int ∧ pfinish() , , , , {i} ∪ sI , , c −→ , , , , sI , , c i = , , ∅, , ∅, p, c1 −→ cerrado, , , , , , (6) Donde: (c )out,ev = insert(cerrado(i), cout,ev ) En el segundo escenario, la interacción tiene algún miembro o sub-interacción. En este caso, es necesario realizar una limpieza antes de desechar la interacción (por ejemplo, si finaliza el período de admisión y ningún estudiante se ha matriculado en el curso, los profesores deben finalizar antes de terminar el curso en sí). Como muestra la regla 7, la interacción se mueve al estado de cierre transitorio y se inserta un evento correspondiente en el puerto de salida. Según el invariante 20, el evento de cierre se enviará a cada subinteracción para activar su procedimiento de cierre (garantizado por el invariante 8). Además, esto está determinado esencialmente por las reglas del protocolo de estas interacciones. La forma en que se inicializa y actualiza la función de despacho está fuera del alcance de este documento. 894 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el escenario y los campos agrícolas se inicializan correctamente para que el proceso continúe en la siguiente etapa de actualización del estado del miembro. Esta etapa iniciará aún más el proceso de salida de los miembros (según el invariante 9). cin,ev = ∅ ∧ cin,stage = int ∧ pfinish() ∧ (sA = ∅ ∨ sI = ∅) i = abierto, , sA, , sI , p, c −→ cerrando, , sA, , sI , p, c (7) Donde: (c )out,ev = insert(closing(i), cout,ev ) (c )in,stage = mem (c )in,ag = sA Eventualmente, cada miembro abandonará la interacción y cada sub-interacción será cerrada. Los eventos correspondientes serán recibidos por la interacción (de acuerdo con los invariantes 23 y 22) para que se cumplan las condiciones del primer escenario. Actualización del estado del miembro 3.2.3. En esta etapa simplemente se itera sobre los miembros de la interacción para verificar si deben finalizarse de acuerdo con los protocolos sobre la función. Cuando todos los miembros hayan sido verificados, el campo de etapa se establecerá en la siguiente etapa de actualización de obligación y el campo ag auxiliar se inicializará con los agentes identificados por la función de actualización de obligación de los protocolos. Si algún miembro tiene que finalizar su participación en la interacción y no está desempeñando ningún papel, será abandonado inmediatamente (exitosamente o sin éxito, según la satisfacción de su propósito). El evento correspondiente será reenviado a su interacción y a la interacción de su agente jugador para tener en cuenta futuros cambios (inv. 23). De lo contrario, el miembro entra en el estado de salida transitorio, impidiendo así cualquier acción de rendimiento. Luego, espera la finalización de los procedimientos de salida de los roles desempeñados, desencadenados por el envío adecuado del evento de salida (inv. 21). Actualización de obligaciones En esta etapa, las obligaciones de los agentes (no necesariamente miembros de la interacción) hacia la interacción se actualizan en consecuencia. Cuando todos los agentes identificados hayan sido actualizados, el evento se elimina de la cola de entrada y el campo de etapa vuelve a establecerse en la actualización del estado de interacción. Por ejemplo, cuando una interacción de curso recibe un evento que representa la asignación de algún miembro del departamento a su materia, se crea una obligación de unirse al curso como profesor para ese miembro. Además, el evento que representa este cambio se agrega al canal de salida de la interacción del departamento. 4. DISCUSIÓN Este artículo ha intentado exponer un posible núcleo semántico subyacente al amplio espectro de tipos de interacción entre componentes de software autónomos, sociales y situados. En el ámbito de las arquitecturas de software, este núcleo se ha formalizado como un modelo operativo de conectores sociales, destinado a describir tanto la estructura básica como la dinámica de las interacciones multiagente, desde la más grande (la sociedad de agentes en sí misma) hasta las más pequeñas (acciones comunicativas). Por lo tanto, las interacciones de alto nivel pueden representar el tipo de agente-web buscado por iniciativas a gran escala como la de Agentcities/openNet [25]. Las interacciones a gran escala, modelando complejos conjuntos de interacciones de agentes como los representados por e-instituciones u organizaciones virtuales, también pueden ser conceptualizadas como tipos particulares de interacciones sociales de primer nivel. Los últimos niveles del árbol de interacción pueden representar interacciones multiagentes a pequeña escala, como las representadas por protocolos de interacción [11], juegos de diálogo [16] o escenas [2]. Finalmente, las interacciones a nivel inferior pueden representar acciones comunicativas. Desde esta perspectiva, los tipos de miembros de una CA incluyen al hablante y posiblemente muchos oyentes. El propósito del hablante coincide con el propósito ilocucionario del CA [22], mientras que el propósito de cualquier oyente es declarar que (en realidad, el componente de software) procesó con éxito el significado del CA. El análisis de las interacciones sociales presentado en este documento se basa en propuestas actuales de la literatura en varios aspectos generales, como el carácter institucional y organizativo de los sistemas multiagentes [2, 26, 10, 7] y la perspectiva normativa sobre los protocolos multiagentes [12, 23, 20]. Estas propuestas, así como otras que se centran en abstracciones relevantes como las relaciones de poder, contratos, mecanismos de confianza y reputación en entornos organizacionales, etc., podrían ser explotadas aún más para caracterizar de manera más precisa el carácter organizacional de algunas interacciones multiagentes. De manera similar, la conceptualización de las acciones comunicativas como interacciones atómicas también puede beneficiarse de la semántica pública de las acciones comunicativas, como la introducida en [3]. Por último, el modelo abstracto de protocolos puede ser refinado teniendo en cuenta los modelos operativos existentes de normas [12, 6]. Estos análisis darán como resultado nuevas abstracciones organizativas y comunicativas obtenidas a través de un refinamiento y/o extensión del modelo general de interacciones sociales. Por lo tanto, el modelo propuesto no tiene la intención de capturar cada característica organizativa o comunicativa de las interacciones multiagentes, sino de revelar sus raíces en mecanismos básicos de interacción. A su vez, esto permitiría la explotación de formalismos comunes, especialmente en lo que respecta a los protocolos. A diferencia del desarrollo de agentes individuales, que ha sido ampliamente beneficiado por el diseño de varios lenguajes de programación de agentes [4], las características sociales de los sistemas multiagente se implementan principalmente en términos de modelado visual [8, 18] y un conjunto fijo de abstracciones de interacción. Sostenemos que el campo actual de la programación de sistemas multiagente podría beneficiarse enormemente de lenguajes de programación multiagente que permitan a los programadores adaptarse a un conjunto abierto de mecanismos de interacción. El modelo de interacciones sociales presentado en este documento está destinado a ser la máquina abstracta de un lenguaje de este tipo. Esta máquina abstracta sería independiente de arquitecturas de agentes y lenguajes particulares (es decir, los componentes de software pueden programarse en un lenguaje BDI como Jason [5] o en un lenguaje no orientado a agentes). Además de las semánticas de ejecución presentadas, el trabajo actual y futuro tiene como objetivo la especificación del sistema de tipos [19] que permite programar la máquina abstracta, la especificación de las sintaxis superficiales correspondientes (tanto textuales como visuales) y el diseño e implementación de una máquina virtual sobre tecnologías de middleware existentes como plataformas FIPA o servicios web. También planeamos estudiar refinamientos y limitaciones particulares del modelo propuesto, especialmente en lo que respecta al despacho de eventos, semántica. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 895 de obligaciones, actualizaciones dinámicas de protocolos y formalismos de reglas. En este último aspecto, planeamos investigar el uso de la Programación de Conjuntos de Respuestas para especificar las reglas de los protocolos, prestando atención al papel que la incompletitud (las reglas pueden especificar solo condiciones necesarias o suficientes, por ejemplo), la negación explícita (por ejemplo, prohibiciones) y los valores por defecto juegan en este dominio. 5. AGRADECIMIENTOS Los autores agradecen a los revisores anónimos por sus comentarios y sugerencias. Investigación patrocinada por el Ministerio de Ciencia y Educación de España (MEC), proyecto TIN200615455-C03-03. REFERENCIAS [1] R. Allen y D. Garlan. Una Base Formal para la Conexión Arquitectónica. ACM Transactions on Software Engineering and Methodology, 6(3):213-249, junio de 1997. [2] J. L. Arcos, M. Esteva, P. Noriega, J. A. Rodríguez y C. Sierra. Ingeniería de entornos abiertos con instituciones electrónicas. Revista sobre Aplicaciones de la Inteligencia Artificial en Ingeniería, 18(2):191-204, 2005. [3] G. Boella, R. Damiano, J. Hulstijn y L. W. N. van der Torre. Semántica basada en roles para la comunicación de agentes: incrustación de la semántica de actitudes mentales y compromisos sociales. En AAMAS, páginas 688-690, 2006. [4] R. H. Bordini, L. Braubach, M. Dastani, A. E. F. Seghrouchni, J. J. G. Sanz, J. Leite, G. OHare, A. Pokahr y A. Ricci. Una encuesta de lenguajes de programación y plataformas para sistemas multiagente. Informatica, 30:33-44, 2006. [5] R. H. Bordini, J. F. H¨ubner, and R. Vieira. Jason y el vellocino de oro de la programación orientada a agentes. En R. H. Bordini, D. M., J. Dix y A. El Fallah Seghrouchni, editores, Programación Multiagente: Lenguajes, Plataformas y Aplicaciones, capítulo 1. Springer-Verlag, 2005. [6] O. Cliffe, M. D. Vos y J. A. Padget. Especificación y análisis de instituciones sociales basadas en agentes utilizando programación de conjuntos de respuestas. En EUMAS, páginas 476-477, 2005. [7] V. Dignum, J. Vázquez-Salceda y F. Dignum. Omni: Introduciendo estructura social, normas y ontologías en organizaciones de agentes. En R. Bordini, M. Dastani, J. Dix y A. Seghrouchni, editores, Programación de Sistemas Multiagente Segundo Taller Internacional ProMAS 2004, volumen 3346 de LNAI, páginas 181-198. Springer, 2005. [8] M. Esteva, D. de la Cruz y C. Sierra. ISLANDER: un editor de instituciones electrónicas. En M. Gini, T. Ishida, C. Castelfranchi y W. L. Johnson, editores, Actas de la Primera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS02), páginas 1045-1052. ACM Press, julio de 2002. [9] M. Esteva, B. Rosell, J. A. Rodríguez-Aguilar y J. L. Arcos. AMELI: Un middleware basado en agentes para instituciones electrónicas. En Actas de la Tercera Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, volumen 1, páginas 236-243, 2004. [10] J. Ferber, O. Gutknecht y F. Michel. De agentes a organizaciones: Una perspectiva organizacional de los sistemas multiagente. En AOSE, páginas 214-230, 2003. [11] Fundación para Agentes Físicos Inteligentes. Especificación de la Biblioteca de Protocolos de Interacción FIPA. http://www.fipa.org/repository/ips.html, 2003. [12] A. García-Camino, J. A. Rodríguez-Aguilar, C. Sierra y W. Vasconcelos. Programación orientada a normas de instituciones electrónicas. En AAMAS, páginas 670-672, 2006. [13] O. Gutknecht y J. Ferber. La arquitectura de la plataforma de agentes MadKit. Notas de conferencia en Ciencias de la Computación, 1887:48-55, 2001. [14] JADE. La página de inicio del proyecto JADE. http://jade.cselt.it, 2005. [15] M. Luck, P. McBurney, O. Shehory y S. Willmott. Tecnología de Agentes: Computación como Interacción - Una Hoja de Ruta para la Computación Basada en Agentes. AgentLink III, 2005. [16] P. McBurney and S. Parsons. Un marco formal para diálogos entre agentes. En J. P. M¨uller, E. Andre, S. Sen y C. Frasson, editores, Actas de la Quinta Conferencia Internacional sobre Agentes Autónomos, páginas 178-179, Montreal, Canadá, mayo de 2001. ACM Press. [17] N. R. Mehta, N. Medvidovic y S. Phadke. Hacia una taxonomía de conectores de software. En Actas de la 22ª Conferencia Internacional sobre Ingeniería de Software, páginas 178-187. ACM Press, junio de 2000. [18] J. Pavón y J. Gómez-Sanz. Ingeniería de software orientada a agentes con Ingenias. En V. Marik, J. Muller y M. Pechoucek, editores, Actas de la 3ra Conferencia Internacional de Sistemas Multiagente de Europa Central y del Este. Springer Verlag, 2003. [19] B. C. Pierce. Tipos y Lenguajes de Programación. The MIT Press, Cambridge, MA, 2002. \n[20] J. Pitt, L. Kamara, M. Sergot, and A. Artikis. Votación en sistemas multiagente. 27 de febrero de 2006.\n[21] G. Plotkin. Un enfoque estructural para la semántica operacional. Informe técnico DAIMI FN-19, Universidad de Aarhus, septiembre de 1981. [22] J. Searle. Actos de habla. Cambridge University Press, 1969. [23] M. Sergot. Una teoría computacional de posiciones normativas. ACM Transactions on Computational Logic, 2(4):581-622, Oct. 2001. [24] M. P. Singh. Abstracciones basadas en agentes para el desarrollo de software. En F. Bergenti, M.-P. Gleizes y F. Zambonelli, editores, Metodologías e Ingeniería de Software para Sistemas de Agentes, capítulo 1, páginas 5-18. Kluwer, 2004. [25] S. Willmot y otros. Agentcities / opennet testbed. http://x-opennet.net, 2004. [26] F. Zambonelli, N. R. Jennings, and M. Wooldridge. Desarrollo de sistemas multiagente: La metodología Gaia. ACM Transactions on Software Engineering and Methodology, 12(3):317-370, julio de 2003. 896 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}