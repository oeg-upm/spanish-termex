{
    "id": "I-20",
    "original_text": "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research. However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics. The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game. In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game. Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex. The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network. We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete. We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices. Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1. INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications. There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus. Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15]. What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)? What is the complexity of the process? Can complexity be used to guard against unwanted phenomena? Does complexity of computation prevent realistic implementation of a technique? The practical applications of voting among automated agents are already widespread. Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting. Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7]. In fact, to see the generality of the (automated) voting scenario, consider modern web searching. One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this). In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices. A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group. The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game. We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game. In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow. We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete. We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent. There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points. The paper proceeds as follows. In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game. In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case. In Section 5 we consider a restricted case of the network flow game, and present results. In Section 6 we discuss related work, and we conclude in Section 7. 2. TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}). We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0. We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}. An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0. A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game. One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game. Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1]. This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system. However, it can also easily be applied to any simple coalitional game. The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20]. The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3. NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites. Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions. This is called the normalized Banzhaf index. We model this problem by considering a network flow game. The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control. A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise. To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow. In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target. Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows. The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei. Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target. More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1. In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game. When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4. THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game. DEFINITION 1. NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3. We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent. In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}. In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E . The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow. All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei). The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING. First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow). The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem. DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows. From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem. The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem. Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index. They differ only in the target flow value. The first run is with a target flow of k, and the second run is with a target flow of k + . A choice of subset Ec ⊂ E reflects a possible matching in the original graph. G is a subgraph of the constructed G . We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V . Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching. We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec. Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec. A perfect matching matches all the vertices in V . If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible. If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once. In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow. Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once. When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once. The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows. The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1. A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1. The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + . Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + . As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G . We denote the network flow game defined on G with target flow k as v(G ,k). The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)). The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )). The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )). This is proven in Theorem 5. Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct. In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + . PROPOSITION 1. Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1. The edges connected to s; 2. The edges connected to t ; 3. The edge ef = (t , t). We call such a subset a missing subset. The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF. The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth. Edges in G only go between consecutive layers. The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers. If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0. Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets. As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa. PROPOSITION 2. Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V . The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching. PROOF. If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3. Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF. A flow of k is possible. We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers. PROPOSITION 4. Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V . Then the maximal flow between s and t using only the edges in Ec is at least k+ . We call such a set a super-matching, and it is not a perfect matching. PROOF. A flow of k is possible, by using the edges of the perfect match as in Proposition 3. We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1). We then send a flow of from ua to va. This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching. We then send a flow of from va to t . Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has. Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + . Thus, the maximal possible flow is at least k + . THEOREM 5. Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3. Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ . Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run. Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )). PROOF. Consider the game v(G ,k). According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game. According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing. According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning. According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning. Consider the game v(G ,k+ ). Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game. According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing. According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing. According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning. Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem. This means that given a polynomial 338 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem. Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5. CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph. This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time. DEFINITION 3. A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}. The edges run only between consecutive layers. DEFINITION 4. A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs. The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph. However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small. Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments. Let v be a vertex in layer Li. We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i. Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv. E may contain a path from s to v, or it may not. We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li. Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi). Consider a subset of these edges, E ⊂ PredV . Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}. We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si. Let V ⊂ Vi be a subset of the vertices in layer Li. We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|. LEMMA 1. Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer. Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2. Then E and E do not contain the same edges: E = E . PROOF. If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ). Let Si ⊂ Vi be a subset of vertices in layer Li. Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1. Let E ⊂ Ei be some subset of these edges. We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}. Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1. PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si. Consider such a subset E counted in PSi . E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E). According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different. Algorithm 1 calculates Pt. It iterates through the layers, and updates the data for the next layer given the data for the current layer. For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi . It does so using the values calculated in the previous layer. The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer. Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer. There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers. If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) . Since c is a constant, this is a polynomial algorithm. Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant). We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ). The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed. The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 . Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6. RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years. The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19]. In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members. The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games. The Banzhaf index emerged directly from the study of voting in decision-making bodies. The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions. This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk . The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced. Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices. The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i. There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games. Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK. Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete. Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete. The problem of computing power indices in simple games depends on the chosen representation of the game. Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains. In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value. The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph. However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow. They have shown that certain families of network flow games and similar games have nonempty cores. 7. CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices. We have assessed the relative power of each agent in this scenario using the Banzhaf index. This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites. Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete. Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain. In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time. It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain. It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index. We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain. Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8. ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9. REFERENCES [1] J. F. Banzhaf. Weighted voting doesnt work: a mathematical analysis. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou. On the complexity of cooperative solution concepts. Math. Oper. Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley. Mathematical properties of the Banzhaf power index. Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein. The Clarke Tax as a consensus mechanism among automated agents. In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein. A heuristic technique for multiagent planning. Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system. In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella. An automated meeting scheduling system that utilizes user preferences. In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe. Anyone but him: The complexity of precluding an alternative. In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel. On totally balanced games and games of flow. Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel. Generalized network problems yielding totally balanced games. Operations Research, 30:998-1008, September 1982. [11] A. Laruelle. On the choice of a power index. Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui. A survey of algorithms for calculating power indices of weighted majority games. Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui. NP-completeness for calculating power indices of weighted majority games. Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen. Algorithmic mechanism design. Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein. Junta distributions and the average-case complexity of manipulating elections. In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth. Deals among rational agents. In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser. Issues in automated negotiation and electronic commerce: Extending the contract net framework. In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley. A value for n-person games. Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik. A method for evaluating the distribution of power in a committee system. American Political Science Review, 48:787-792, 1954. [20] P. Straffin. Homogeneity, independence and power indices. Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman. On the axiomatic The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341",
    "original_translation": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341",
    "original_sentences": [
        "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
        "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
        "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
        "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
        "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
        "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
        "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
        "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
        "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
        "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
        "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
        "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
        "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
        "What is the complexity of the process?",
        "Can complexity be used to guard against unwanted phenomena?",
        "Does complexity of computation prevent realistic implementation of a technique?",
        "The practical applications of voting among automated agents are already widespread.",
        "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
        "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
        "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
        "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
        "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
        "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
        "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
        "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
        "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
        "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
        "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
        "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
        "The paper proceeds as follows.",
        "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
        "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
        "In Section 5 we consider a restricted case of the network flow game, and present results.",
        "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
        "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
        "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
        "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
        "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
        "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
        "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
        "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
        "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
        "However, it can also easily be applied to any simple coalitional game.",
        "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
        "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
        "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
        "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
        "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
        "This is called the normalized Banzhaf index.",
        "We model this problem by considering a network flow game.",
        "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
        "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
        "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
        "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
        "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
        "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
        "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
        "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
        "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
        "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
        "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
        "DEFINITION 1.",
        "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
        "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
        "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
        "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
        "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
        "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
        "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
        "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
        "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
        "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
        "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
        "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
        "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
        "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
        "They differ only in the target flow value.",
        "The first run is with a target flow of k, and the second run is with a target flow of k + .",
        "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
        "G is a subgraph of the constructed G .",
        "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
        "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
        "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
        "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
        "A perfect matching matches all the vertices in V .",
        "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
        "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
        "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
        "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
        "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
        "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
        "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
        "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
        "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
        "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
        "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
        "We denote the network flow game defined on G with target flow k as v(G ,k).",
        "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
        "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
        "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
        "This is proven in Theorem 5.",
        "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
        "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
        "PROPOSITION 1.",
        "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
        "The edges connected to s; 2.",
        "The edges connected to t ; 3.",
        "The edge ef = (t , t).",
        "We call such a subset a missing subset.",
        "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
        "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
        "Edges in G only go between consecutive layers.",
        "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
        "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
        "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
        "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
        "PROPOSITION 2.",
        "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
        "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
        "PROOF.",
        "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
        "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
        "A flow of k is possible.",
        "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
        "PROPOSITION 4.",
        "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
        "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
        "We call such a set a super-matching, and it is not a perfect matching.",
        "PROOF.",
        "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
        "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
        "We then send a flow of from ua to va.",
        "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
        "We then send a flow of from va to t .",
        "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
        "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
        "Thus, the maximal possible flow is at least k + .",
        "THEOREM 5.",
        "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
        "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
        "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
        "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
        "PROOF.",
        "Consider the game v(G ,k).",
        "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
        "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
        "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
        "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
        "Consider the game v(G ,k+ ).",
        "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
        "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
        "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
        "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
        "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
        "This means that given a polynomial 338 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
        "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
        "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
        "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
        "DEFINITION 3.",
        "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
        "The edges run only between consecutive layers.",
        "DEFINITION 4.",
        "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
        "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
        "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
        "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
        "Let v be a vertex in layer Li.",
        "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
        "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
        "E may contain a path from s to v, or it may not.",
        "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
        "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
        "Consider a subset of these edges, E ⊂ PredV .",
        "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
        "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
        "Let V ⊂ Vi be a subset of the vertices in layer Li.",
        "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
        "LEMMA 1.",
        "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
        "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
        "Then E and E do not contain the same edges: E = E .",
        "PROOF.",
        "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
        "Let Si ⊂ Vi be a subset of vertices in layer Li.",
        "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
        "Let E ⊂ Ei be some subset of these edges.",
        "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
        "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
        "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
        "Consider such a subset E counted in PSi .",
        "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
        "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
        "Algorithm 1 calculates Pt.",
        "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
        "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
        "It does so using the values calculated in the previous layer.",
        "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
        "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
        "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
        "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
        "Since c is a constant, this is a polynomial algorithm.",
        "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
        "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
        "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
        "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
        "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
        "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
        "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
        "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
        "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
        "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
        "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
        "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
        "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
        "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
        "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
        "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
        "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
        "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
        "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
        "The problem of computing power indices in simple games depends on the chosen representation of the game.",
        "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
        "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
        "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
        "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
        "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
        "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
        "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
        "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
        "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
        "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
        "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
        "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
        "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
        "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
        "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
        "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
        "REFERENCES [1] J. F. Banzhaf.",
        "Weighted voting doesnt work: a mathematical analysis.",
        "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
        "On the complexity of cooperative solution concepts.",
        "Math.",
        "Oper.",
        "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
        "Mathematical properties of the Banzhaf power index.",
        "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
        "The Clarke Tax as a consensus mechanism among automated agents.",
        "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
        "A heuristic technique for multiagent planning.",
        "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
        "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
        "An automated meeting scheduling system that utilizes user preferences.",
        "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
        "Anyone but him: The complexity of precluding an alternative.",
        "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
        "On totally balanced games and games of flow.",
        "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
        "Generalized network problems yielding totally balanced games.",
        "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
        "On the choice of a power index.",
        "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
        "A survey of algorithms for calculating power indices of weighted majority games.",
        "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
        "NP-completeness for calculating power indices of weighted majority games.",
        "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
        "Algorithmic mechanism design.",
        "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
        "Junta distributions and the average-case complexity of manipulating elections.",
        "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
        "Deals among rational agents.",
        "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
        "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
        "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
        "A value for n-person games.",
        "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
        "A method for evaluating the distribution of power in a committee system.",
        "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
        "Homogeneity, independence and power indices.",
        "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
        "On the axiomatic The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
    ],
    "translated_text_sentences": [
        "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes.",
        "Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía.",
        "El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple.",
        "En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red.",
        "Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino.",
        "El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red.",
        "Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo.",
        "También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes.",
        "Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1.",
        "La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes.",
        "Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal.",
        "El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15].",
        "Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)?",
        "¿Cuál es la complejidad del proceso?",
        "¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados?",
        "¿La complejidad de la computación impide la implementación realista de una técnica?",
        "Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas.",
        "Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes.",
        "Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7].",
        "De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna.",
        "Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este).",
        "En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder.",
        "Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande.",
        "El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple.",
        "Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red.",
        "En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo.",
        "Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo.",
        "También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente.",
        "Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos.",
        "El artículo continúa de la siguiente manera.",
        "En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red.",
        "En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general.",
        "En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados.",
        "En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2.",
        "Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}).",
        "Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0.",
        "Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}.",
        "Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0.",
        "Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple.",
        "Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego.",
        "Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1].",
        "Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada.",
        "Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple.",
        "El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
        "Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20].",
        "El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3.",
        "JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios.",
        "Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras.",
        "Esto se llama el índice de Banzhaf normalizado.",
        "Modelamos este problema considerando un juego de flujo de red.",
        "El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan.",
        "Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario.",
        "Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo.",
        "En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo.",
        "Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera.",
        "El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei.",
        "Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo.",
        "Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1.",
        "En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego.",
        "Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t.",
        "El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red.",
        "DEFINICIÓN 1.",
        "Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3.",
        "Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente.",
        "En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}.",
        "En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
        "Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E.",
        "El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo.",
        "Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei).",
        "El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING.",
        "Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo).",
        "El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF.",
        "DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera.",
        "A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF.",
        "La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING.",
        "Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf.",
        "Solo difieren en el valor de flujo objetivo.",
        "La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + .",
        "Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original.",
        "G es un subgrafo del G construido.",
        "Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V.",
        "Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento.",
        "Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec.",
        "Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec.",
        "Un emparejamiento perfecto empareja todos los vértices en V.",
        "Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible.",
        "Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez.",
        "En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible.",
        "Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez.",
        "Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez.",
        "La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera.",
        "El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1.",
        "Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1.",
        "La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + .",
        "Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + .",
        "Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G.",
        "Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k).",
        "La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)).",
        "La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )).",
        "El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )).",
        "Esto se demuestra en el Teorema 5.",
        "La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta.",
        "En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +.",
        "PROPUESTA 1.",
        "Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1.",
        "Los bordes conectados a s; 2.",
        "Los bordes conectados a t; 3.",
        "El borde ef = (t, t).",
        "Llamamos a dicho subconjunto un subconjunto faltante.",
        "El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF.",
        "El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta.",
        "Los bordes en G solo van entre capas consecutivas.",
        "El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas.",
        "Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0.",
        "Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes.",
        "Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa.",
        "PROPOSICIÓN 2.",
        "Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V.",
        "El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto.",
        "PRUEBA.",
        "Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3.",
        "Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN.",
        "Un flujo de k es posible.",
        "Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas.",
        "PROPOSICIÓN 4.",
        "Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V.",
        "Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+.",
        "Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto.",
        "PRUEBA.",
        "Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3.",
        "Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1).",
        "Luego enviamos un flujo de ua a va.",
        "Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto.",
        "Luego enviamos un flujo de va a t.",
        "Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde.",
        "Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + .",
        "Por lo tanto, el flujo máximo posible es al menos k + .",
        "TEOREMA 5.",
        "Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3.",
        "Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+.",
        "Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución.",
        "Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )).",
        "PRUEBA.",
        "Considera el juego v(G, k).",
        "Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego.",
        "Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo.",
        "Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores.",
        "Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores.",
        "Considera el juego v(G, k+).",
        "Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego.",
        "Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo.",
        "Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo.",
        "Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores.",
        "Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF.",
        "Esto significa que dado un polinomio 338 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA.",
        "Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5.",
        "CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada.",
        "Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo.",
        "DEFINICIÓN 3.",
        "Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}.",
        "Los bordes corren solo entre capas consecutivas.",
        "DEFINICIÓN 4.",
        "Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos.",
        "El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c.",
        "Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño.",
        "Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos.",
        "Sea v un vértice en la capa Li.",
        "Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i.",
        "Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv.",
        "E puede contener un camino de s a v, o puede que no lo contenga.",
        "Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li.",
        "Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi).",
        "Considera un subconjunto de estos bordes, E ⊂ PredV.",
        "Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}.",
        "Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si.",
        "Sea V ⊂ Vi un subconjunto de los vértices en la capa Li.",
        "Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|.",
        "LEMMA 1. \n\nLEMMA 1.",
        "Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa.",
        "Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2.",
        "Entonces E y E no contienen los mismos bordes: E = E.",
        "PRUEBA.",
        "Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E).",
        "Sea Si ⊂ Vi un subconjunto de vértices en la capa Li.",
        "Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1.",
        "Sea E ⊂ Ei algún subconjunto de estas aristas.",
        "Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}.",
        "Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1.",
        "PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si.",
        "Considera tal subconjunto E contado en PSi.",
        "E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E).",
        "Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente.",
        "El algoritmo 1 calcula Pt.",
        "Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual.",
        "Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi.",
        "Lo hace utilizando los valores calculados en la capa anterior.",
        "El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa.",
        "Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa.",
        "También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas.",
        "Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2).",
        "Dado que c es una constante, este es un algoritmo polinómico.",
        "Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante).",
        "Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G).",
        "La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e.",
        "El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1.",
        "Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada.",
        "La Sexta Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6.",
        "TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años.",
        "Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19].",
        "En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros.",
        "El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples.",
        "El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones.",
        "El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras.",
        "Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk.",
        "El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural.",
        "Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices.",
        "La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i.",
        "Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados.",
        "Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK.",
        "Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto.",
        "Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo.",
        "El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego.",
        "Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos.",
        "En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor.",
        "El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red.",
        "Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo.",
        "Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7.",
        "CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices.",
        "Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf.",
        "Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios.",
        "Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo.",
        "A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido.",
        "En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico.",
        "Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes.",
        "También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf.",
        "Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red.",
        "Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios.",
        "AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9.",
        "REFERENCIAS [1] J. F. Banzhaf.",
        "El voto ponderado no funciona: un análisis matemático.",
        "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou.",
        "Sobre la complejidad de los conceptos de solución cooperativa.",
        "Matemáticas.",
        "This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish.",
        "Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley.",
        "Propiedades matemáticas del índice de poder de Banzhaf.",
        "Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein.",
        "El impuesto Clarke como mecanismo de consenso entre agentes automatizados.",
        "En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein.",
        "Una técnica heurística para la planificación multiagente.",
        "Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación.",
        "En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella.",
        "Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario.",
        "En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe.",
        "Cualquiera menos él: La complejidad de excluir una alternativa.",
        "En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel.",
        "Sobre juegos totalmente equilibrados y juegos de flujo.",
        "Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel.",
        "Problemas de red generalizados que resultan en juegos totalmente equilibrados.",
        "Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle.",
        "Sobre la elección de un índice de poder.",
        "Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui.",
        "Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados.",
        "Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui.",
        "La NP-completitud para calcular índices de poder de juegos de mayoría ponderados.",
        "Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen.",
        "Diseño de mecanismos algorítmicos.",
        "Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein.",
        "Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones.",
        "En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth.",
        "Acuerdos entre agentes racionales.",
        "En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser.",
        "Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos.",
        "En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley.",
        "Un valor para juegos de n personas.",
        "Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik.",
        "Un método para evaluar la distribución de poder en un sistema de comités.",
        "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin.",
        "Índices de homogeneidad, independencia y poder.",
        "Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman.",
        "En el Sexto Congreso Internacional Axiomático.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341"
    ],
    "error_count": 4,
    "keys": {
        "preference aggregation": {
            "translated_key": "agregación de preferencias",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT <br>preference aggregation</br> is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive <br>preference aggregation</br> schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, <br>preference aggregation</br> and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT <br>preference aggregation</br> is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "One of the most massive <br>preference aggregation</br> schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, <br>preference aggregation</br> and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent."
            ],
            "translated_annotated_samples": [
                "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La <br>agregación de preferencias</br> se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes.",
                "Uno de los esquemas de <br>agregación de preferencias</br> más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este).",
                "También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La <br>agregación de preferencias</br> se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de <br>agregación de preferencias</br> más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "multiagent application": {
            "translated_key": "aplicaciones multiagentes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of <br>multiagent application</br>s, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build <br>multiagent application</br>s.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of <br>multiagent application</br>s, and as a result, voting theory has become an important topic in multiagent system research.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build <br>multiagent application</br>s."
            ],
            "translated_annotated_samples": [
                "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de <br>aplicaciones multiagentes</br>, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes.",
                "La teoría de la elección social puede servir como una base apropiada sobre la cual construir <br>aplicaciones multiagentes</br>."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de <br>aplicaciones multiagentes</br>, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir <br>aplicaciones multiagentes</br>. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "voting theory": {
            "translated_key": "teoría de votación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, <br>voting theory</br> has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, <br>voting theory</br> has become an important topic in multiagent system research."
            ],
            "translated_annotated_samples": [
                "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la <br>teoría de votación</br> se ha convertido en un tema importante en la investigación de sistemas multiagentes."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la <br>teoría de votación</br> se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "banzhaf power index": {
            "translated_key": "Índice de Poder de Banzhaf",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the <br>banzhaf power index</br> in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The <br>banzhaf power index</br> is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the <br>banzhaf power index</br> within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the <br>banzhaf power index</br> of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The <br>banzhaf power index</br> is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the <br>banzhaf power index</br> in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the <br>banzhaf power index</br> of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the <br>banzhaf power index</br> of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the <br>banzhaf power index</br>, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the <br>banzhaf power index</br> in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The <br>banzhaf power index</br> reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the <br>banzhaf power index</br>.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Computing the <br>banzhaf power index</br> in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "The <br>banzhaf power index</br> is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the <br>banzhaf power index</br> within a particular multiagent domain, a network flow game.",
                "We show that calculating the <br>banzhaf power index</br> of each agent in this network flow domain is #P-complete.",
                "The <br>banzhaf power index</br> is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game."
            ],
            "translated_annotated_samples": [
                "Calcular el <br>Índice de Poder de Banzhaf</br> en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes.",
                "El <br>índice de poder de Banzhaf</br> es uno de los más populares; también está bien definido para cualquier juego de coalición simple.",
                "En este artículo, examinamos la complejidad computacional de calcular el <br>índice de poder de Banzhaf</br> dentro de un dominio multiagente particular, un juego de flujo de red.",
                "Mostramos que calcular el <br>índice de poder de Banzhaf</br> de cada agente en este dominio de flujo de red es #P-completo.",
                "El <br>índice de poder de Banzhaf</br> es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple."
            ],
            "translated_text": "Calcular el <br>Índice de Poder de Banzhaf</br> en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El <br>índice de poder de Banzhaf</br> es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el <br>índice de poder de Banzhaf</br> dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el <br>índice de poder de Banzhaf</br> de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El <br>índice de poder de Banzhaf</br> es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "analysis of algorithm and problem complexity": {
            "translated_key": "análisis de algoritmos y complejidad de problemas",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "algorithm and problem complexity analysis": {
            "translated_key": "Análisis de algoritmos y complejidad de problemas",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "social choice theory": {
            "translated_key": "teoría de la elección social",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION <br>social choice theory</br> can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "INTRODUCTION <br>social choice theory</br> can serve as an appropriate foundation upon which to build multiagent applications."
            ],
            "translated_annotated_samples": [
                "La <br>teoría de la elección social</br> puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La <br>teoría de la elección social</br> puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "automated agent voting": {
            "translated_key": "votación de agentes automatizados",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of <br>automated agent voting</br>, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "In this paper, we consider a topic that has been less studied in the context of <br>automated agent voting</br>, namely power indices."
            ],
            "translated_annotated_samples": [
                "En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la <br>votación de agentes automatizados</br>, a saber, los índices de poder."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la <br>votación de agentes automatizados</br>, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "network flow game": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a <br>network flow game</br>.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a <br>network flow game</br>.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific <br>network flow game</br>.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the <br>network flow game</br>, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a <br>network flow game</br>.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a <br>network flow game</br> is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the <br>network flow game</br> is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a <br>network flow game</br> where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a <br>network flow game</br> (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the <br>network flow game</br>.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the <br>network flow game</br>, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the <br>network flow game</br> We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the <br>network flow game</br> defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the <br>network flow game</br> defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general <br>network flow game</br>, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The <br>network flow game</br> we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the <br>network flow game</br>, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a <br>network flow game</br>.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a <br>network flow game</br>.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific <br>network flow game</br>.",
                "In Section 5 we consider a restricted case of the <br>network flow game</br>, and present results.",
                "We model this problem by considering a <br>network flow game</br>."
            ],
            "translated_annotated_samples": [
                "En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un <br>juego de flujo de red</br>.",
                "Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un <br>juego de flujo de red</br>.",
                "En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro <br>juego específico de flujo de red</br>.",
                "En la Sección 5 consideramos un caso restringido del <br>juego de flujo de red</br> y presentamos resultados.",
                "Modelamos este problema considerando un <br>juego de flujo de red</br>."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un <br>juego de flujo de red</br>. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un <br>juego de flujo de red</br>. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro <br>juego específico de flujo de red</br>. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del <br>juego de flujo de red</br> y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un <br>juego de flujo de red</br>. ",
            "candidates": [],
            "error": [
                [
                    "juego de flujo de red",
                    "juego de flujo de red",
                    "juego específico de flujo de red",
                    "juego de flujo de red",
                    "juego de flujo de red"
                ]
            ]
        },
        "probabilistic model": {
            "translated_key": "modelo probabilístico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable <br>probabilistic model</br>, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Under a reasonable <br>probabilistic model</br>, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows."
            ],
            "translated_annotated_samples": [
                "Bajo un <br>modelo probabilístico</br> razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un <br>modelo probabilístico</br> razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "connectivity game": {
            "translated_key": "juego de conectividad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the <br>connectivity game</br>; in a <br>connectivity game</br>, a coalition wants to have some path from source to target.",
                "More precisely, a <br>connectivity game</br> is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a <br>connectivity game</br>), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a <br>connectivity game</br>, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the <br>connectivity game</br> on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the <br>connectivity game</br>; in a <br>connectivity game</br>, a coalition wants to have some path from source to target.",
                "More precisely, a <br>connectivity game</br> is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a <br>connectivity game</br>), we can compute the power indices of the game.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a <br>connectivity game</br>, where the network is a bounded layer graph.",
                "Consider the <br>connectivity game</br> on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant)."
            ],
            "translated_annotated_samples": [
                "Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el <br>juego de conectividad</br>; en un <br>juego de conectividad</br>, una coalición desea tener algún camino desde la fuente al objetivo.",
                "Más precisamente, un <br>juego de conectividad</br> es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1.",
                "En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un <br>juego de conectividad</br>), podemos calcular los índices de poder del juego.",
                "CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un <br>juego de conectividad</br>, donde la red es un gráfico de capa limitada.",
                "Considera el <br>juego de conectividad</br> en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante)."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el <br>juego de conectividad</br>; en un <br>juego de conectividad</br>, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un <br>juego de conectividad</br> es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un <br>juego de conectividad</br>), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un <br>juego de conectividad</br>, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el <br>juego de conectividad</br> en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "computational complexity": {
            "translated_key": "complejidad computacional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the <br>computational complexity</br> of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "In this paper, we examine the <br>computational complexity</br> of calculating the Banzhaf power index within a particular multiagent domain, a network flow game."
            ],
            "translated_annotated_samples": [
                "En este artículo, examinamos la <br>complejidad computacional</br> de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la <br>complejidad computacional</br> de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "vote": {
            "translated_key": "voto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf Power Index in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf power index is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf power index within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf power index of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a <br>vote</br> among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A power index is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf power index is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf power index in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf power index of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf power index of an agent.",
                "There are implications in this scenario to real-world networks; for example, the power index might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf power index, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf power index in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf power index reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This power index may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf power index.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a power index.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a <br>vote</br> among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this)."
            ],
            "translated_annotated_samples": [
                "Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un <br>voto</br> entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este)."
            ],
            "translated_text": "Calcular el Índice de Poder de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El índice de poder de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el índice de poder de Banzhaf dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un <br>voto</br> entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un índice de poder es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. El índice de poder de Banzhaf es una de las medidas más populares de poder de voto, y aunque ha sido utilizado principalmente para medir el poder en juegos de votación ponderada, está bien definido para cualquier juego de coalición simple. Examinamos algunos aspectos computacionales del índice de poder de Banzhaf en un entorno específico, a saber, un juego de flujo de red. En este juego, una coalición de agentes gana si puede enviar un flujo de tamaño k desde un vértice fuente s a un vértice objetivo t, con el poder relativo de cada arista reflejando su importancia en permitir dicho flujo. Mostramos que calcular el índice de poder de Banzhaf de cada agente en este dominio general de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos (específicamente, de juegos de conectividad en grafos de capa acotada), existe un algoritmo polinómico para calcular el índice de poder de Banzhaf de un agente. Existen implicaciones en este escenario para las redes del mundo real; por ejemplo, el índice de potencia podría ser utilizado para asignar recursos de mantenimiento (siendo más crítico un borde más poderoso), con el fin de mantener un flujo de datos dado entre dos puntos. El artículo continúa de la siguiente manera. En la Sección 2 proporcionamos antecedentes sobre los juegos coalicionales y el índice de poder de Banzhaf, y en la Sección 3 presentamos nuestro juego específico de flujo de red. En la Sección 4 discutimos el índice de poder de Banzhaf en juegos de flujo de red, presentando nuestro resultado de complejidad en el caso general. En la Sección 5 consideramos un caso restringido del juego de flujo de red y presentamos resultados. En la Sección 6 discutimos el trabajo relacionado, y concluimos en la Sección 7. 2. Un juego de coalición está compuesto por un conjunto de n agentes, I, y una función que asigna a cualquier subconjunto (coalición) de los agentes un valor real v : 2I → R. En un juego de coalición simple, v solo toma valores de 0 o 1 (v : 2I → {0, 1}). Decimos que una coalición C ⊂ I gana si v(C) = 1, y decimos que pierde si v(C) = 0. Denotamos el conjunto de todas las coaliciones ganadoras como W(v) = {C ⊂ 2I |v(C) = 1}. Un agente i es un jugador clave (o pivote) en una coalición ganadora C si la eliminación del agente de esa coalición la convertiría en una coalición perdedora: v(C) = 1, v(C \\ {i}) = 0. Un swing es un par < i, S > tal que el agente i es un swinger en la coalición S. Una pregunta que surge en este contexto es la de medir la influencia que un agente dado tiene en el resultado de un juego simple. Un enfoque para medir el poder de agentes individuales en juegos de coalición simples es el índice de Banzhaf. 2.1 El Índice de Banzhaf Una interpretación común del poder que posee un agente es la probabilidad a priori de tener un papel significativo en el juego. Diferentes suposiciones sobre la formación de coaliciones y diferentes definiciones de tener un papel significativo han llevado a los investigadores a definir diferentes índices de poder, uno de los más destacados de los cuales es el índice de Banzhaf [1]. Este índice ha sido ampliamente utilizado, aunque principalmente con el propósito de medir el poder individual en un sistema de votación ponderada. Sin embargo, también se puede aplicar fácilmente a cualquier juego coalicional simple. El índice de Banzhaf depende del número de coaliciones en las que un agente es un jugador clave, de todas las coaliciones posibles. El índice de Banzhaf se da por β(v) = (β1(v), ..., βn(v)) donde βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})]. Diferentes modelos probabilísticos sobre la forma en que se forma una coalición producen diferentes índices de poder apropiados [20]. El índice de poder de Banzhaf refleja la suposición de que los agentes son independientes en sus elecciones. 3. JUEGOS DE FLUJO DE RED 3.1 Motivación Considera una red de comunicación, donde es crucial poder enviar una cierta cantidad de información entre dos sitios. Dado los recursos limitados para mantener enlaces de red, ¿en qué aristas deberían invertirse esos recursos? Banzhaf 2 consideró realmente el porcentaje de dichas coaliciones respecto a todas las coaliciones ganadoras. Esto se llama el índice de Banzhaf normalizado. Modelamos este problema considerando un juego de flujo de red. El juego consiste en agentes en un grafo de flujo de red, con un cierto vértice fuente s y un vértice destino t. Cada agente controla una de las aristas del grafo, y una coalición de agentes controla todas las aristas que sus miembros controlan. Una coalición de agentes gana el juego si logra enviar un flujo de al menos k desde la fuente s hasta el objetivo t, y pierde en caso contrario. Para asegurar que la red sea capaz de mantener el flujo deseado entre s y t, podemos optar por asignar nuestros limitados recursos de mantenimiento a las aristas según su impacto en permitir este flujo. En otras palabras, los recursos podrían ser dedicados a los enlaces cuyo fallo es más probable que nos haga perder la capacidad de enviar la cantidad requerida de información entre la fuente y el objetivo. Bajo un modelo probabilístico razonable, el índice de Banzhaf nos proporciona una medida del impacto que cada arista tiene en permitir que esta cantidad de información sea enviada entre los sitios, y por lo tanto proporciona una base razonable para la asignación de recursos escasos de mantenimiento. 3.2 Definición Formal Formalmente, un juego de flujo de red se define de la siguiente manera. El juego consiste en un grafo de flujo de red G =< V, E >, con capacidades en las aristas c : E → R, un vértice fuente s, un vértice destino t, y un conjunto I de agentes, donde el agente i controla la arista ei. Dada una coalición C, que controla las aristas EC = {ei|i ∈ C}, podemos verificar si la coalición permite un flujo de k de s a t. Definimos el juego coalicional simple de flujo de red como el juego en el que la coalición gana si permite dicho flujo, y pierde de lo contrario: v(C) = 1 si EC permite un flujo de k de s a t; 0 de lo contrario; Una versión simplificada del juego de flujo de red es el juego de conectividad; en un juego de conectividad, una coalición desea tener algún camino desde la fuente al objetivo. Más precisamente, un juego de conectividad es un juego de flujo de red donde cada una de las aristas tiene una capacidad idéntica, c(e) = 1, y el valor de flujo objetivo es k = 1. En dicho escenario, el objetivo de una coalición es tener al menos un camino de s a t: v(C) = 1 si EC contiene un camino de s a t; 0 en caso contrario; Dado un juego de flujo de red (o un juego de conectividad), podemos calcular los índices de poder del juego. Cuando se elige al azar una coalición de aristas, y cada coalición es equiprobable, el índice apropiado es el índice de Banzhaf. Podemos usar el valor de Banzhaf de un agente i ∈ I (o la arista que controla, ei), βei(v) = βi(v), para medir su impacto en permitir un flujo dado entre s y t. El Índice de Banzhaf en los juegos de flujo de red. Ahora definimos el problema de calcular el Índice de Banzhaf en el juego de flujo de red. DEFINICIÓN 1. Se nos da un grafo de flujo de red G =< V, E > con un vértice fuente s y un vértice objetivo t, una función de capacidad c : E → R, y un valor de flujo objetivo k. Consideramos el juego de flujo de red, como se define arriba en la Sección 3. Se nos da un agente i, controlando el borde ei, y se nos pide calcular el índice de Banzhaf para ese agente. En la red 3, cuando cada ordenación de aristas es equiprobable, el índice apropiado es el índice de Shapley-Shubik. 336 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) juego de flujo, sea Cei el conjunto de todos los subconjuntos de E que contienen ei: Cei = {C ⊂ E|ei ∈ C}. En este juego, el índice de Banzhaf de ei es: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})]. Sea W(Cei) el conjunto de subconjuntos ganadores de aristas en Cei, es decir, los subconjuntos E ∈ Cei donde se puede enviar un flujo de al menos k de s a t utilizando solo las aristas en E. El índice de Banzhaf de ei es la proporción de subconjuntos en W(Cei) donde ei es crucial para mantener el k-flujo. Todos los subconjuntos de bordes en W(Cei) contienen ei y son ganadores, pero solo para algunos de ellos, E ∈ W(Cei), tenemos que v(E \\ {ei}) = 0 (es decir, E ya no es ganador si eliminamos ei). El índice de Banzhaf de ei es la proporción de tales subconjuntos. 4.1 #Completitud de P al calcular el índice de Banzhaf en el juego de flujo de red. Ahora mostramos que el caso general de NETWORK-FLOW-BANZHAF es #P-completo, mediante una reducción de #MATCHING. Primero, observamos que NETWORK-FLOW-BANZHAF está en #P. Hay varios algoritmos polinomiales para calcular el flujo de red máximo, por lo que es fácil verificar si un cierto subconjunto de aristas E ⊂ E contiene ei y permite un flujo de al menos k de s a t. También es fácil verificar si un flujo de al menos k ya no es posible cuando eliminamos ei de E (nuevamente, ejecutando un algoritmo polinomial para calcular el flujo máximo). El índice de Banzhaf de ei es exactamente el número de subconjuntos E ⊂ E, por lo que NETWORK-FLOW-BANZHAF está en #P. Para demostrar que NETWORK-FLOW-BANZHAF es #P-completo, reducimos un problema de #MATCHING a un problema de NETWORK-FLOW-BANZHAF. DEFINICIÓN 2. #COINCIDENCIA: Se nos da un grafo bipartito G =< U, V, E >, tal que |U| = |V | = n, y se nos pide contar el número de coincidencias perfectas posibles en G. 4.2 El Enfoque de Reducción General El proceso de reducción se realiza de la siguiente manera. A partir de la entrada #MATCHING, G =< U, V, E >, construimos dos entradas para el problema de FLUJO EN RED-BANZHAF. La diferencia entre las respuestas obtenidas de las ejecuciones de NETWORK-FLOW-BANZHAF es la respuesta al problema de #MATCHING. Ambas ejecuciones del problema NETWORKFLOW-BANZHAF se construyen con el mismo grafo G =< V , E >, con el mismo vértice fuente s y vértice destino t, y con la misma arista ef para la cual calcular el índice de Banzhaf. Solo difieren en el valor de flujo objetivo. La primera corrida es con un flujo objetivo de k, y la segunda corrida es con un flujo objetivo de k + . Una elección de subconjunto Ec ⊂ E refleja una posible correspondencia en el grafo original. G es un subgrafo del G construido. Identificamos un borde en G, e ∈ E, con el mismo borde en G. Este borde indica una coincidencia particular entre algún vértice u ∈ U y otro vértice v ∈ V. Por lo tanto, si Ec ⊂ E es un subconjunto de aristas en G que contiene solo aristas en el subgrafo de G, lo identificamos con un subconjunto de aristas en G, o con algún candidato de un emparejamiento. Decimos que Ec ⊂ E coincide con algún vértice v ∈ V, si Ec contiene alguna arista que se conecta a v, es decir, para algún u ∈ U tenemos (u, v) ∈ Ec. Ec es una coincidencia posible si no coincide con un vértice v ∈ V con más de un vértice en U, es decir, no hay dos vértices u1 = u2 en U que ambos (u1, v) ∈ Ec y (u2, v) ∈ Ec. Un emparejamiento perfecto empareja todos los vértices en V. Si Ec no logra emparejar un vértice en V (el lado derecho de la partición), el flujo máximo posible que Ec permite en G es menor que k. Si empareja todos los vértices en V, un flujo de k es posible. Si coincide con 4, este es uno de los problemas #P-completos más conocidos. Si empareja todos los vértices en V, pero empareja algún vértice en V más de una vez (lo que significa que no es un emparejamiento verdadero), es posible un flujo de k+. Se elige de tal manera que si un solo vértice v ∈ V no está emparejado, el flujo máximo posible sería menor que |V|, incluso si todos los demás vértices están emparejados más de una vez. En otras palabras, se elige de manera que emparejar varios vértices en V más de una vez nunca pueda compensar por no emparejar algún vértice en V, en términos del flujo máximo posible. Por lo tanto, al verificar el índice de Banzhaf de ef cuando el flujo requerido es al menos k, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez. Cuando verificamos el índice de Banzhaf de ef con un flujo requerido de al menos k+, obtenemos el número de subconjuntos E ⊂ E que coinciden con todos los vértices en V al menos una vez, y coinciden con al menos un vértice v ∈ V más de una vez. La diferencia entre ambos es exactamente el número de emparejamientos perfectos en G. Por lo tanto, si existiera un algoritmo polinomial para NETWORKFLOW-BANZHAF, podríamos utilizarlo para construir un algoritmo polinomial para #MATCHING, por lo que NETWORK-FLOW-BANZHAF es #Pcompleto. Detalles de la Reducción 4.3 La reducción toma la entrada de #MATCHING, el grafo bipartito G =< U, V, E >, donde |U| = |V | = k. Luego genera un grafo de flujo de red G de la siguiente manera. El grafo G se mantiene como un subgrafo de G, y a cada arista en G se le asigna una capacidad de 1. Se agrega un nuevo vértice fuente s, junto con un nuevo vértice t y un nuevo vértice objetivo t. Sea = 1 k+1 de modo que · k < 1. La fuente s está conectada a cada uno de los vértices en U, la partición izquierda de G, con una arista de capacidad 1 + . Cada uno de los vértices en V está conectado a t con un borde de capacidad 1 + . t está conectado a t con un borde ef de capacidad 1 + . Como se mencionó anteriormente, realizamos dos ejecuciones de NETWORK-FLOWBANZHAF, ambas verificando el índice de Banzhaf del borde ef en la red de flujo G. Denotamos el juego de flujo de red definido en G con flujo objetivo k como v(G, k). La primera ejecución se realiza en el juego con un flujo objetivo de k, v(G, k), devolviendo el índice βef (v(G, k)). La segunda ejecución se realiza en el juego con un flujo objetivo de k + , v(G ,k+ ), devolviendo el índice βef (v(G ,k+ )). El número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). Esto se demuestra en el Teorema 5. La Figura 1 muestra un ejemplo de construcción de G a partir de G. A la izquierda se encuentra el grafo original G, y a la derecha se encuentra el grafo de flujo de red construido G . 4.4 Prueba de la reducción Ahora demostraremos que la reducción anterior es correcta. En toda esta sección, tomamos la entrada para el problema #MATCHING como G =< U, V, E > con |U| = |V | = k, el grafo de flujo de red construido en la reducción como G =< V , E > con capacidades c : E → R como se define en la Sección 4.3, la arista para la cual calcular el índice de Banzhaf como ef, y los valores de flujo objetivo de k y k +. PROPUESTA 1. Sea Ec ⊂ E un subconjunto de aristas que carece de una o más aristas de las siguientes: 1. Los bordes conectados a s; 2. Los bordes conectados a t; 3. El borde ef = (t, t). Llamamos a dicho subconjunto un subconjunto faltante. El flujo máximo entre s y t utilizando solo las aristas en el subconjunto faltante Ec es menor que k. El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 337 Figura 1: Reducción de #MATCHING a PRUEBA DE FLUJO DE RED-BANZHAF. El grafo es un grafo de capas, con s siendo el vértice en la primera capa, U los vértices en la segunda capa, V los vértices en la tercera, t el vértice en la cuarta, y t en la quinta. Los bordes en G solo van entre capas consecutivas. El flujo máximo en un grafo de capas está limitado por la capacidad total de las aristas entre cada dos capas consecutivas. Si falta alguno de los bordes entre s y U, el flujo está limitado por (|V| − 1)(1 + ε) < k. Si falta alguno de los bordes entre V y t, el flujo también está limitado por (|V| − 1)(1 + ε) < k. Si falta el borde ef, no hay bordes que vayan a la última capa y el flujo máximo es 0. Dado que tales subconjuntos faltantes de aristas no afectan el índice de Banzhaf de ef (suman 0 al total), a partir de ahora consideraremos solo los subconjuntos no faltantes. Como se explica en la Sección 4.2, identificamos los bordes en G que fueron copiados de G (los bordes entre U y V en G) con sus contrapartes en G. Cada borde (u, v) ∈ E representa una coincidencia entre u y v en G. Ec es un emparejamiento perfecto si empareja cada vértice u con un solo vértice v y viceversa. PROPOSICIÓN 2. Sea Ec ⊂ E un subconjunto de aristas que no coincide con algún vértice v ∈ V. El flujo máximo entre s y t usando solo las aristas en el subconjunto faltante Ec es menor que k. Llamamos a este tipo de conjunto sub-matching, y no es un emparejamiento perfecto. PRUEBA. Si Ec no logra emparejar algún vértice v ∈ V, el flujo máximo que puede llegar a los vértices en la capa V es (1+ )(k−1) < k, por lo que este también es el flujo máximo que puede llegar a t. PROPOSICIÓN 3. Sea Ec ⊂ E un subconjunto de aristas que es un emparejamiento perfecto en G. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es exactamente k. DEMOSTRACIÓN. Un flujo de k es posible. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Un flujo mayor a k no es posible ya que hay exactamente k aristas de capacidad 1 entre la capa U y la capa V, y el flujo máximo está limitado por la capacidad total de las aristas entre estas dos capas consecutivas. PROPOSICIÓN 4. Sea Ec ⊂ E un subconjunto de aristas que contiene un emparejamiento perfecto M ⊂ E en G y al menos una arista adicional ex entre algún vértice ua ∈ U y va ∈ V. Entonces, el flujo máximo entre s y t usando solo las aristas en Ec es al menos k+. Llamamos a dicho conjunto un super-matching, y no es un emparejamiento perfecto. PRUEBA. Un flujo de k es posible, utilizando los bordes de la pareja perfecta como en la Proposición 3. Enviamos un flujo de 1 desde s a cada uno de los vértices en U, enviamos un flujo de 1 desde cada vértice u ∈ U a su pareja v ∈ V, y enviamos un flujo de 1 desde cada v ∈ V a t. t recibe un flujo total de exactamente k y lo envía a t. Después de usar las aristas del emparejamiento perfecto, enviamos un flujo de s a ua (esto es posible ya que la capacidad de la arista (s, ua) es 1 + y solo hemos utilizado 1). Luego enviamos un flujo de ua a va. Esto es posible ya que no hemos utilizado este borde en absoluto: es el borde que no forma parte del emparejamiento perfecto. Luego enviamos un flujo de va a t. Nuevamente, esto es posible ya que hemos utilizado 1 de la capacidad total de 1 + que tiene ese borde. Ahora t recibe un flujo total de k + , y lo envía todo a t, por lo que hemos logrado un flujo total de k + . Por lo tanto, el flujo máximo posible es al menos k + . TEOREMA 5. Considere una instancia de #MATCHING G =< U, V, E > reducida a una instancia de flujo de red de BANZHAF-NETWORK-FLOW G como se explica en la Sección 4.3. Sea v(G, k) el juego de flujo de red definido en G con un flujo objetivo k, y v(G, k+) el juego definido con un flujo objetivo de k+. Que el índice resultante de la primera ejecución sea βef (v(G ,k)), y βef (v(G ,k+ )) sea el índice resultante de la segunda ejecución. Entonces, el número de emparejamientos perfectos en G es la diferencia entre las respuestas en las dos ejecuciones, βef (v(G ,k)) − βef (v(G ,k+ )). PRUEBA. Considera el juego v(G, k). Según la Proposición 1, en este juego, el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 1 al conteo por cada emparejamiento perfecto, ya que dichos subconjuntos permiten un flujo de k y son ganadores. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k (y más de k) y son ganadores. Considera el juego v(G, k+). Nuevamente, de acuerdo con la Proposición 1, en este juego el índice de Banzhaf de Ef no cuenta los subconjuntos faltantes Ec ∈ E, ya que están perdiendo en este juego. Según la Proposición 2, no se cuentan los subconjuntos Ec ∈ E que son subemparejamientos, ya que también están perdiendo. Según la Proposición 3, se suma 0 al recuento por cada emparejamiento perfecto, ya que tales subconjuntos permiten un flujo de k pero no de k +, y por lo tanto están perdiendo. Según la Proposición 3, se suma 1 al recuento por cada super-matching, ya que dichos subconjuntos permiten un flujo de k + y son ganadores. Por lo tanto, la diferencia entre los dos índices, βef (v(G ,k)) − βef (v(G ,k+ )), es exactamente el número de emparejamientos perfectos en G. Hemos reducido un problema de #MATCHING a un problema de NETWORKFLOW-BANZHAF. Esto significa que dado un polinomio 338 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) algoritmo para calcular el índice de Banzhaf de un agente en un juego de flujo de red general, podemos construir un algoritmo para resolver el problema de #COINCIDENCIA. Por lo tanto, el problema de calcular el índice de Banzhaf de los agentes en juegos de flujo de red en general también es #P-completo. 5. CALCULANDO EL ÍNDICE DE BANZHAF EN JUEGOS DE CONECTIVIDAD DE GRÁFICOS DE CAPA LIMITADA Presentamos aquí un algoritmo polinómico para calcular el índice de Banzhaf de una arista en un juego de conectividad, donde la red es un gráfico de capa limitada. Este resultado positivo indica que para algunos dominios restringidos de juegos de flujo de red, es posible calcular el índice de Banzhaf en una cantidad razonable de tiempo. DEFINICIÓN 3. Un grafo de capas es un grafo G =< V, E >, con vértice fuente s y vértice destino t, donde los vértices del grafo se dividen en n + 1 capas, L0 = {s}, L1, ..., Ln = {t}. Los bordes corren solo entre capas consecutivas. DEFINICIÓN 4. Un grafo de capas acotadas por c es un grafo de capas donde el número de vértices en cada capa está limitado por un número constante c. Aunque no hay límite en el número de capas en un grafo de capas acotadas, la estructura de dichos grafos permite calcular el índice de Banzhaf de aristas en juegos de conectividad en dichos grafos. El algoritmo proporcionado a continuación es efectivamente polinómico en el número de vértices dado que la red es un grafo de capas acotado por c. Sin embargo, hay un factor constante en el tiempo de ejecución, que es exponencial en c. Por lo tanto, este método solo es viable para grafos donde el límite c es pequeño. Los grafos de capa limitada pueden ocurrir en redes cuando los nodos están ubicados en varios segmentos ordenados, donde los nodos solo pueden estar conectados entre segmentos consecutivos. Sea v un vértice en la capa Li. Decimos que un borde e ocurre antes de v si conecta dos vértices en la capa de v o en una capa anterior: e = (u, w) conecta el vértice u ∈ Lj con el vértice w ∈ Lj+1 y j + 1 ≤ i. Sea Predv ⊂ E el subconjunto de aristas que ocurren antes de v. Considere un subconjunto de estas aristas, E ⊂ Predv. E puede contener un camino de s a v, o puede que no lo contenga. Definimos Pv como el número de subconjuntos E ⊂ Predv que contienen un camino desde s hasta v. De manera similar, sea Vi ∈ V el subconjunto de todos los vértices en la misma capa Li. Sea PredVi ⊂ E el subconjunto de aristas que ocurren antes de Vi (todos los vértices en Vi están en la misma capa, por lo que cualquier arista que ocurra antes de algún v ∈ Vi ocurre antes que cualquier otro vértice w ∈ Vi). Considera un subconjunto de estos bordes, E ⊂ PredV. Sea Vi(E) el subconjunto de vértices en Vi que son alcanzables desde s usando solo las aristas en E: Vi(E) = {v ∈ Vi | E contiene un camino de s a v}. Decimos que E ∈ PredV conecta exactamente los vértices en Si ⊂ Vi si todos los vértices en Si son alcanzables desde s usando las aristas en E pero ningún otro vértice en Vi es alcanzable desde s usando E, por lo tanto, Vi(E) = Si. Sea V ⊂ Vi un subconjunto de los vértices en la capa Li. Definimos PV como el número de subconjuntos E ⊂ PredV que conectan exactamente los vértices en V: PV = |{E ⊂ PredV |Vi(E) = V}|. LEMMA 1. \n\nLEMMA 1. Sean S1, S2 ⊂ Vi donde S1 = S2 dos subconjuntos diferentes de vértices en la misma capa. Sean E, E ⊂ PredVi dos conjuntos de subconjuntos de aristas, de modo que E conecta exactamente los vértices en S1 y E conecta exactamente los vértices en S2: Vi(E) = S1 y Vi(E) = S2. Entonces E y E no contienen los mismos bordes: E = E. PRUEBA. Si E = E entonces ambos conjuntos de aristas permiten los mismos caminos desde s, por lo que Vi(E) = Vi(E). Sea Si ⊂ Vi un subconjunto de vértices en la capa Li. Sea Ei ⊂ E el conjunto de aristas entre los vértices en la capa Li y la capa Li+1. Sea E ⊂ Ei algún subconjunto de estas aristas. Denotamos por Dests(Si, E) al conjunto de vértices en la capa Li+1 que están conectados a algún vértice en Si por una arista en E: Dests(Si, E) = {v ∈ Vi+1|existe algún w ∈ Si y algún e ∈ E tal que e = (w, v)}. Sea Si ⊂ Vi un subconjunto de vértices en Li y E ⊂ Ei un subconjunto de aristas entre la capa Li y la capa Li+1. PSi cuenta el número de subconjuntos de bordes en PredVi que conectan exactamente los vértices en Si. Considera tal subconjunto E contado en PSi. E ∪ E es un subconjunto de aristas en PredVi+1 que se conecta exactamente con Dest(Si, E). Según el Lema 1, si iteramos sobre los diferentes Sis en la capa Li, los PSi cuentan diferentes subconjuntos de aristas, y por lo tanto, cada expansión utilizando las aristas en E también es diferente. El algoritmo 1 calcula Pt. Itera a través de las capas y actualiza los datos para la siguiente capa dados los datos de la capa actual. Para cada capa Li y cada subconjunto de aristas en esa capa Si ⊂ Vi, se calcula PSi. Lo hace utilizando los valores calculados en la capa anterior. El algoritmo considera cada subconjunto de vértices posibles en la capa actual, y cada subconjunto posible de aristas de expansión hacia la siguiente capa, y actualiza el valor del subconjunto correspondiente en la siguiente capa. Algoritmo 1 1: procedimiento CONECTANDO-EXACTAMENTE-SUBCONJUNTOS(G, v) 2: P{s} ← 1 Inicialización 3: para todos los demás subconjuntos de vértices S hacer Inicialización 4: PS ← 0 5: fin para 6: para i ← 0 a n − 1 hacer Iterar a través de capas 7: para todos los subconjuntos de vértices Si en Li hacer 8: para todos los subconjuntos de aristas E entre Li, Li+1 hacer 9: D ← Destinos(Si, E) subconjunto en Li+1 10: PD ← PD + PSi 11: fin para 12: fin para 13: fin para 14: fin procedimiento Un grafo de capas acotado por c contiene como máximo c vértices en cada capa, por lo que para cada capa hay como máximo 2c subconjuntos diferentes de vértices en esa capa. También hay a lo sumo c2 aristas entre 2 capas consecutivas, y por lo tanto a lo sumo 2(c2) subconjuntos de aristas entre dos capas. Si el grafo contiene k capas, el tiempo de ejecución del algoritmo está limitado por k·2c ·2(c2). Dado que c es una constante, este es un algoritmo polinómico. Considera el juego de conectividad en un grafo de capa G, con un solo vértice fuente s y un vértice destino t. El índice de Banzhaf de la arista e es el número de subconjuntos de aristas que permiten un camino entre s y t, pero no permiten tal camino cuando se elimina e (dividido por una constante). Podemos calcular P{t} = P{t}(G) para G utilizando el algoritmo para contar el número de subconjuntos de aristas que permiten un camino de s a t. Luego podemos eliminar e de G para obtener el grafo G =< V, E \\ {e} >, y calcular P{t} = P{t}(G). La diferencia P{t}(G) − P{t}(G ) es el número de subconjuntos de aristas que contienen un camino de s a t pero ya no contienen dicho camino cuando se elimina e. El índice de Banzhaf para e es P{t}(G)−P{t}(G ) 2|E|−1. Por lo tanto, este algoritmo nos permite calcular el índice de Banzhaf en una arista en los juegos de conectividad en grafos de capa limitada. La Sexta Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 339 6. TRABAJO RELACIONADO Medir el poder de los jugadores individuales en juegos coalicionales ha sido estudiado durante muchos años. Los índices más populares sugeridos para dicha medición son el índice de Banzhaf [1] y el índice de Shapley-Shubik [19]. En su artículo seminal, Shapley [18] consideró juegos coalicionales y la asignación justa de la utilidad obtenida por la gran coalición (la coalición de todos los agentes) a sus miembros. El índice de Shapley-Shubik [19] es la aplicación directa del valor de Shapley a juegos de coalición simples. El índice de Banzhaf surgió directamente del estudio de la votación en los órganos de toma de decisiones. El índice Banzhaf normalizado mide la proporción de coaliciones en las que un jugador es un jugador decisivo, de todas las coaliciones ganadoras. Este índice es similar al índice de Banzhaf discutido en la Sección 1, y se define como: βi = βi(v) k∈N βk. El índice de Banzhaf fue analizado matemáticamente en [3], donde se demostró que esta normalización carece de ciertas propiedades deseables, y se introduce el índice de Banzhaf más natural. Tanto los índices de Shapley-Shubik como los de Banzhaf han sido ampliamente estudiados, y Straffin [20] ha demostrado que cada índice refleja condiciones específicas en un cuerpo de votación. [11] considera estos dos índices junto con varios otros, y describe los axiomas que caracterizan los diferentes índices. La implementación ingenua de un algoritmo para calcular el índice de Banzhaf de un agente i enumera todas las coaliciones que contienen a i. Existen 2n−1 tales coaliciones, por lo que el rendimiento es exponencial en el número de agentes. [12] contiene una encuesta de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Deng y Papadimitriou [2] muestran que calcular el valor de Shapley en juegos de mayoría ponderada es #P-completo, utilizando una reducción de KNAPSACK. Dado que el valor de Shapley de cualquier juego simple tiene el mismo valor que su índice de Shapley-Shubik, esto demuestra que calcular el índice de Shapley-Shubik en juegos de mayoría ponderada es #Pcompleto. Matsui y Matsui [13] han demostrado que calcular tanto los índices de Banzhaf como los de Shapley-Shubik en juegos de votación ponderada es NP-completo. El problema de calcular índices de poder en juegos simples depende de la representación elegida del juego. Dado que el número de posibles coaliciones es exponencial en el número de agentes, calcular índices de poder en tiempo polinómico en el número de agentes solo se puede lograr en dominios específicos. En este documento, hemos considerado el dominio del flujo de red, donde una coalición de agentes debe lograr un flujo más allá de cierto valor. El juego de flujo de red que hemos definido es un juego simple. [10, 9] han considerado un dominio de flujo de red similar, donde cada agente controla un borde de un grafo de flujo de red. Sin embargo, introdujeron un juego no simple, donde el valor que logra una coalición de agentes es el flujo total máximo. Han demostrado que ciertas familias de juegos de flujo de red y juegos similares tienen núcleos no vacíos. 7. CONCLUSIONES Y DIRECCIONES FUTURAS Hemos considerado juegos de flujo de red, donde una coalición de agentes gana si logra enviar un flujo de más de algún valor k entre dos vértices. Hemos evaluado el poder relativo de cada agente en este escenario utilizando el índice de Banzhaf. Este índice de potencia puede ser utilizado para decidir cómo asignar recursos de mantenimiento en redes del mundo real, con el fin de maximizar nuestra capacidad para mantener un cierto flujo de información entre dos sitios. Aunque el índice de Banzhaf teóricamente nos permite medir el poder de los agentes en el juego de flujo de red, hemos demostrado que el problema de calcular el índice de Banzhaf en este dominio es #P-completo. A pesar de este resultado desalentador para el dominio general del flujo de red, también hemos proporcionado un resultado más alentador para un dominio restringido. En el caso de los juegos de conectividad (donde solo se requiere que una coalición contenga un camino desde la fuente hasta el destino) jugados en grafos de capas acotadas, es posible calcular el índice de Banzhaf de un agente en tiempo polinómico. Permanece como un problema abierto encontrar formas de aproximar de manera manejable el índice de Banzhaf en el dominio general de flujo de redes. También podría ser posible encontrar otros dominios restringidos útiles donde sea posible calcular exactamente el índice de Banzhaf. Solo hemos considerado la complejidad de calcular el índice de Banzhaf; sigue siendo un problema abierto encontrar la complejidad de calcular el índice de Shapley-Shubik u otros índices en el dominio del flujo de red. Finalmente, creemos que existen muchos otros dominios interesantes además de los juegos de votación ponderada y los juegos de flujo de red, y sería valioso investigar la complejidad de calcular el índice de Banzhaf u otros índices de poder en dichos dominios. AGRADECIMIENTO Este trabajo fue parcialmente apoyado por la subvención #898/05 de la Fundación para la Ciencia de Israel. 9. REFERENCIAS [1] J. F. Banzhaf. El voto ponderado no funciona: un análisis matemático. Rutgers Law Review, 19:317-343, 1965. [2] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. This is not a complete sentence. Please provide the full sentence you would like me to translate to Spanish. Res., 19(2):257-266, 1994. [3] P. Dubey y L. Shapley. Propiedades matemáticas del índice de poder de Banzhaf. Matemáticas de la Investigación de Operaciones, 4(2):99-131, 1979. [4] E. Ephrati y J. S. Rosenschein. El impuesto Clarke como mecanismo de consenso entre agentes automatizados. En Actas de la Novena Conferencia Nacional de Inteligencia Artificial, páginas 173-178, Anaheim, California, julio de 1991. [5] E. Ephrati y J. S. Rosenschein. Una técnica heurística para la planificación multiagente. Anales de Matemáticas e Inteligencia Artificial, 20:13-67, primavera de 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez y S. Sen. Votación para películas: la anatomía de un sistema de recomendación. En Actas de la Tercera Conferencia Anual sobre Agentes Autónomos, páginas 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora y R. Nadella. Un sistema automatizado de programación de reuniones que utiliza las preferencias del usuario. En Actas de la Primera Conferencia Internacional sobre Agentes Autónomos, páginas 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra y J. Rothe. Cualquiera menos él: La complejidad de excluir una alternativa. En Actas de la 20ª Conferencia Nacional de Inteligencia Artificial, Pittsburgh, julio de 2005. [9] E. Kalai y E. Zemel. Sobre juegos totalmente equilibrados y juegos de flujo. Documentos de discusión 413, Universidad Northwestern, Centro de Estudios Matemáticos en Economía y Ciencias de la Gestión, enero de 1980. Disponible en http://ideas.repec.org/p/nwu/cmsems/413.html. 340 El Sexto Congreso Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) [10] E. Kalai y E. Zemel. Problemas de red generalizados que resultan en juegos totalmente equilibrados. Investigación de Operaciones, 30:998-1008, septiembre de 1982. [11] A. Laruelle. Sobre la elección de un índice de poder. Documentos 99-10, Valencia - Instituto de Investigaciones Económicas, 1999. [12] Y. Matsui y T. Matsui. Un estudio de algoritmos para calcular índices de poder de juegos de mayoría ponderados. Revista de la Sociedad Japonesa de Investigación de Operaciones, 43, 2000. [13] Y. Matsui y T. Matsui. La NP-completitud para calcular índices de poder de juegos de mayoría ponderados. Ciencia de la Computación Teórica, 263(1-2):305-310, 2001. [14] N. Nisan y A. Ronen. Diseño de mecanismos algorítmicos. Juegos y Comportamiento Económico, 35:166-196, 2001. [15] A. D. Procaccia y J. S. Rosenschein. Distribuciones de Junta y la complejidad en el caso promedio de manipular elecciones. En la Quinta Conferencia Internacional Conjunta sobre Agentes Autónomos y Sistemas Multiagente, páginas 497-504, Hakodate, Japón, mayo de 2006. [16] J. S. Rosenschein y M. R. Genesereth. Acuerdos entre agentes racionales. En Actas de la Novena Conferencia Internacional Conjunta sobre Inteligencia Artificial, páginas 91-99, Los Ángeles, California, agosto de 1985. [17] T. Sandholm y V. Lesser. Problemas en la negociación automatizada y el comercio electrónico: Ampliando el marco de la red de contratos. En Actas de la Primera Conferencia Internacional sobre Sistemas Multiagentes (ICMAS-95), páginas 328-335, San Francisco, 1995. [18] L. S. Shapley. Un valor para juegos de n personas. Contribuciones a la Teoría de Juegos, páginas 31-40, 1953. [19] L. S. Shapley y M. Shubik. Un método para evaluar la distribución de poder en un sistema de comités. American Political Science Review, 48:787-792, 1954. [20] P. Straffin.\nRevisión de Ciencia Política Americana, 48:787-792, 1954. [20] P. Straffin. Índices de homogeneidad, independencia y poder. Elección Pública, 30:107-118, 1977. [21] M. Tennenholtz y A. Altman. En el Sexto Congreso Internacional Axiomático. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 341 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "power index": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Computing the Banzhaf <br>power index</br> in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "However, power indices (which reflect how much real power a voter has in a weighted voting system) have received relatively little attention, although they have long been studied in political science and economics.",
                "The Banzhaf <br>power index</br> is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf <br>power index</br> within a particular multiagent domain, a network flow game.",
                "Agents control the edges of a graph; a coalition wins if it can send a flow of a given size from a source vertex to a target vertex.",
                "The relative power of each edge/agent reflects its significance in enabling such a flow, and in real-world networks could be used, for example, to allocate resources for maintaining parts of the network.",
                "We show that calculating the Banzhaf <br>power index</br> of each agent in this network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains there exists a polynomial algorithm to calculate agents Banzhaf power indices.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; J.4 [Computer Applications]: Social and Behavioral SciencesEconomics General Terms Algorithms, Theory, Economics 1.",
                "INTRODUCTION Social choice theory can serve as an appropriate foundation upon which to build multiagent applications.",
                "There is a rich literature on the subject of voting1 from political science, mathematics, and economics, with important theoretical results, and builders of automated agents can benefit from this work as they engineer systems that reach group consensus.",
                "Interest in the theory of economics and social choice has in fact become widespread throughout computer science, because it is recognized as having direct implications on the building of systems comprised of multiple automated agents [16, 4, 22, 17, 14, 8, 15].",
                "What distinguishes computer science work in these areas is its concern for computational issues: how are results arrived at (e.g., equilibrium points)?",
                "What is the complexity of the process?",
                "Can complexity be used to guard against unwanted phenomena?",
                "Does complexity of computation prevent realistic implementation of a technique?",
                "The practical applications of voting among automated agents are already widespread.",
                "Ghosh et al. [6] built a movie recommendation system; a users preferences were represented as agents, and movies to be suggested were selected through agent voting.",
                "Candidates in virtual elections have also been beliefs, joint plans [5], and schedules [7].",
                "In fact, to see the generality of the (automated) voting scenario, consider modern web searching.",
                "One of the most massive preference aggregation schemes in existence is Googles PageRank algorithm, which can be viewed as a vote among indexed web pages on candidates determined by a user-input search string; winners are ranked (Tennenholtz and Altman [21] consider the axiomatic foundations of ranking systems such as this).",
                "In this paper, we consider a topic that has been less studied in the context of automated agent voting, namely power indices.",
                "A <br>power index</br> is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group.",
                "The Banzhaf <br>power index</br> is one of the most popular measures of voting power, and although it has been used primarily for measuring power in weighted voting games, it is well-defined for any simple coalitional game.",
                "We look at some computational aspects of the Banzhaf <br>power index</br> in a specific environment, namely a network flow game.",
                "In this game, a coalition of agents wins if it can send a flow of size k from a source vertex s to a target vertex t, with the relative power of each edge reflecting its significance in allowing such a flow.",
                "We show that calculating the Banzhaf <br>power index</br> of each agent in this general network flow domain is #P-complete.",
                "We also show that for some restricted network flow domains (specifically, of con1 We use the term in its intuitive sense here, but in the social choice literature, preference aggregation and voting are basically synonymous. 335 978-81-904262-7-5 (RPS) c 2007 IFAAMAS nectivity games on bounded layer graphs), there does exist a polynomial algorithm to calculate the Banzhaf <br>power index</br> of an agent.",
                "There are implications in this scenario to real-world networks; for example, the <br>power index</br> might be used to allocate maintenance resources (a more powerful edge being more critical), in order to maintain a given flow of data between two points.",
                "The paper proceeds as follows.",
                "In Section 2 we give some background concerning coalitional games and the Banzhaf <br>power index</br>, and in Section 3 we introduce our specific network flow game.",
                "In Section 4 we discuss the Banzhaf <br>power index</br> in network flow games, presenting our complexity result in the general case.",
                "In Section 5 we consider a restricted case of the network flow game, and present results.",
                "In Section 6 we discuss related work, and we conclude in Section 7. 2.",
                "TECHNICAL BACKGROUND A coalitional game is composed of a set of n agents, I, and a function mapping any subset (coalition) of the agents to a real value v : 2I → R. In a simple coalitional game, v only gets values of 0 or 1 (v : 2I → {0, 1}).",
                "We say a coalition C ⊂ I wins if v(C) = 1, and say it loses if v(C) = 0.",
                "We denote the set of all winning coalitions as W(v) = {C ⊂ 2I |v(C) = 1}.",
                "An agent i is a swinger (or pivot) in a winning coalition C if the agents removal from that coalition would make it a losing coalition: v(C) = 1, v(C \\ {i}) = 0.",
                "A swing is a pair < i, S > such that agent i is a swinger in coalition S. A question that arises in this context is that of measuring the influence a given agent has on the outcome of a simple game.",
                "One approach to measuring the power of individual agents in simple coalitional games is the Banzhaf index. 2.1 The Banzhaf Index A common interpretation of the power an agent possesses is that of its a priori probability of having a significant role in the game.",
                "Different assumptions about the formation of coalitions, and different definitions of having a significant role, have caused researchers to define different power indices, one of the most prominent of which is the Banzhaf index [1].",
                "This index has been widely used, though primarily for the purpose of measuring individual power in a weighted voting system.",
                "However, it can also easily be applied to any simple coalitional game.",
                "The Banzhaf index depends on the number of coalitions in which an agent is a swinger, out of all possible coalitions.2 The Banzhaf index is given by β(v) = (β1(v), ..., βn(v)) where βi(v) = 1 2n−1 S⊂N|i∈S [v(S) − v(S \\ {i})].",
                "Different probabilistic models on the way a coalition is formed yield different appropriate power indices [20].",
                "The Banzhaf <br>power index</br> reflects the assumption that the agents are independent in their choices. 3.",
                "NETWORK FLOW GAMES 3.1 Motivation Consider a communication network, where it is crucial to be able to send a certain amount of information between two sites.",
                "Given limited resources to maintain network links, which edges should get those resources? 2 Banzhaf actually considered the percentage of such coalitions out of all winning coalitions.",
                "This is called the normalized Banzhaf index.",
                "We model this problem by considering a network flow game.",
                "The game consists of agents in a network flow graph, with a certain source vertex s and target vertex t. Each agent controls one of the graphs edges, and a coalition of agents controls all the edges its members control.",
                "A coalition of agents wins the game if it manages to send a flow of at least k from source s to target t, and loses otherwise.",
                "To ensure that the network is capable of maintaining the desired flow between s and t, we may choose to allocate our limited maintenance resources to the edges according to their impact on allowing this flow.",
                "In other words, resources could be devoted to the links whose failure is most likely to cause us to lose the ability to send the required amount of information between the source and target.",
                "Under a reasonable probabilistic model, the Banzhaf index provides us with a measure of the impact each edge has on enabling this amount of information to be sent between the sites, and thus provides a reasonable basis for allocation of scarce maintenance resources. 3.2 Formal Definition Formally, a network flow game is defined as follows.",
                "The game consists of a network flow graph G =< V, E >, with capacities on the edges c : E → R, a source vertex s, a target vertex t, and a set I of agents, where agent i controls the edge ei.",
                "Given a coalition C, which controls the edges EC = {ei|i ∈ C}, we can check whether the coalition allows a flow of k from s to t. We define the simple coalitional game of network flow as the game where the coalition wins if it allows such a flow, and loses otherwise: v(C) = 1 if EC allows a flow of k from s to t; 0 otherwise; A simplified version of the network flow game is the connectivity game; in a connectivity game, a coalition wants to have some path from source to target.",
                "More precisely, a connectivity game is a network flow game where each of the edges has identical capacity, c(e) = 1, and the target flow value is k = 1.",
                "In such a scenario, the goal of a coalition is to have at least one path from s to t: v(C) = 1 if EC contains a path from s to t; 0 otherwise; Given a network flow game (or a connectivity game), we can compute the power indices of the game.",
                "When a coalition of edges is chosen at random, and each coalition is equiprobable, the appropriate index is the Banzhaf index.3 We can use the Banzhaf value of an agent i ∈ I (or the edge it controls, ei), βei (v) = βi(v), to measure its impact on allowing a given flow between s and t. 4.",
                "THE BANZHAF INDEX IN NETWORK FLOW GAMES We now define the problem of calculating the Banzhaf index in the network flow game.",
                "DEFINITION 1.",
                "NETWORK-FLOW-BANZHAF: We are given a network flow graph G =< V, E > with a source vertex s and a target vertex t, a capacity function c : E → R, and a target flow value k. We consider the network flow game, as defined above in Section 3.",
                "We are given an agent i, controlling the edge ei, and are asked to calculate the Banzhaf index for that agent.",
                "In the network 3 When each ordering of edges is equiprobable, the appropriate index is the Shapley-Shubik index. 336 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) flow game, let Cei be the set of all subsets of E that contain ei: Cei = {C ⊂ E|ei ∈ C}.",
                "In this game, the Banzhaf index of ei is: βi(v) = 1 2|E|−1 E ⊂Cei [v(E ) − v(E \\ {ei})].",
                "Let W(Cei ) be the set of winning subsets of edges in Cei , i.e., the subsets E ∈ Cei where a flow of at least k can be sent from s to t using only the edges in E .",
                "The Banzhaf index of ei is the proportion of subsets in W(Cei ) where ei is crucial to maintaining the k-flow.",
                "All the edge subsets in W(Cei ) contain ei and are winning, but only for some of them, E ∈ W(Cei ), do we have that v(E \\ {ei}) = 0 (i.e., E is no longer winning if we remove ei).",
                "The Banzhaf index of ei is the proportion of such subsets. 4.1 #P-Completeness of Calculating the Banzhaf Index in the Network Flow Game We now show that the general case of NETWORK-FLOW-BANZHAF is #P-complete, by a reduction from #MATCHING.",
                "First, we note that NETWORK-FLOW-BANZHAF is in #P. There are several polynomial algorithms to calculate the maximal network flow, so it is easy to check if a certain subset of edges E ⊂ E contains ei and allows a flow of at least k from s to t. It is also easy to check if a flow of at least k is no longer possible when we remove ei from E (again, by running a polynomial algorithm for calculating the maximal flow).",
                "The Banzhaf index of ei is exactly the number of such subsets E ⊂ E, so NETWORK-FLOWBANZHAF is in #P. To show that NETWORK-FLOW-BANZHAF is #P-complete, we reduce a #MATCHING problem4 to a NETWORKFLOW-BANZHAF problem.",
                "DEFINITION 2. #MATCHING: We are given a bipartite graph G =< U, V, E >, such that |U| = |V | = n, and are asked to count the number of perfect matchings possible in G. 4.2 The Overall Reduction Approach The reduction is done as follows.",
                "From the #MATCHING input, G =< U, V, E >, we build two inputs for the NETWORKFLOW-BANZHAF problem.",
                "The difference between the answers obtained from the NETWORK-FLOW-BANZHAF runs is the answer to the #MATCHING problem.",
                "Both runs of the NETWORKFLOW-BANZHAF problem are constructed with the same graph G =< V , E >, with the same source vertex s and target vertex t, and with the same edge ef for which to compute the Banzhaf index.",
                "They differ only in the target flow value.",
                "The first run is with a target flow of k, and the second run is with a target flow of k + .",
                "A choice of subset Ec ⊂ E reflects a possible matching in the original graph.",
                "G is a subgraph of the constructed G .",
                "We identify an edge in G , e ∈ E , with the same edge in G. This edge indicates a particular match between some vertex u ∈ U and another vertex v ∈ V .",
                "Thus, if Ec ⊂ E is a subset of edges in G which contains only edges in the subgraph of G, we identify it with a subset of edges in G, or with some candidate of a matching.",
                "We say Ec ⊂ E matches some vertex v ∈ V , if Ec contains some edge that connects to v, i.e., for some u ∈ U we have (u, v) ∈ Ec.",
                "Ec is a possible matching if it does not match a vertex v ∈ V with more than one vertex in U, i.e., there are not two vertices u1 = u2 in U that both (u1, v) ∈ Ec and (u2, v) ∈ Ec.",
                "A perfect matching matches all the vertices in V .",
                "If Ec fails to match a vertex in V (the right side of the partition), the maximal possible flow that Ec allows in G is less than k. If it matches all the vertices in V , a flow of k is possible.",
                "If it matches 4 This is one of the most well-known #P-complete problems. all the vertices in V , but matches some vertex in V more than once (which means this is not a true matching), a flow of k+ is possible. is chosen so that if a single vertex v ∈ V is unmatched, the maximal possible flow would be less than |V |, even if all the other vertices are matched more than once.",
                "In other words, is chosen so that matching several vertices in V more than once can never compensate for not matching some vertex in V , in terms of the maximal possible flow.",
                "Thus, when we check the Banzhaf index of ef when the required flow is at least k, we get the number of subsets E ⊂ E that match all the vertices in V at least once.",
                "When we check the Banzhaf index of ef with a required flow of at least k+ , we get the number of subsets E ⊂ E that match all the vertices in V at least once, and match at least one vertex v ∈ V more than once.",
                "The difference between the two is exactly the number of perfect matchings in G. Therefore, if there existed a polynomial algorithm for NETWORKFLOW-BANZHAF, we could use it to build a polynomial algorithm for #MATCHING, so NETWORK-FLOW-BANZHAF is #Pcomplete. 4.3 Reduction Details The reduction takes the #MATCHING input, the bipartite graph G =< U, V, E >, where |U| = |V | = k. It then generates a network flow graph G as follows.",
                "The graph G is kept as a subgraph of G , and each edge in G is given a capacity of 1.",
                "A new source vertex s is added, along with a new vertex t and a new target vertex t. Let = 1 k+1 so that · k < 1.",
                "The source s is connected to each of the vertices in U, the left partition of G, with an edge of capacity 1 + .",
                "Each of the vertices in V is connected to t with an edge of capacity 1 + . t is connected to t with an edge ef of capacity 1 + .",
                "As mentioned above, we perform two runs of NETWORK-FLOWBANZHAF, both checking the Banzhaf index of the edge ef in the flow network G .",
                "We denote the network flow game defined on G with target flow k as v(G ,k).",
                "The first run is performed on the game with a target flow of k, v(G ,k), returning the index βef (v(G ,k)).",
                "The second run is performed on the game with a target flow of k + , v(G ,k+ ), returning the index βef (v(G ,k+ )).",
                "The number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "This is proven in Theorem 5.",
                "Figure 1 shows an example of constructing G from G. On the left is the original graph G, and on the right is the constructed network flow graph G . 4.4 Proof of the reduction We now prove that the reduction above is correct.",
                "In all of this section, we take the input to the #MATCHING problem to be G =< U, V, E > with |U| = |V | = k, the network flow graph constructed in the reduction to be G =< V , E > with capacities c : E → R as defined in Section 4.3, the edge for which to calculate the Banzhaf index to be ef , and target flow values of k and k + .",
                "PROPOSITION 1.",
                "Let Ec ⊂ E be a subset of edges that lacks one or more edges of the following: 1.",
                "The edges connected to s; 2.",
                "The edges connected to t ; 3.",
                "The edge ef = (t , t).",
                "We call such a subset a missing subset.",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 337 Figure 1: Reducing #MATCHING to NETWORK-FLOW-BANZHAF PROOF.",
                "The graph is a layer graph, with s being the vertex in the first layer, U the vertices in the second layer, V the vertices in the third, t the vertex in the fourth, and t in the fifth.",
                "Edges in G only go between consecutive layers.",
                "The maximal flow in a layer graph is limited by the total capacity of the edges between every two consecutive layers.",
                "If any of the edges between s and U is missing, the flow is limited by (|V | − 1)(1 + ) < k. If any of the edges between V and t is missing, the flow is also limited by (|V | − 1)(1 + ) < k. If the edge ef is missing, there are no edges going to the last layer, and the maximal flow is 0.",
                "Since such missing subsets of edges do not affect the Banzhaf index of ef (they add 0 to the sum), from now on we will consider only non-missing subsets.",
                "As explained in Section 4.2, we identify the edges in G that were copied from G (the edges between U and V in G ) with their counterparts in G. Each such edge (u, v) ∈ E represents a match between u and v in G. Ec is a perfect matching if it matches every vertex u to a single vertex v and vice versa.",
                "PROPOSITION 2.",
                "Let Ec ⊂ E be a subset of edges that fails to match some vertex v ∈ V .",
                "The maximal flow between s and t using only the edges in the missing subset Ec is less than k. We call such a set sub-matching, and it is not a perfect matching.",
                "PROOF.",
                "If Ec fails to match some vertex v ∈ V , the maximal flow that can reach the vertices in the V layer is (1+ )(k−1) < k, so this is also the maximal flow that can reach t. PROPOSITION 3.",
                "Let Ec ⊂ E be a subset of edges that is a perfect matching in G. Then the maximal flow between s and t using only the edges in Ec is exactly k. PROOF.",
                "A flow of k is possible.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. A flow of more than k is not possible since there are exactly k edges of capacity 1 between the U layer and the V layer, and the maximal flow is limited by the total capacity of the edges between these two consecutive layers.",
                "PROPOSITION 4.",
                "Let Ec ⊂ E be a subset of edges that contains a perfect matching M ⊂ E in G and at least one more edge ex between some vertex ua ∈ U and va ∈ V .",
                "Then the maximal flow between s and t using only the edges in Ec is at least k+ .",
                "We call such a set a super-matching, and it is not a perfect matching.",
                "PROOF.",
                "A flow of k is possible, by using the edges of the perfect match as in Proposition 3.",
                "We send a flow of 1 from s to each of the vertices in U, send a flow of 1 from each vertex u ∈ U to its match v ∈ V , and send a flow of 1 from each v ∈ V to t . t gets a total flow of exactly k, and sends it to t. After using the edges of the perfect matching, we send a flow of from s to ua (this is possible since the capacity of the edge (s, ua) is 1 + and we have only used up 1).",
                "We then send a flow of from ua to va.",
                "This is possible since we have not used this edge at all-it is the edge which is not a part of the perfect matching.",
                "We then send a flow of from va to t .",
                "Again, this is possible since we have used 1 out of the total capacity of 1 + which that edge has.",
                "Now t gets a total flow of k + , and sends it all to t, so we have achieved a total flow of k + .",
                "Thus, the maximal possible flow is at least k + .",
                "THEOREM 5.",
                "Consider a #MATCHING instance G =< U, V, E > reduced to a BANZHAF-NETWORK-FLOW instance G as explained in Section 4.3.",
                "Let v(G ,k) be the network flow game defined on G with target flow k, and v(G ,k+ ) be the game defined with a target flow of k+ .",
                "Let the resulting index of the first run be βef (v(G ,k)), and βef (v(G ,k+ )) be the resulting index of the second run.",
                "Then the number of perfect matchings in G is the difference between the answers in the two runs, βef (v(G ,k)) − βef (v(G ,k+ )).",
                "PROOF.",
                "Consider the game v(G ,k).",
                "According to Proposition 1, in this game, the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 1 to the count for each perfect matching, since such subsets allow a flow of k and are winning.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k (and more than k) and are winning.",
                "Consider the game v(G ,k+ ).",
                "Again, according to Proposition 1, in this game the Banzhaf index of Ef does not count missing subsets Ec ∈ E , since they are losing in this game.",
                "According to Proposition 2, it does not count subsets Ec ∈ E that are submatchings, since they are also losing.",
                "According to Proposition 3, it adds 0 to the count for each perfect matching, since such subsets allow a flow of k but not k + , and are thus losing.",
                "According to Proposition 3, it adds 1 to the count for each super-matching, since such subsets allow a flow of k + and are winning.",
                "Thus the difference between the two indices, βef (v(G ,k)) − βef (v(G ,k+ )), is exactly the number of perfect matchings in G. We have reduced a #MATCHING problem to a NETWORKFLOW-BANZHAF problem.",
                "This means that given a polynomial 338 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) algorithm to calculate the Banzhaf index of an agent in a general network flow game, we can build an algorithm to solve the #MATCHING problem.",
                "Thus, the problem of calculating the Banzhaf index of agents in general network flow games is also #P-complete. 5.",
                "CALCULATING THE BANZHAF INDEX IN BOUNDED LAYER GRAPH CONNECTIVITY GAMES We here present a polynomial algorithm to calculate the Banzhaf index of an edge in a connectivity game, where the network is a bounded layer graph.",
                "This positive result indicates that for some restricted domains of network flow games, it is possible to calculate the Banzhaf index in a reasonable amount of time.",
                "DEFINITION 3.",
                "A layer graph is a graph G =< V, E >, with source vertex s and target vertex t, where the vertices of the graph are partitioned into n + 1 layers, L0 = {s}, L1, ..., Ln = {t}.",
                "The edges run only between consecutive layers.",
                "DEFINITION 4.",
                "A c-bounded layer graph is a layer graph where the number of vertices in each layer is bounded by some constant number c. Although there is no limit on the number of layers in a bounded layer graph, the structure of such graphs makes it possible to calculate the Banzhaf index of edges in connectivity games on such graphs.",
                "The algorithm provided below is indeed polynomial in the number of vertices given that the network is a c-bounded layer graph.",
                "However, there is a constant factor to the running time, which is exponential in c. Therefore, this method is only tractable for graphs where the bound c is small.",
                "Bounded layer graphs may occur in networks when the nodes are located in several ordered segments, where nodes can be connected only between consecutive segments.",
                "Let v be a vertex in layer Li.",
                "We say an edge e occurs before v if it connects two vertices in vs layer or a previous layer: e = (u, w) connects vertex u ∈ Lj to vertex w ∈ Lj+1 and j + 1 ≤ i.",
                "Let Predv ⊂ E be the subset of edges that occur before v. Consider a subset of these edges, E ⊂ Predv.",
                "E may contain a path from s to v, or it may not.",
                "We define Pv as the number of subsets E ⊂ Predv that contain a path from s to v. Similarly, let Vi ∈ V be the subset of all the vertices in the same layer Li.",
                "Let PredVi ⊂ E be the subset of edges that occur before Vi (all the vertices in Vi are in the same layer, so any edge that occurs before some v ∈ Vi occurs before any other vertex w ∈ Vi).",
                "Consider a subset of these edges, E ⊂ PredV .",
                "Let Vi(E ) be the subset of vertices in Vi that are reachable from s using only the edges in E : Vi(E ) = {v ∈ Vi|E contains a path from s to v}.",
                "We say E ∈ PredV connects exactly the vertices in Si ⊂ Vi if all the vertices in Si are reachable from s using the edges in E but no other vertices in Vi are reachable from s using E , so Vi(E ) = Si.",
                "Let V ⊂ Vi be a subset of the vertices in layer Li.",
                "We define PV as the number of subsets E ⊂ PredV that connect exactly the vertices in V : PV = |{E ⊂ PredV |Vi(E ) = V }|.",
                "LEMMA 1.",
                "Let S1, S2 ⊂ Vi where S1 = S2 be two different subsets of vertices in the same layer.",
                "Let E , E ⊂ PredVi be two sets of edge subsets, so that E connects exactly the vertices in S1 and E connects exactly the vertices in S2: Vi(E ) = S1 and Vi(E ) = S2.",
                "Then E and E do not contain the same edges: E = E .",
                "PROOF.",
                "If E = E then both sets of edges allow the same paths from s, so Vi(E ) = Vi(E ).",
                "Let Si ⊂ Vi be a subset of vertices in layer Li.",
                "Let Ei ⊂ E be the set of edges between the vertices in layer Li and layer Li+1.",
                "Let E ⊂ Ei be some subset of these edges.",
                "We denote by Dests(Si, E) the set of vertices in layer Li+1 that are connected to some vertex in Si by an edge in E: Dests(Si, E) = {v ∈ Vi+1|there exists some w ∈ Si and some e ∈ E that e = (w, v)}.",
                "Let Si ⊂ Vi be a subset of vertices in Li and E ⊂ Ei be some subset of the edges between layer Li and layer Li+1.",
                "PSi counts the number of edge subsets in PredVi that connect exactly the vertices in Si.",
                "Consider such a subset E counted in PSi .",
                "E ∪ E is a subset of edges in PredVi+1 that connects exactly to Dest(Si, E).",
                "According to Lemma 1, if we iterate over the different Sis in layer Li, the PSi s count different subsets of edges, and thus every expansion using the edges in E is also different.",
                "Algorithm 1 calculates Pt.",
                "It iterates through the layers, and updates the data for the next layer given the data for the current layer.",
                "For each layer Li and every subset of edges in that layer Si ⊂ Vi, it calculates PSi .",
                "It does so using the values calculated in the previous layer.",
                "The algorithm considers every subset of possible vertices in the current layer, and every possible subset of expanding edges to the next layer, and updates the value of the appropriate subset in the next layer.",
                "Algorithm 1 1: procedure CONNECTING-EXACTLY-SUBSETS(G, v) 2: P{s} ← 1 Initialization 3: for all other subsets of vertices S do Initialization 4: PS ← 0 5: end for 6: for i ← 0 to n − 1 do Iterate through layers 7: for all vertex subsets Si in Li do 8: for all edge subsets E between Li, Li+1 do 9: D ← Dests(Si, E) subset in Li+1 10: PD ← PD + PSi 11: end for 12: end for 13: end for 14: end procedure A c-bounded layer graph contains at most c vertices in each layer, so for each layer there are at most 2c different subsets of vertices in that layer.",
                "There are also at most c2 edges between 2 consecutive layers, and thus at most 2(c2 ) edge subsets between two layers.",
                "If the graph contains k layers, the running time of the algorithm is bounded by k·2c ·2(c2 ) .",
                "Since c is a constant, this is a polynomial algorithm.",
                "Consider the connectivity game on a layer graph G, with a single source vertex s and target vertex t. The Banzhaf index of the edge e is the number of subsets of edges that allow a path between s and t, but do not allow such a path when e is removed (divided by a constant).",
                "We can calculate P{t} = P{t}(G) for G using the algorithm to count the number of subsets of edges that allow a path from s to t. We can then remove e from G to obtain the graph G =< V, E \\ {e} >, and calculate P{t} = P{t}(G ).",
                "The difference P{t}(G) − P{t}(G ) is the number of subsets of edges that contain a path from s to t but no longer contain such a path when e is removed.",
                "The Banzhaf index for e is P{t}(G)−P{t}(G ) 2|E|−1 .",
                "Thus, this algorithm allows us to calculate the Banzhaf index on an edge in the connectivity games on bounded layer graphs.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 339 6.",
                "RELATED WORK Measuring the power of individual players in coalitional games has been studied for many years.",
                "The most popular indices suggested for such measurement are the Banzhaf index [1] and the Shapley-Shubik index [19].",
                "In his seminal paper, Shapley [18] considered coalitional games and the fair allocation of the utility gained by the grand coalition (the coalition of all agents) to its members.",
                "The Shapley-Shubik index [19] is the direct application of the Shapley value to simple coalitional games.",
                "The Banzhaf index emerged directly from the study of voting in decision-making bodies.",
                "The normalized Banzhaf index measures the proportion of coalitions in which a player is a swinger, out of all winning coalitions.",
                "This index is similar to the Banzhaf index discussed in Section 1, and is defined as: βi = βi(v) k∈N βk .",
                "The Banzhaf index was mathematically analyzed in [3], where it was shown that this normalization lacks certain desirable properties, and the more natural Banzhaf index is introduced.",
                "Both the Shapley-Shubik and the Banzhaf indices have been widely studied, and Straffin [20] has shown that each index reflects specific conditions in a voting body. [11] considers these two indices along with several others, and describes the axioms that characterize the different indices.",
                "The naive implementation of an algorithm for calculating the Banzhaf index of an agent i enumerates all coalitions containing i.",
                "There are 2n−1 such coalitions, so the performance is exponential in the number of agents. [12] contains a survey of algorithms for calculating power indices of weighted majority games.",
                "Deng and Papadimitriou [2] show that computing the Shapley value in weighted majority games is #P-complete, using a reduction from KNAPSACK.",
                "Since the Shapley value of any simple game has the same value as its Shapley-Shubik index, this shows that calculating the Shapley-Shubik index in weighted majority games is #Pcomplete.",
                "Matsui and Matsui [13] have shown that calculating both the Banzhaf and Shapley-Shubik indices in weighted voting games is NP-complete.",
                "The problem of computing power indices in simple games depends on the chosen representation of the game.",
                "Since the number of possible coalitions is exponential in the number of agents, calculating power indices in time polynomial in the number of agents can only be achieved in specific domains.",
                "In this paper, we have considered the network flow domain, where a coalition of agents must achieve a flow beyond a certain value.",
                "The network flow game we have defined is a simple game. [10, 9] have considered a similar network flow domain, where each agent controls an edge of a network flow graph.",
                "However, they introduced a non-simple game, where the value a coalition of agents achieves is the maximal total flow.",
                "They have shown that certain families of network flow games and similar games have nonempty cores. 7.",
                "CONCLUSIONS AND FUTURE DIRECTIONS We have considered network flow games, where a coalition of agents wins if it manages to send a flow of more than some value k between two vertices.",
                "We have assessed the relative power of each agent in this scenario using the Banzhaf index.",
                "This <br>power index</br> may be used to decide how to allocate maintenance resources in real-world networks, in order to maximize our ability to maintain a certain flow of information between two sites.",
                "Although the Banzhaf index theoretically allows us to measure the power of the agents in the network flow game, we have shown that the problem of calculating the Banzhaf index in this domain in #P-complete.",
                "Despite this discouraging result for the general network flow domain, we have also provided a more encouraging result for a restricted domain.",
                "In the case of connectivity games (where it is only required for a coalition to contain a path from the source to the destination) played on bounded layer graphs, it is possible to calculate the Banzhaf index of an agent in polynomial time.",
                "It remains an open problem to find ways to tractably approximate the Banzhaf index in the general network flow domain.",
                "It might also be possible to find other useful restricted domains where it is possible to exactly calculate the Banzhaf index.",
                "We have only considered the complexity of calculating the Banzhaf index; it remains an open problem to find the complexity of calculating the Shapley-Shubik or other indices in the network flow domain.",
                "Finally, we believe that there are many additional interesting domains other than weighted voting games and network flow games, and it would be worthwhile to investigate the complexity of calculating the Banzhaf index or other power indices in such domains. 8.",
                "ACKNOWLEDGMENT This work was partially supported by grant #898/05 from the Israel Science Foundation. 9.",
                "REFERENCES [1] J. F. Banzhaf.",
                "Weighted voting doesnt work: a mathematical analysis.",
                "Rutgers Law Review, 19:317-343, 1965. [2] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19(2):257-266, 1994. [3] P. Dubey and L. Shapley.",
                "Mathematical properties of the Banzhaf <br>power index</br>.",
                "Mathematics of Operations Research, 4(2):99-131, 1979. [4] E. Ephrati and J. S. Rosenschein.",
                "The Clarke Tax as a consensus mechanism among automated agents.",
                "In Proceedings of the Ninth National Conference on Artificial Intelligence, pages 173-178, Anaheim, California, July 1991. [5] E. Ephrati and J. S. Rosenschein.",
                "A heuristic technique for multiagent planning.",
                "Annals of Mathematics and Artificial Intelligence, 20:13-67, Spring 1997. [6] S. Ghosh, M. Mundhe, K. Hernandez, and S. Sen. Voting for movies: the anatomy of a recommender system.",
                "In Proceedings of the Third Annual Conference on Autonomous Agents, pages 434-435, 1999. [7] T. Haynes, S. Sen, N. Arora, and R. Nadella.",
                "An automated meeting scheduling system that utilizes user preferences.",
                "In Proceedings of the First International Conference on Autonomous Agents, pages 308-315, 1997. [8] E. Hemaspaandra, L. Hemaspaandra, and J. Rothe.",
                "Anyone but him: The complexity of precluding an alternative.",
                "In Proceedings of the 20th National Conference on Artificial Intelligence, Pittsburgh, July 2005. [9] E. Kalai and E. Zemel.",
                "On totally balanced games and games of flow.",
                "Discussion Papers 413, Northwestern University, Center for Mathematical Studies in Economics and Management Science, Jan. 1980. available at http://ideas.repec.org/p/nwu/cmsems/413.html. 340 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) [10] E. Kalai and E. Zemel.",
                "Generalized network problems yielding totally balanced games.",
                "Operations Research, 30:998-1008, September 1982. [11] A. Laruelle.",
                "On the choice of a <br>power index</br>.",
                "Papers 99-10, Valencia - Instituto de Investigaciones Economicas, 1999. [12] Y. Matsui and T. Matsui.",
                "A survey of algorithms for calculating power indices of weighted majority games.",
                "Journal of the Operations Research Society of Japan, 43, 2000. [13] Y. Matsui and T. Matsui.",
                "NP-completeness for calculating power indices of weighted majority games.",
                "Theoretical Computer Science, 263(1-2):305-310, 2001. [14] N. Nisan and A. Ronen.",
                "Algorithmic mechanism design.",
                "Games and Economic Behavior, 35:166-196, 2001. [15] A. D. Procaccia and J. S. Rosenschein.",
                "Junta distributions and the average-case complexity of manipulating elections.",
                "In The Fifth International Joint Conference on Autonomous Agents and Multiagent Systems, pages 497-504, Hakodate, Japan, May 2006. [16] J. S. Rosenschein and M. R. Genesereth.",
                "Deals among rational agents.",
                "In Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pages 91-99, Los Angeles, California, August 1985. [17] T. Sandholm and V. Lesser.",
                "Issues in automated negotiation and electronic commerce: Extending the contract net framework.",
                "In Proceedings of the First International Conference on Multiagent Systems (ICMAS-95), pages 328-335, San Francisco, 1995. [18] L. S. Shapley.",
                "A value for n-person games.",
                "Contributions to the Theory of Games, pages 31-40, 1953. [19] L. S. Shapley and M. Shubik.",
                "A method for evaluating the distribution of power in a committee system.",
                "American Political Science Review, 48:787-792, 1954. [20] P. Straffin.",
                "Homogeneity, independence and power indices.",
                "Public Choice, 30:107-118, 1977. [21] M. Tennenholtz and A. Altman.",
                "On the axiomatic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 341"
            ],
            "original_annotated_samples": [
                "Computing the Banzhaf <br>power index</br> in Network Flow Games Yoram Bachrach Jeffrey S. Rosenschein School of Engineering and Computer Science The Hebrew University of Jerusalem, Israel {yori,jeff}@cs.huji.ac.il ABSTRACT Preference aggregation is used in a variety of multiagent applications, and as a result, voting theory has become an important topic in multiagent system research.",
                "The Banzhaf <br>power index</br> is one of the most popular; it is also well-defined for any simple coalitional game.",
                "In this paper, we examine the computational complexity of calculating the Banzhaf <br>power index</br> within a particular multiagent domain, a network flow game.",
                "We show that calculating the Banzhaf <br>power index</br> of each agent in this network flow domain is #P-complete.",
                "A <br>power index</br> is a measure of the power that a subgroup, or equivalently a voter in a weighted voting environment, has over decisions of a larger group."
            ],
            "translated_annotated_samples": [
                "Calcular el <br>Índice de Poder</br> de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes.",
                "El <br>índice de poder</br> de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple.",
                "En este artículo, examinamos la complejidad computacional de calcular el <br>índice de poder de Banzhaf</br> dentro de un dominio multiagente particular, un juego de flujo de red.",
                "Mostramos que calcular el <br>índice de poder</br> de Banzhaf de cada agente en este dominio de flujo de red es #P-completo.",
                "Un <br>índice de poder</br> es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande."
            ],
            "translated_text": "Calcular el <br>Índice de Poder</br> de Banzhaf en Juegos de Flujo de Red Yoram Bachrach Jeffrey S. Rosenschein Escuela de Ingeniería e Informática Universidad Hebrea de Jerusalén, Israel {yori,jeff}@cs.huji.ac.il RESUMEN La agregación de preferencias se utiliza en una variedad de aplicaciones multiagentes, y como resultado, la teoría de votación se ha convertido en un tema importante en la investigación de sistemas multiagentes. Sin embargo, los índices de poder (que reflejan cuánto poder real tiene un votante en un sistema de votación ponderada) han recibido relativamente poca atención, aunque han sido estudiados durante mucho tiempo en ciencias políticas y economía. El <br>índice de poder</br> de Banzhaf es uno de los más populares; también está bien definido para cualquier juego de coalición simple. En este artículo, examinamos la complejidad computacional de calcular el <br>índice de poder de Banzhaf</br> dentro de un dominio multiagente particular, un juego de flujo de red. Los agentes controlan los bordes de un grafo; una coalición gana si puede enviar un flujo de un tamaño dado desde un vértice fuente a un vértice destino. El poder relativo de cada borde/agente refleja su importancia en permitir dicho flujo, y en redes del mundo real podría utilizarse, por ejemplo, para asignar recursos para mantener partes de la red. Mostramos que calcular el <br>índice de poder</br> de Banzhaf de cada agente en este dominio de flujo de red es #P-completo. También demostramos que para algunos dominios de flujo de red restringidos existe un algoritmo polinómico para calcular los índices de poder de Banzhaf de los agentes. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; I.2.11 [Inteligencia Artificial]: Inteligencia Artificial DistribuidaSistemas Multiagente; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del ComportamientoEconomía Términos Generales Algoritmos, Teoría, Economía 1. La teoría de la elección social puede servir como una base apropiada sobre la cual construir aplicaciones multiagentes. Existe una amplia literatura sobre el tema del voto en ciencias políticas, matemáticas y economía, con importantes resultados teóricos, y los desarrolladores de agentes automatizados pueden beneficiarse de este trabajo al diseñar sistemas que logren consenso grupal. El interés en la teoría de la economía y la elección social se ha extendido ampliamente en la ciencia de la computación, ya que se reconoce que tiene implicaciones directas en la construcción de sistemas compuestos por múltiples agentes automatizados [16, 4, 22, 17, 14, 8, 15]. Lo que distingue el trabajo de la informática en estas áreas es su preocupación por cuestiones computacionales: ¿cómo se llegan a los resultados (por ejemplo, puntos de equilibrio)? ¿Cuál es la complejidad del proceso? ¿Se puede utilizar la complejidad para protegerse contra fenómenos no deseados? ¿La complejidad de la computación impide la implementación realista de una técnica? Las aplicaciones prácticas de la votación entre agentes automatizados ya son ampliamente utilizadas. Ghosh et al. [6] construyeron un sistema de recomendación de películas; las preferencias de los usuarios se representaron como agentes, y las películas a sugerir se seleccionaron a través de votación de agentes. Los candidatos en elecciones virtuales también han sido creencias, planes conjuntos [5], y horarios [7]. De hecho, para comprender la generalidad del escenario de votación (automatizada), considera la búsqueda web moderna. Uno de los esquemas de agregación de preferencias más masivos que existen es el algoritmo PageRank de Google, que puede ser visto como un voto entre las páginas web indexadas sobre los candidatos determinados por una cadena de búsqueda ingresada por el usuario; los ganadores son clasificados (Tennenholtz y Altman [21] consideran los fundamentos axiomáticos de sistemas de clasificación como este). En este artículo, consideramos un tema que ha sido menos estudiado en el contexto de la votación de agentes automatizados, a saber, los índices de poder. Un <br>índice de poder</br> es una medida del poder que tiene un subgrupo, o equivalente a un votante en un entorno de votación ponderada, sobre las decisiones de un grupo más grande. ",
            "candidates": [],
            "error": [
                [
                    "Índice de Poder",
                    "índice de poder",
                    "índice de poder de Banzhaf",
                    "índice de poder",
                    "índice de poder"
                ]
            ]
        }
    }
}