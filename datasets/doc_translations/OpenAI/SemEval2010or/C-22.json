{
    "id": "C-22",
    "original_text": "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware. The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects. A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system. The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead. Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1. INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications. One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage. Effective adaptation requires detailed and up to date information about both the system and the software itself. Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8]. Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required. For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4]. On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves. With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process. In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them. Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications. This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine. Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3). The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3. Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2. BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain. Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts. At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13]. A runtime is a container process for the management of mobile objects. For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads. The applications themselves comprise mobile objects, which interact with each other through proxies [14]. Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with. Upon migration, proxy objects move with the source object. The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components. Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects. Secondly, MobJeX has a per-application mobile object container called a transport manager (TM). As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case. Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3. METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration. The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated. Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment. It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios. As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation. This subset is listed below and categorised according to metric type. Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1. Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2. Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3. Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec). Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario. As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU. Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack. In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call. Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured. Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service. However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime. The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself. NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer. In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller. In order to collect IT metrics, another additional metric is needed. Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET. The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation. Once the Response Time (RT) is known, IT can derived by subtracting RT from ET. Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e. RT measured in the proxy, ET measured in the method body of the object implementation. In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object). Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there. The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application. To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively. In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load. Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread. Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework. The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection. Note that this containment captures the different granularity of measurement attributes and their corresponding metrics. Consider the case of measuring memory consumption. At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method. As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation. The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level. Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9]. However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process. Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine. Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine). A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9]. Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call. Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive. Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine. Consequently, an abstract representation or model [17] of the system needs to be maintained. Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system. Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects). Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine. The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine. This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not. This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested. These four criteria are described in the following subsections. Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not. This is most useful in the case where it is expensive to measure a particular metric. Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained. Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history. Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer. This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing. A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer. A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery. Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer. Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below. This decision making is facilitated by the notifications received from individual Metric objects as described above. A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity. For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed. A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process. Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer. The purpose of this criterion is twofold. For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved. For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer. Furthermore, this criterion is evaluated using information from two sources. Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target. In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers. Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1. Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers. Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject. This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times. A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent. Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e. TransportManager) have undergone substantial changes. For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push. With shallow push, a list of metrics containers that contain updated metrics is pushed. In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics. In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4. EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead. All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08. The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario. Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system. In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests. The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured. In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine. All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted. Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario. It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear. Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains. Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2. Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach. Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself. In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion. This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation. Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics. These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5]. Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance. The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3. Performance characteristics with simple criteria 5. SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware. Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria. In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy. A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead. While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria. One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push. Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured. Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper. Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6. REFERENCES 1. Katz, R.H., Adaptation and Mobility in Wireless Information Systems. IEEE Personal Communications, 1994. 1: p. 6-17. 2. Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3. Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4. Noble, B.D., et al. Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997. Saint-Malo, France. 5. Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005. Larnaca, Cyprus: SpringerVerlag. 6. Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004. Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8. Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003. Sydney: IEEE. 9. Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005. Como, Italy. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf. Software Engineering (ICSE99). 1999: ACM Press. 13. Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java. Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl. Conference on Distributed Computing Systems. 1986. Cambridge, Mass. (USA): IEEE. 15. Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16. Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., and Bolmsjö, G.S. Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999. Phoenix, Arizona. 18. Waldo, J., Remote Procedure Calls and Java Remote Method Invocation. IEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. and Lin, B. Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994. Toronto, Canada. 20. Henricksen, K. and Indulska, J. A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004. Orlando.",
    "original_translation": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java. Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl. Conferencia sobre Sistemas de Computación Distribuida. 1986. Cambridge, Massachusetts (EE. UU.): IEEE. 15. Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16. Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., y Bolmsjö, G.S. Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999. Phoenix, Arizona. 18. \n\nFénix, Arizona. 18. Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java. IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994. Toronto, Canadá. 20. Henricksen, K. y Indulska, J. Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004. Orlando.",
    "original_sentences": [
        "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
        "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
        "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
        "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
        "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
        "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
        "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
        "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
        "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
        "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
        "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
        "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
        "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
        "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
        "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
        "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
        "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
        "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
        "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
        "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
        "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
        "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
        "A runtime is a container process for the management of mobile objects.",
        "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
        "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
        "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
        "Upon migration, proxy objects move with the source object.",
        "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
        "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
        "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
        "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
        "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
        "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
        "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
        "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
        "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
        "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
        "This subset is listed below and categorised according to metric type.",
        "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
        "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
        "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
        "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
        "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
        "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
        "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
        "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
        "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
        "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
        "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
        "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
        "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
        "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
        "In order to collect IT metrics, another additional metric is needed.",
        "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
        "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
        "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
        "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
        "RT measured in the proxy, ET measured in the method body of the object implementation.",
        "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
        "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
        "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
        "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
        "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
        "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
        "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
        "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
        "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
        "Consider the case of measuring memory consumption.",
        "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
        "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
        "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
        "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
        "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
        "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
        "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
        "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
        "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
        "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
        "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
        "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
        "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
        "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
        "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
        "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
        "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
        "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
        "These four criteria are described in the following subsections.",
        "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
        "This is most useful in the case where it is expensive to measure a particular metric.",
        "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
        "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
        "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
        "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
        "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
        "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
        "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
        "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
        "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
        "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
        "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
        "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
        "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
        "The purpose of this criterion is twofold.",
        "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
        "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
        "Furthermore, this criterion is evaluated using information from two sources.",
        "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
        "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
        "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
        "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
        "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
        "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
        "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
        "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
        "TransportManager) have undergone substantial changes.",
        "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
        "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
        "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
        "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
        "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
        "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
        "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
        "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
        "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
        "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
        "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
        "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
        "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
        "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
        "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
        "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
        "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
        "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
        "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
        "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
        "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
        "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
        "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
        "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
        "Performance characteristics with simple criteria 5.",
        "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
        "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
        "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
        "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
        "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
        "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
        "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
        "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
        "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
        "REFERENCES 1.",
        "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
        "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
        "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
        "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
        "Noble, B.D., et al.",
        "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
        "Saint-Malo, France. 5.",
        "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
        "Larnaca, Cyprus: SpringerVerlag. 6.",
        "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
        "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
        "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
        "Sydney: IEEE. 9.",
        "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
        "Como, Italy. 10.",
        "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
        "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
        "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
        "Software Engineering (ICSE99). 1999: ACM Press. 13.",
        "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
        "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
        "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
        "Conference on Distributed Computing Systems. 1986.",
        "Cambridge, Mass. (USA): IEEE. 15.",
        "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
        "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
        "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
        "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
        "Phoenix, Arizona. 18.",
        "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
        "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
        "Rolia, J. and Lin, B.",
        "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
        "Toronto, Canada. 20.",
        "Henricksen, K. and Indulska, J.",
        "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
        "Orlando."
    ],
    "translated_text_sentences": [
        "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte.",
        "La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles.",
        "Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema.",
        "La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección.",
        "Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1.",
        "INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles.",
        "Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria.",
        "La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo.",
        "Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8].",
        "Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida.",
        "Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4].",
        "Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles.",
        "Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso.",
        "En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente.",
        "Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles.",
        "Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación.",
        "Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3).",
        "El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3.",
        "La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros.",
        "FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado.",
        "Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts.",
        "Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13].",
        "Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles.",
        "Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos.",
        "Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14].",
        "Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos.",
        "Al migrar, los objetos de proxy se mueven con el objeto fuente.",
        "El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales.",
        "En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles.",
        "En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM).",
        "Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general.",
        "Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3.",
        "RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos.",
        "La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente.",
        "Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución.",
        "Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación.",
        "Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos.",
        "Este subconjunto está listado a continuación y categorizado según el tipo de métrica.",
        "Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1.",
        "Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2.",
        "Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3.",
        "Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg).",
        "A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación.",
        "A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU.",
        "El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método.",
        "En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota.",
        "Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad.",
        "De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX.",
        "Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual.",
        "La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo.",
        "NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador.",
        "Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante.",
        "Para recopilar métricas de TI, se necesita otra métrica adicional.",
        "Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET.",
        "El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método.",
        "Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET.",
        "Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir.",
        "RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto.",
        "Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente).",
        "Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí.",
        "El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación.",
        "Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente.",
        "En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual.",
        "Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado.",
        "Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles.",
        "La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección.",
        "Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes.",
        "Considera el caso de medir el consumo de memoria.",
        "A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico.",
        "Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método.",
        "El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos.",
        "Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9].",
        "Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas.",
        "En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación.",
        "En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación).",
        "Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9].",
        "La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local.",
        "Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso.",
        "Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación.",
        "Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17].",
        "Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real.",
        "Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles).",
        "Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación.",
        "La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación.",
        "Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no.",
        "Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban.",
        "Estos cuatro criterios se describen en las siguientes subsecciones.",
        "Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico.",
        "Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular.",
        "Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico.",
        "Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas.",
        "Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas.",
        "Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional.",
        "Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer.",
        "Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas.",
        "Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer.",
        "Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación.",
        "Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente.",
        "Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo.",
        "Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado.",
        "Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación.",
        "Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer.",
        "El propósito de este criterio es doble.",
        "Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local.",
        "Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer.",
        "Además, este criterio se evalúa utilizando información de dos fuentes.",
        "En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino.",
        "En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales.",
        "Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1.",
        "Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales.",
        "Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject.",
        "Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces.",
        "Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre.",
        "Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular.",
        "TransportManager) ha experimentado cambios sustanciales.",
        "Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo.",
        "Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas.",
        "En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios.",
        "En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4.",
        "EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas.",
        "Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08.",
        "Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global.",
        "Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema.",
        "Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas.",
        "El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas.",
        "Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación.",
        "Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación.",
        "La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto.",
        "Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales.",
        "Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación.",
        "Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2.",
        "Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas.",
        "Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo.",
        "Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio.",
        "Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación.",
        "Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas.",
        "Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5].",
        "Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método.",
        "El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3.",
        "Características de rendimiento con criterios simples 5.",
        "RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte.",
        "Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección.",
        "Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta.",
        "Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección.",
        "Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados.",
        "Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas.",
        "Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia.",
        "El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento.",
        "Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6.",
        "REFERENCIAS 1.",
        "Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica.",
        "IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2.",
        "Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3.",
        "Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4.",
        "Noble, B.D., y col.",
        "Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997.",
        "Saint-Malo, Francia. 5.",
        "Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005.",
        "Larnaca, Chipre: SpringerVerlag. 6.",
        "Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004.",
        "Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8.",
        "Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003.",
        "Sídney: IEEE. 9.",
        "Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005.",
        "Como, Italia. 10.",
        "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
        "Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12.",
        "Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional.",
        "Ingeniería de Software (ICSE99). 1999: ACM Press. 13.",
        "Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java.",
        "Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14.",
        "Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl.",
        "Conferencia sobre Sistemas de Computación Distribuida. 1986.",
        "Cambridge, Massachusetts (EE. UU.): IEEE. 15.",
        "Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16.",
        "Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17.",
        "Randell, L.G., Holst, L.G., y Bolmsjö, G.S.",
        "Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999.",
        "Phoenix, Arizona. 18. \n\nFénix, Arizona. 18.",
        "Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java.",
        "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
        "Rolia, J. y Lin, B.",
        "Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994.",
        "Toronto, Canadá. 20.",
        "Henricksen, K. y Indulska, J.",
        "Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004.",
        "Orlando."
    ],
    "error_count": 6,
    "keys": {
        "data": {
            "translated_key": "datos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote <br>data</br> for a remote call being orders of magnitude higher than the cost of pushing and popping <br>data</br> from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and <br>data</br> marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of <br>data</br> in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed <br>data</br>, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) <br>data</br> for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile <br>data</br> Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote <br>data</br> for a remote call being orders of magnitude higher than the cost of pushing and popping <br>data</br> from the method call stack.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and <br>data</br> marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of <br>data</br> in aggregate form rather than sending smaller chunks multiple times.",
                "For reducing the size of pushed <br>data</br>, two types of pushes were considered: shallow push and deep push.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) <br>data</br> for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile <br>data</br> Management 2004. 2004. 4."
            ],
            "translated_annotated_samples": [
                "El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir <br>datos</br> remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar <br>datos</br> de la pila de llamadas del método.",
                "Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de <br>datos</br>, por lo que es más eficiente enviar una cantidad determinada de <br>datos</br> en forma agregada en lugar de enviar fragmentos más pequeños varias veces.",
                "Para reducir el tamaño de los <br>datos</br> enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo.",
                "Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los <br>datos</br> de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2.",
                "Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir <br>datos</br> remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar <br>datos</br> de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de <br>datos</br>, por lo que es más eficiente enviar una cantidad determinada de <br>datos</br> en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los <br>datos</br> enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los <br>datos</br> de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "object-oriented application": {
            "translated_key": "aplicación orientada a objetos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an <br>object-oriented application</br> consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "BACKGROUND In general, an <br>object-oriented application</br> consists of objects collaborating to provide the functionality required by a given problem domain."
            ],
            "translated_annotated_samples": [
                "FONDO En general, una <br>aplicación orientada a objetos</br> consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una <br>aplicación orientada a objetos</br> consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java. Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl. Conferencia sobre Sistemas de Computación Distribuida. 1986. Cambridge, Massachusetts (EE. UU.): IEEE. 15. Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16. Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., y Bolmsjö, G.S. Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999. Phoenix, Arizona. 18. \n\nFénix, Arizona. 18. Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java. IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994. Toronto, Canadá. 20. Henricksen, K. y Indulska, J. Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004. Orlando. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mobile object framework": {
            "translated_key": "marco de objetos móviles",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object framework</br> and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a <br>mobile object framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the <br>mobile object framework</br> such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the <br>mobile object framework</br>.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a <br>mobile object framework</br> and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object framework</br> and supporting middleware.",
                "At a minimum, a <br>mobile object framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the <br>mobile object framework</br> such metrics should actually be measured.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the <br>mobile object framework</br>.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a <br>mobile object framework</br> and supporting middleware."
            ],
            "translated_annotated_samples": [
                "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un <br>marco de objetos móviles</br> y middleware de soporte.",
                "Como mínimo, un <br>marco de objetos móviles</br> con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13].",
                "Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el <br>marco de objetos móviles</br> dichas métricas deben ser medidas en realidad.",
                "Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el <br>marco de objetos móviles</br>.",
                "RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un <br>marco de objetos móviles</br> y middleware de soporte."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un <br>marco de objetos móviles</br> y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un <br>marco de objetos móviles</br> con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el <br>marco de objetos móviles</br> dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el <br>marco de objetos móviles</br>. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un <br>marco de objetos móviles</br> y middleware de soporte. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mobjex": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The <br>mobjex</br> platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of <br>mobjex</br> [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of <br>mobjex</br>, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with <br>mobjex</br>, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system <br>mobjex</br>, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in <br>mobjex</br>) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, <br>mobjex</br> has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, <br>mobjex</br> can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the <br>mobjex</br> framework, is for the most part discussed in generic terms, except where explicitly stated to be <br>mobjex</br> specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the <br>mobjex</br> service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the <br>mobjex</br> containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in <br>mobjex</br> this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the <br>mobjex</br> system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the <br>mobjex</br> framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "The <br>mobjex</br> platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "With the exception of <br>mobjex</br> [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of <br>mobjex</br>, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with <br>mobjex</br>, which can run multiple applications in a single runtime using threads.",
                "The Java based system <br>mobjex</br>, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components."
            ],
            "translated_annotated_samples": [
                "La <br>plataforma MobJeX</br> se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección.",
                "Con la excepción de <br>MobJeX</br> [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso.",
                "En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de <br>métricas de software</br> en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente.",
                "Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de <br>MobJeX</br>, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos.",
                "El sistema basado en Java <br>MobJeX</br>, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La <br>plataforma MobJeX</br> se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de <br>MobJeX</br> [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de <br>métricas de software</br> en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de <br>MobJeX</br>, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java <br>MobJeX</br>, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. ",
            "candidates": [],
            "error": [
                [
                    "plataforma MobJeX",
                    "MobJeX",
                    "métricas de software",
                    "MobJeX",
                    "MobJeX"
                ]
            ]
        },
        "java": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The <br>java</br> based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the <br>java</br> Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running <br>java</br> 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in <br>java</br>. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in <br>java</br>.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The <br>java</br> Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and <br>java</br> Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "The <br>java</br> based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "In the case of Memory Usage (MU), the <br>java</br> Virtual Machine (JVM) [16] is polled for the current memory load.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running <br>java</br> 1.4.2_08.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in <br>java</br>. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in <br>java</br>."
            ],
            "translated_annotated_samples": [
                "El sistema basado en <br>Java</br> MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales.",
                "En el caso del Uso de Memoria (MU), la <br>Máquina Virtual de Java</br> (JVM) [16] es consultada para conocer la carga de memoria actual.",
                "Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08.",
                "Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en <br>Java</br>. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004.",
                "Philippsen, M. y Zenger, M., <br>Java</br>Party - Objetos Remotos Transparentes en <br>Java</br>."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en <br>Java</br> MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la <br>Máquina Virtual de Java</br> (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en <br>Java</br>. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., <br>Java</br>Party - Objetos Remotos Transparentes en <br>Java</br>. ",
            "candidates": [],
            "error": [
                [
                    "Java",
                    "Máquina Virtual de Java",
                    "Java",
                    "Java",
                    "Java"
                ]
            ]
        },
        "metricscontainer": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a <br>metricscontainer</br> with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its <br>metricscontainer</br>.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the <br>metricscontainer</br> for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the <br>metricscontainer</br>.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a <br>metricscontainer</br>.",
                "Since a <br>metricscontainer</br> can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own <br>metricscontainer</br> but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a <br>metricscontainer</br> with individual containers corresponding to functional components in the mobile object framework.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its <br>metricscontainer</br>.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the <br>metricscontainer</br> for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the <br>metricscontainer</br>.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a <br>metricscontainer</br>."
            ],
            "translated_annotated_samples": [
                "Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles.",
                "Notificar Criterio de <br>Contenedor de Métricas</br> - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su <br>Contenedor de Métricas</br>.",
                "Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al <br>MetricsContainer</br> para su procesamiento adicional.",
                "Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el <br>MetricsContainer</br>.",
                "Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un <br>MetricsContainer</br>."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de <br>Contenedor de Métricas</br> - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su <br>Contenedor de Métricas</br>. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al <br>MetricsContainer</br> para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el <br>MetricsContainer</br>. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un <br>MetricsContainer</br>. ",
            "candidates": [],
            "error": [
                [
                    "Contenedor de Métricas",
                    "Contenedor de Métricas",
                    "MetricsContainer",
                    "MetricsContainer",
                    "MetricsContainer"
                ]
            ]
        },
        "metric collection": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the <br>metric collection</br> overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this <br>metric collection</br> approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the <br>metric collection</br> overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Figure 2 shows the <br>metric collection</br> overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this <br>metric collection</br> approach.",
                "These results are encouraging since even for the worst case scenario of n=1 the <br>metric collection</br> overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5]."
            ],
            "translated_annotated_samples": [
                "La Figura 2 muestra el sobrecosto de <br>recolección de métricas</br> en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto.",
                "Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de <br>recolección de métricas</br> en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de <br>recolección de métricas</br>.",
                "Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de <br>recopilación de métricas</br> es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de <br>recolección de métricas</br> en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de <br>recolección de métricas</br> en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de <br>recolección de métricas</br>. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de <br>recopilación de métricas</br> es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java. Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl. Conferencia sobre Sistemas de Computación Distribuida. 1986. Cambridge, Massachusetts (EE. UU.): IEEE. 15. Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16. Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., y Bolmsjö, G.S. Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999. Phoenix, Arizona. 18. \n\nFénix, Arizona. 18. Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java. IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994. Toronto, Canadá. 20. Henricksen, K. y Indulska, J. Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004. Orlando. ",
            "candidates": [],
            "error": [
                [
                    "recolección de métricas",
                    "recolección de métricas",
                    "recolección de métricas",
                    "recopilación de métricas"
                ]
            ]
        },
        "proxy": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, <br>proxy</br> objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the <br>proxy</br> call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the <br>proxy</br>, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the <br>proxy</br>, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a <br>proxy</br> to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the <br>proxy</br>, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the <br>proxy</br> metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a <br>proxy</br> push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the <br>proxy</br> Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Upon migration, <br>proxy</br> objects move with the source object.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the <br>proxy</br> call rather than the method implementation.",
                "RT measured in the <br>proxy</br>, ET measured in the method body of the object implementation.",
                "In the specialised case of the push criterion for the <br>proxy</br>, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a <br>proxy</br> to a mobject."
            ],
            "translated_annotated_samples": [
                "Al migrar, los <br>objetos de proxy</br> se mueven con el objeto fuente.",
                "El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de <br>proxy</br> en lugar de la implementación del método.",
                "RT medido en el <br>proxy</br>, ET medido en el cuerpo del método de implementación del objeto.",
                "En el caso especializado del criterio de empuje para el <br>proxy</br>, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales.",
                "Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un <br>proxy</br> a un mobject."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los <br>objetos de proxy</br> se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de <br>proxy</br> en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el <br>proxy</br>, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el <br>proxy</br>, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un <br>proxy</br> a un mobject. ",
            "candidates": [],
            "error": [
                [
                    "objetos de proxy",
                    "proxy",
                    "proxy",
                    "proxy",
                    "proxy"
                ]
            ]
        },
        "performance and scalability": {
            "translated_key": "rendimiento y la escalabilidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the <br>performance and scalability</br> of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "EVALUATION The preliminary tests presented in this section aim to analyse the <br>performance and scalability</br> of the solution and evaluate the impact on application execution in terms of metrics collection overhead."
            ],
            "translated_annotated_samples": [
                "EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el <br>rendimiento y la escalabilidad</br> de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el <br>rendimiento y la escalabilidad</br> de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java. Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl. Conferencia sobre Sistemas de Computación Distribuida. 1986. Cambridge, Massachusetts (EE. UU.): IEEE. 15. Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16. Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., y Bolmsjö, G.S. Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999. Phoenix, Arizona. 18. \n\nFénix, Arizona. 18. Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java. IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994. Toronto, Canadá. 20. Henricksen, K. y Indulska, J. Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004. Orlando. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "measurement": {
            "translated_key": "medición",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the <br>measurement</br> and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple <br>measurement</br> and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms <br>measurement</br>, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics <br>measurement</br> This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct <br>measurement</br> or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The <br>measurement</br> of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct <br>measurement</br>, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 <br>measurement</br> Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of <br>measurement</br> attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the <br>measurement</br> and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the <br>measurement</br> process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum <br>measurement</br> and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the <br>measurement</br> time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics <br>measurement</br> to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "A key feature of the solution is the specification of multiple configurable criteria to control the <br>measurement</br> and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple <br>measurement</br> and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms <br>measurement</br>, Performance. 1.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics <br>measurement</br> This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct <br>measurement</br> or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "The <br>measurement</br> of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct <br>measurement</br>, however in this case within the mobile object implementation (mobject) itself."
            ],
            "translated_annotated_samples": [
                "Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la <br>medición</br> y propagación de métricas a través del sistema.",
                "La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de <br>medición</br> y propagación para reducir la sobrecarga de recolección.",
                "Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1.",
                "Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de <br>medición</br> directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad.",
                "La <br>medición</br> de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una <br>medición</br> directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la <br>medición</br> y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de <br>medición</br> y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de <br>medición</br> directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La <br>medición</br> de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una <br>medición</br> directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "propagation and delivery": {
            "translated_key": "recopilación, propagación y entrega",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, <br>propagation and delivery</br> of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 <br>propagation and delivery</br> of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 <br>propagation and delivery</br> Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, <br>propagation and delivery</br> of metrics as described in section 3.",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 <br>propagation and delivery</br> of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 <br>propagation and delivery</br> Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine."
            ],
            "translated_annotated_samples": [
                "El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la <br>recopilación, propagación y entrega</br> de métricas, tal como se describe en la Sección 3.",
                "Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas.",
                "La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la <br>recopilación, propagación y entrega</br> de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un marco de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los marcos individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del marco de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el marco de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el marco de objetos móviles. La principal ventaja de agregar métricas en contenedores es que permite que se propaguen fácilmente como una unidad cohesiva a través de los componentes del marco de movilidad para que puedan ser entregadas al motor de adaptación, como se discute en la siguiente subsección. Ten en cuenta que este contenedor captura la diferente granularidad de los atributos de medición y sus métricas correspondientes. Considera el caso de medir el consumo de memoria. A un nivel grueso de granularidad, esto podría medirse para toda una aplicación o incluso un sistema, pero también podría medirse a nivel de un objeto individual; o para un nivel aún más fino de granularidad, el consumo de memoria durante la ejecución de un método específico. Como ejemplo del nivel de granularidad requerido para la adaptación basada en movilidad, el algoritmo de adaptación local propuesto por Ryan y Rossi [9] requiere métricas que representen tanto la duración de la ejecución de un método como el sobrecoste de la invocación de un método. El uso de contenedores de métricas facilita la recopilación de métricas en niveles de granularidad que van desde una sola máquina hasta el nivel individual de los métodos. Ten en cuenta que algunos contenedores de métricas no contienen objetos de métricas, ya que, como se describió anteriormente, la implementación de muestra solo utiliza un subconjunto de las métricas de adaptación de [9]. Sin embargo, por el bien de la consistencia y para promover la flexibilidad en cuanto a la adición de nuevas métricas en el futuro, estos contenedores aún se consideran en el diseño actual por completitud y para trabajos futuros. 3.5 Propagación y Entrega de Métricas La solución en este documento identifica dos etapas en el proceso de recolección y entrega de métricas. En primer lugar, la propagación de métricas a través de los componentes del marco de movilidad y, en segundo lugar, la entrega de esas métricas desde el gestor de host/servicio (o tiempo de ejecución si el gestor de host no está presente) al motor de adaptación. En cuanto a la propagación, en resumen, se propone que cuando un componente del sistema de nivel inferior detecta la llegada de una nueva actualización métrica (por ejemplo, un objeto móvil), la métrica se envía (posiblemente junto con otras métricas relevantes) al siguiente componente de nivel (es decir, el gestor de tiempo de ejecución o transporte que contiene el objeto móvil), que en una etapa posterior, nuevamente determinada por un criterio configurable (por ejemplo, cuando hay un número suficiente de objetos móviles cambiados), se enviará al siguiente componente de nivel (es decir, el gestor de host o el motor de adaptación). Un incentivo adicional para tratar la propagación por separado de la entrega se debe a la distinción entre la adaptación local y global [9]. La adaptación local se realiza mediante un motor que se ejecuta en el host local (por ejemplo, en MobJeX esto ocurriría dentro del servicio) y, por lo tanto, en este caso la fase de entrega sería una llamada interproceso local. Por el contrario, la adaptación global es manejada por un motor de adaptación centralizado que se ejecuta en un host remoto y, por lo tanto, la entrega de métricas se realiza a través de una llamada remota, y en el caso de que existan múltiples entornos de ejecución sin un administrador de host separado, el proceso de entrega sería aún más costoso. Por lo tanto, debido a la presencia de la latencia de comunicación en la red, es importante que el administrador del host pase la mayor cantidad de métricas posible al motor de adaptación en una invocación, lo que implica la necesidad de recopilar estas métricas en el administrador del host, a través de algún tipo de empuje o propagación, antes de enviarlas al motor de adaptación. Por consiguiente, se necesita mantener una representación o modelo abstracto del sistema [17]. Un modelo de este tipo contendría entidades de modelo, correspondientes a cada uno de los componentes principales del sistema, conectados en una jerarquía tipo árbol, que refleja precisamente la estructura y jerarquía de contención del sistema real. Adjuntar contenedores de métricas a entidades de modelo permite que una entidad de modelo que representa a un administrador de host sea entregada al motor de adaptación, lo que le permite acceder a todas las métricas en ese componente y en cualquiera de sus hijos (es decir, tiempos de ejecución y objetos móviles). Además, generalmente se esperaría que un motor de adaptación o controlador del sistema ya mantenga un modelo del sistema que no solo pueda ser reutilizado para la propagación, sino que también proporcione un medio efectivo para entregar información métrica desde el gestor del sistema al motor de adaptación. La relación entre las entidades del modelo y los contenedores de métricas se captura en la Figura 1. 3.6 Criterios de Propagación y Entrega Esta subsección propone criterios flexibles para permitir que cada componente decida cuándo debe propagar sus métricas al siguiente componente en línea (Figura 1), con el fin de reducir la sobrecarga incurrida cuando las métricas se propagan innecesariamente a través de los componentes del marco de movilidad y se entregan al motor de adaptación. Este documento propone cuatro tipos diferentes de criterios que se ejecutan en varias etapas del proceso de medición y propagación para determinar si la siguiente acción debe ser tomada o no. Este enfoque fue diseñado de tal manera que cuando un solo criterio no se cumple, los criterios siguientes no se prueban. Estos cuatro criterios se describen en las siguientes subsecciones. Criterio de Medición Métrica: Este criterio se adjunta a objetos Métricos individuales para decidir si se debe medir o no un nuevo valor métrico. Esto es especialmente útil en el caso en el que resulta costoso medir un métrica en particular. Además, este criterio puede ser utilizado como un mecanismo para limitar los requisitos de almacenamiento y la sobrecarga de manipulación en el caso de que se mantenga un historial métrico. Ejemplos simples podrían ser basados en el tiempo o la frecuencia, mientras que criterios más complejos podrían ser específicos del dominio para una métrica particular, o basados en la información almacenada en el historial de las métricas. Notificar Criterio de Contenedor de Métricas - Este criterio también está adjunto a objetos de Métricas individuales y se utiliza para determinar las circunstancias bajo las cuales el objeto de Métrica debe notificar a su Contenedor de Métricas. Esto se basa en la suposición de que puede haber casos en los que sea deseable medir y almacenar una métrica en el historial para el análisis del comportamiento temporal, pero aún no es lo suficientemente significativa como para notificar al MetricsContainer para su procesamiento adicional. Un ejemplo simple de este criterio sería basado en un umbral, en el cual el valor métrico más reciente se compara con el valor previamente almacenado para determinar si la diferencia es lo suficientemente significativa como para ser de interés para el MetricsContainer. Un criterio más complejo podría implicar el análisis de la historia para determinar si un patrón de cambios recientes es lo suficientemente significativo como para justificar un procesamiento adicional y la entrega de posibles métricas. Notificar Criterio de Entidad de Modelo - A diferencia de los dos criterios anteriores, este criterio está asociado con un MetricsContainer. Dado que un MetricsContainer puede tener varios objetos de Métrica, de los cuales tiene conocimiento explícito del dominio, es capaz de determinar si, cuándo y cuántos de estos métricos deben ser propagados a la ModelEntity y, por lo tanto, convertirse en candidatos para formar parte del proceso de empuje jerárquico de ModelEntity descrito a continuación. Esta toma de decisiones es facilitada por las notificaciones recibidas de los objetos Métricos individuales descritos anteriormente. Una implementación sencilla sería esperar un cierto número de actualizaciones antes de enviar una notificación a la entidad del modelo. Por ejemplo, dado que el objeto MobjectMetricsContainer contiene tres métricas, un criterio posible sería verificar si dos o más de las métricas han cambiado. Una implementación ligeramente más avanzada se puede lograr asignando un peso a cada métrica para indicar cuán significativa es en el proceso de toma de decisiones de adaptación. Criterio de empuje: El criterio de empuje se aplica a todas las ModelEntites que son contenedores, es decir, la TransportManagerModelEntity, RuntimeModelEntity y ServiceModelEntity, así como al caso especial del ProxyMetricsContainer. El propósito de este criterio es doble. Para el TransportManagerModelEntity esto sirve como un criterio para determinar la notificación ya que, al igual que con los criterios previamente descritos, se involucra una referencia local. Para las otras entidades de modelo, esto sirve como una oportunidad para determinar tanto cuándo como qué métricas deben ser enviadas al contenedor padre, donde en el caso de la ServiceModelEntity el padre es el motor de adaptación en sí mismo o en el caso del ProxyMetricsContainer el objetivo del envío es el MobjectMetricsContainer. Además, este criterio se evalúa utilizando información de dos fuentes. En primer lugar, responde a la notificación recibida de su propio MetricsContainer, pero lo más importante es que sirve para hacer un seguimiento de las notificaciones de sus ModelEntities secundarios para determinar cuándo y qué información de métricas debe ser enviada a su padre o destino. En el caso especializado del criterio de empuje para el proxy, la toma de decisiones se basa tanto en el ProxyMetricsContainer en sí mismo, como en la información acumulada de los ProxyMethodMetricsContainers individuales. Se debe tener en cuenta que un criterio de empuje no es necesario para un mobjeto, ya que no tiene ninguna responsabilidad de contención o agregación, ya que esto ya está en el Modelo de Servicio Entidad Servicio Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Tiempo de Ejecución Entidad Tiempo de Ejecución Métricas Contenedor Notificar Modelo de Entidad Criterio Modelo de Gestor de Transporte Entidad Gestor de Transporte Métricas Contenedor Notificar Modelo de Entidad Criterio Criterio de Empuje Mobjeto Modelo de Entidad Mobjeto Método Métricas Notificar Modelo de Entidad Criterio Criterio de Empuje Criterio de Empuje Hacia el motor de adaptación Métricas del contenedor Notificar Métricas del contenedor Criterio Medir Métrica Criterio Métrica 1 Notificar Métricas del contenedor Criterio Notificar Métricas del contenedor Criterio Medir Métrica Criterio Proxy Método Métricas Contenedores RT Métrica Notificar Métricas del contenedor Criterio Proxy Métricas del contenedor Criterio Empuje Medir Métrica Criterio Métrica 2 Medir Métrica Criterio Métrica 1 1..n actualmente no implementado Notificar Métricas del contenedor Criterio Métrica 1 Métrica 2 Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio MU Métrica Medir Métrica Criterio Notificar Métricas del contenedor Criterio ET Métrica IT Métrica NI Métrica Medir Métrica Criterio Medir Métrica Criterio Medir Métrica Criterio Notificar Métricas del contenedor Criterio NU Métrica PU Métrica Medir Métrica Criterio Medir Métrica Criterio 1..n Figura 1. Descripción estructural de las relaciones jerárquicas y basadas en criterios entre Métricas, Contenedores de Métricas y Entidades de Modelo manejadas por el MobjectMetricsContainer y sus MobjectMethodMetricsContainers individuales. Aunque siempre es importante reducir el número de empujes, esto es especialmente importante desde un servicio a un motor de adaptación global centralizado, o desde un proxy a un mobject. Esto se debe a que estas relaciones implican una llamada remota [18] que es costosa debido a la configuración de la conexión y la sobrecarga de empaquetado y desempaquetado de datos, por lo que es más eficiente enviar una cantidad determinada de datos en forma agregada en lugar de enviar fragmentos más pequeños varias veces. Una implementación sencilla para reducir el número de empujes se puede hacer utilizando el concepto de un período de proceso [19], en cuyo caso la entidad del modelo acumula empujes de sus entidades secundarias hasta que el período de proceso expire, momento en el que empuja las métricas acumuladas a su entidad padre. Alternativamente, podría basarse en la frecuencia utilizando el conocimiento del dominio sobre el tipo de niños, por ejemplo, cuando un número significativo de objetos en una aplicación particular. TransportManager) ha experimentado cambios sustanciales. Para reducir el tamaño de los datos enviados, se consideraron dos tipos de envíos: envío superficial y envío profundo. Con un empuje superficial, se empuja una lista de contenedores de métricas que contienen métricas actualizadas. En un empuje profundo, la entidad del modelo en sí es empujada, junto con su contenedor de métricas y sus entidades secundarias, las cuales también tienen referencia a contenedores de métricas pero posiblemente métricas sin cambios. En el caso del proxy, un empuje profundo implica empujar el ProxyMetricsContainer y todos los ProxyMethodMetricsContainers, mientras que un empuje superficial significa solo los ProxyMethodMetricsContainers que cumplen con cierto criterio. 4. EVALUACIÓN Los tests preliminares presentados en esta sección tienen como objetivo analizar el rendimiento y la escalabilidad de la solución, y evaluar el impacto en la ejecución de la aplicación en términos de sobrecarga de recolección de métricas. Todos los tests fueron ejecutados utilizando dos PCs Pentium 4 de 3.0 GHz con 1,024 MB de RAM, ejecutando Java 1.4.2_08. Las dos máquinas estaban conectadas a un enrutador con una tercera computadora actuando como servidor de archivos y alojando el motor de adaptación externo implementado dentro del controlador del sistema MobJeX, simulando así un escenario de adaptación global. Dado que solo se podía ejecutar un número limitado de pruebas, esta evaluación optó por medir el peor escenario en el que se inició la recopilación de todas las métricas en mobjetos, donde el costo de propagación es mayor que para cualquier otra métrica recopilada en el sistema. Además, dado que realizar pruebas exhaustivas de criterios está más allá del alcance de este documento, se utilizaron dos tipos diferentes de criterios en las pruebas. El criterio de medición de métricas fue elegido, ya que esto representa el punto de partida del proceso de medición y puede controlar en qué circunstancias y con qué frecuencia se miden las métricas. Además, el criterio de empuje también se implementó en el servicio, con el fin de proporcionar una evaluación del control de la frecuencia de entrega de métricas al motor de adaptación. Todos los demás criterios (actualizar y enviar) se establecieron para que siempre significara que siempre se evaluaban como verdaderos y, por lo tanto, se publicaba una notificación. La Figura 2 muestra el sobrecosto de recolección de métricas en el mobject (MMCO), para diferentes números de mobjects y métodos cuando todos los criterios están configurados siempre para proporcionar la máxima medición y propagación de métricas y, por lo tanto, un escenario de rendimiento en el peor de los casos absoluto. Se puede observar que los factores independientes de aumentar el número de objetos y métodos de forma independiente son lineales. Aunque combinarlos juntos proporciona un crecimiento exponencial que es aproximadamente n-cuadrado, los resultados iniciales no son desalentadores, ya que entregar todas las métricas asociadas con 20 mobjetos, cada uno con 20 métodos (lo que constituye una aplicación bastante grande dado que los mobjetos suelen representar grupos de objetos de grano grueso) es aproximadamente 400ms, lo cual razonablemente se podría esperar compensar con ganancias de adaptación. Cabe destacar que, en contraste, el sobrecosto de recolección de métricas de proxy (PMCO) era relativamente pequeño y constante, menor a 5 ms, ya que en ausencia de un criterio de empuje de proxy (esto solo se implementó en el servicio), los datos de tiempo de respuesta (RT) para un solo método se empujan durante cada invocación. 50 150 250 350 450 550 1 5 10 15 20 25 Número de Mobjetos/Métodos Sobrecosto de recolección de métricas de Mobjeto MMCO (ms) Métodos Mobjetos Ambos Figura 2. Las características de rendimiento en el peor de los casos. El siguiente paso fue determinar la sobrecarga de recolección de métricas en porcentaje en comparación con el tiempo de ejecución para proporcionar información sobre las características de ejecución de objetos que serían adecuadas para la adaptación utilizando este enfoque de recolección de métricas. Claramente, no es práctico medir métricas y realizar adaptaciones en objetos con tiempos de ejecución cortos que no pueden beneficiarse de la ejecución remota en hosts con mayor capacidad de procesamiento, compensando así los costos operativos de TI de la ejecución remota en comparación con la local, así como el costo de la migración de objetos y el proceso de recolección de métricas en sí mismo. Además, para demostrar el efecto de utilizar criterios simples basados en frecuencia, los resultados de MMCO como porcentaje del tiempo de ejecución del método se representaron en un gráfico tridimensional en la Figura 3, donde el eje z representa la frecuencia utilizada tanto en el criterio de medición de métricas como en el criterio de empuje del motor de adaptación al servicio. Esto significa que para un valor de frecuencia de 5 (n=5), las métricas solo se miden en cada quinta llamada al método, lo que luego resulta en una notificación a través de la jerarquía de entidades del modelo al servicio, en esta misma quinta invocación. Además, el valor de n=5 también se aplicó al criterio de empuje de servicio para que las métricas solo se enviaran al motor de adaptación después de cinco notificaciones de este tipo, es decir, por ejemplo, cinco mobjects diferentes habían actualizado sus métricas. Estos resultados son alentadores, ya que incluso para el peor escenario de n=1, el sobrecoste de recopilación de métricas es aceptable, siendo del 20% para un método de duración de 1500ms (que es relativamente corto para un componente u objeto de nivel de servicio en una aplicación de clase empresarial distribuida), con trabajos previos sobre adaptación que muestran que dicho sobrecoste podría recuperarse fácilmente mediante las ganancias de eficiencia logradas por la adaptación [5]. Además, el tiempo de medición incluye la entrega de los resultados de forma síncrona a través de una llamada remota al motor de adaptación en un host diferente, lo cual normalmente se haría de forma asíncrona, reduciendo así aún más el impacto en el rendimiento de la ejecución del método. El gráfico también demuestra que incluso al utilizar criterios modestos para reducir la medición de métricas a niveles más realistas, tiene una mejora rápida en la sobrecarga de recolección al 20% durante 500 ms de ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milisegundos) N (intervalo) MMCO (%) Figura 3. Características de rendimiento con criterios simples 5. RESUMEN Y CONCLUSIONES Dadas las dificultades de desarrollar aplicaciones móviles que se ejecuten en entornos dinámicos/heterogéneos, y el interés posterior en la adaptación de aplicaciones, este documento ha propuesto e implementado una estrategia de recopilación de métricas en línea para ayudar a dicha adaptación utilizando un marco de objetos móviles y middleware de soporte. Se realizaron estudios de laboratorio controlados para determinar el rendimiento en el peor de los casos, así como para mostrar la reducción en los costos de recolección al aplicar criterios simples de recolección. Además, pruebas adicionales proporcionaron una indicación inicial de las características de los objetos de aplicación (basadas en el tiempo de ejecución del método) que serían buenos candidatos para adaptación utilizando la implementación del peor caso de la estrategia de recopilación de métricas propuesta. Una característica clave de la solución fue la especificación de múltiples criterios configurables para controlar la propagación de métricas a través del sistema, reduciendo así la sobrecarga de recolección. Si bien la eficacia potencial de este enfoque se probó utilizando criterios simples, dada la flexibilidad del enfoque, creemos que hay muchas oportunidades para reducir significativamente los costos de recolección mediante el uso de criterios más sofisticados. Un enfoque podría basarse en mantener un historial de métricas para determinar el comportamiento temporal de las métricas y así tomar decisiones más inteligentes y conservadoras sobre si un cambio en una métrica en particular es probable que sea de interés para el motor de adaptación y, por lo tanto, debería servir como base para la notificación para su inclusión en la próxima actualización de métricas. Además, tal historial temporal también podría facilitar decisiones inteligentes con respecto a la recopilación de métricas, ya que, por ejemplo, una métrica que se sabe que es en su mayoría constante no necesita ser medida con frecuencia. El trabajo futuro también implicará la evaluación de una amplia gama de escenarios de adaptación en el marco de MobJeX para cuantificar las ganancias que se pueden obtener mediante la adaptación a través de la movilidad de objetos y así demostrar en la práctica la eficacia de la solución descrita en este documento. Finalmente, los autores desean explorar la aplicación de los conceptos de recopilación de métricas descritos en este documento a un sistema de gestión de contexto más general y reutilizable [20]. 6. REFERENCIAS 1. Katz, R.H., Adaptación y Movilidad en Sistemas de Información Inalámbrica. IEEE Comunicaciones Personales, 1994. 1: p. 6-17. 2. Hirschfeld, R. y Kawamura, K. Adaptación Dinámica del Servicio. en ICDCS Workshops04. 2004. 3. Lemlouma, T. y Layaida, N. Adaptación Consciente del Contexto para Dispositivos Móviles. en Actas de la Conferencia Internacional de IEEE sobre Gestión de Datos Móviles 2004. 2004. 4. Noble, B.D., y col. Adaptación ágil y consciente de la aplicación para la movilidad. en Proc. del 16º Simposio de la ACM sobre Sistemas Operativos y Principios SOSP. 1997. Saint-Malo, Francia. 5. Rossi, P. y Ryan, C. Una Evaluación Empírica de la Adaptación Local Dinámica para Aplicaciones Móviles Distribuidas. en Actas del Simposio Internacional de 2005 sobre Objetos y Aplicaciones Distribuidas (DOA 2005). 2005. Larnaca, Chipre: SpringerVerlag. 6. Ryan, C. y Westhorpe, C. Adaptación de aplicaciones a través de la movilidad de objetos transparente y portátil en Java. en el Simposio Internacional sobre Objetos y Aplicaciones Distribuidas (DOA 2004). 2004. Larnaca, Chipre: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M. y Kon, F. Desarrollo de Aplicaciones Distribuidas Adaptativas: Una Visión General del Marco y Resultados Experimentales. en On The Move to Meaningful Internet Systems 2003: CoopIS, DOA y ODBASE (LNCS 2888). 2003. 8. Rossi, P. y Fernández, G. Definición y validación de métricas de diseño para aplicaciones distribuidas. en el Noveno Simposio Internacional de Métricas de Software. 2003. Sídney: IEEE. 9. Ryan, C. y Rossi, P. Métricas de software, rendimiento y utilización de recursos para aplicaciones móviles conscientes del contexto. en Actas del Simposio Internacional de Métricas de Software IEEE Metrics 2005. 2005. Como, Italia. 10. Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. \n\nRecursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11. Holder, O., Ben-Shaul, I., y Gazit, H., Soporte del sistema para el diseño dinámico de aplicaciones distribuidas. 1998, Instituto de Tecnología Technion-Israel. p. 163 - 173. 12. Holder, O., Ben-Shaul, I., y Gazit, H. Diseño dinámico de aplicaciones distribuidas en FarGo. en la 21ª Conferencia Internacional. Ingeniería de Software (ICSE99). 1999: ACM Press. 13. Philippsen, M. y Zenger, M., JavaParty - Objetos Remotos Transparentes en Java. Concurrencia: Práctica y Experiencia, 1997. 9(11): p. 1225-1242. 14. Shapiro, M. Estructura y Encapsulamiento en Sistemas Distribuidos: el Principio del Proxy. en Proc. 6to Intl. Conferencia sobre Sistemas de Computación Distribuida. 1986. Cambridge, Massachusetts (EE. UU.): IEEE. 15. Gazit, H., Ben-Shaul, I., y Holder, O. Reubicación dinámica basada en monitoreo de componentes en Fargo. en Actas del Segundo Simposio Internacional sobre Sistemas de Agentes y Aplicaciones y Cuarto Simposio Internacional sobre Agentes Móviles. 2000. 16. Lindholm, T. y Yellin, F., Especificación de la Máquina Virtual de Java 2da Edición. 1999: Addison-Wesley. 17. Randell, L.G., Holst, L.G., y Bolmsjö, G.S. Desarrollo Incremental de Sistemas de Modelado de Simulación de Eventos Discretos a Gran Escala. en Actas de la 31ª conferencia sobre Simulación de Invierno. 1999. Phoenix, Arizona. 18. \n\nFénix, Arizona. 18. Waldo, J., Llamadas a Procedimientos Remotos y Invocación de Métodos Remotos en Java. IEEE Concurrency, 1998. 6(3): p. 5-7. 19.\nIEEE Concurrency, 1998. 6(3): p. 5-7. 19. Rolia, J. y Lin, B. Problemas de consistencia en las métricas de rendimiento de aplicaciones distribuidas. en Actas de la Conferencia de 1994 del Centro de Estudios Avanzados sobre Investigación Colaborativa. 1994. Toronto, Canadá. 20. Henricksen, K. y Indulska, J. Un marco de ingeniería de software para la computación pervasiva consciente del contexto. en Actas de la 2ª Conferencia de IEEE sobre Computación y Comunicaciones Pervasivas (PerCom). 2004. Orlando. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "framework": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object <br>framework</br> and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object <br>framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX <br>framework</br>, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object <br>framework</br> such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object <br>framework</br>.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility <br>framework</br> so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility <br>framework</br> and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility <br>framework</br> and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a mobile object <br>framework</br> and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX <br>framework</br> to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A <br>framework</br> Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering <br>framework</br> for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a mobile object <br>framework</br> and supporting middleware.",
                "At a minimum, a mobile object <br>framework</br> with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "The solution, although implemented within the MobJeX <br>framework</br>, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object <br>framework</br> such metrics should actually be measured.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object <br>framework</br>."
            ],
            "translated_annotated_samples": [
                "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un <br>marco de objetos móviles</br> y middleware de soporte.",
                "Como mínimo, un <br>marco</br> de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los <br>marco</br>s individuales puede diferir [6, 10-13].",
                "La solución, aunque implementada dentro del <br>marco</br> de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente.",
                "Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el <br>marco</br> de objetos móviles dichas métricas deben ser medidas en realidad.",
                "Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el <br>marco de objetos</br> móviles."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un <br>marco de objetos móviles</br> y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de objetos móviles existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de objetos móviles y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de objetos móviles típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. Además, en algunos casos, la ubicación donde se debe recopilar cada métrica no está fija (es decir, podría hacerse en varios lugares) y, por lo tanto, se debe tomar una decisión basada en la eficiencia de la solución elegida (ver sección 3). El resto de este documento está organizado de la siguiente manera: La Sección 2 describe la estructura general y la implementación de marcos de objetos móviles para comprender los desafíos relacionados con la recopilación, propagación y entrega de métricas, tal como se describe en la Sección 3. La sección 4 describe algunas pruebas iniciales y resultados, y la sección 5 concluye con un resumen, conclusiones y discusión sobre trabajos futuros. FONDO En general, una aplicación orientada a objetos consiste en objetos que colaboran para proporcionar la funcionalidad requerida por un dominio de problema dado. Los marcos de objetos móviles permiten que algunos de estos objetos sean etiquetados como objetos móviles, brindando soporte de middleware para que dichos objetos puedan ser movidos en tiempo de ejecución a otros hosts. Como mínimo, un <br>marco</br> de objetos móviles con al menos una aplicación móvil en ejecución consta de los siguientes componentes: tiempos de ejecución, objetos móviles y proxies [14], aunque la terminología utilizada por los <br>marco</br>s individuales puede diferir [6, 10-13]. Un tiempo de ejecución es un proceso contenedor para la gestión de objetos móviles. Por ejemplo, en FarGo [15] este componente es conocido como núcleo y en la mayoría de los sistemas se requieren tiempos de ejecución separados para permitir que diferentes aplicaciones se ejecuten de forma independiente, aunque este no es el caso de MobJeX, que puede ejecutar múltiples aplicaciones en un solo tiempo de ejecución utilizando hilos. Las aplicaciones en sí mismas comprenden objetos móviles, los cuales interactúan entre sí a través de proxies [14]. Se requieren proxies para cada objeto de destino con el que un objeto fuente se comunica, los cuales tienen la misma interfaz de método que el objeto en sí pero añaden funcionalidad de comunicación remota y seguimiento de objetos. Al migrar, los objetos de proxy se mueven con el objeto fuente. El sistema basado en Java MobJeX, que se utiliza como plataforma de implementación para la solución de recopilación de métricas descrita en este documento, agrega una serie de componentes de middleware adicionales. En primer lugar, un administrador de host (conocido como un servicio en MobJeX) proporciona un punto central de comunicación al ejecutarse en un puerto conocido por host, facilitando así la enumeración o búsqueda de componentes como tiempos de ejecución u objetos móviles. En segundo lugar, MobJeX tiene un contenedor de objetos móviles por aplicación llamado gestor de transporte (TM). Por lo tanto, los administradores de host y transporte se consideran en la solución proporcionada en la siguiente sección, pero podrían omitirse en el caso general. Finalmente, dependiendo del modo de adaptación, MobJeX puede tener un controlador de sistema centralizado que incorpora un motor de adaptación global para realizar una optimización en todo el sistema. 3. RECOLECCIÓN DE MÉTRICAS Esta sección discute el diseño y la derivación de una solución para recolectar métricas con el fin de apoyar la adaptación de aplicaciones a través de la migración de objetos. La solución, aunque implementada dentro del <br>marco</br> de MobJeX, se discute en su mayor parte en términos genéricos, excepto cuando se indica explícitamente que es específica de MobJeX. 3.1 Selección de Métricas Se han elegido las métricas de Ryan y Rossi [9] como base para esta solución, ya que están específicamente destinadas a la adaptación de aplicaciones móviles y han sido derivadas de una serie de modelos matemáticos y validadas empíricamente. Además, se demostró empíricamente que las métricas mejoraron el rendimiento de la aplicación en un escenario real de adaptación tras un cambio en el entorno de ejecución. Sin embargo, estaría fuera del alcance de este documento implementar y probar el conjunto completo de métricas enumeradas en [9], por lo que, con el fin de proporcionar un subconjunto no aleatorio útil, elegimos implementar el conjunto mínimo de métricas necesarias para llevar a cabo la adaptación local y global [9] y así satisfacer una variedad de escenarios reales de adaptación. Por lo tanto, la solución presentada en esta sección se discute principalmente en términos de estas métricas, aunque la estructura de la solución está destinada a apoyar la implementación de las métricas restantes, así como otras métricas no especificadas como aquellas relacionadas con la calidad y la utilización de recursos. Este subconjunto está listado a continuación y categorizado según el tipo de métrica. Se debe tener en cuenta que se utilizaron métricas adicionales con fines de implementación para derivar métricas fundamentales o asistir en la evaluación, y por lo tanto se definen en el contexto correspondiente cuando sea apropiado. 1. Métricas de software - Número de Invocaciones (NI), la frecuencia de invocaciones en los métodos de una clase. 2. Métricas de rendimiento - Tiempo de ejecución del método (ET), el tiempo tomado para ejecutar el cuerpo de un método (ms). - Tiempo de invocación del método (IT), el tiempo tomado para invocar un método, excluyendo el tiempo de ejecución del método (ms). 3. Métricas de utilización de recursos: Uso de memoria (MU), el uso de memoria de un proceso (en bytes). - Uso del procesador (PU), el porcentaje de la carga de la CPU de un host. - Uso de red (NU), el ancho de banda de red entre dos hosts (en bytes/seg). A continuación se presentan breves ejemplos de varios de estos indicadores para demostrar su uso en un escenario de adaptación. A medida que el Uso del Procesador (PU) en un determinado host aumenta, el Tiempo de Ejecución (ET) de un método dado ejecutado en ese host también aumenta [9], facilitando así la decisión de si mover un objeto con un alto ET a otro host con bajo PU. El Tiempo de Invocación (IT) muestra el sobrecosto de invocar un método específico, siendo el sobrecosto de invocación de empaquetar parámetros y transmitir datos remotos para una llamada remota varias órdenes de magnitud más alto que el costo de empujar y sacar datos de la pila de llamadas del método. En otras palabras, la invocación de métodos remotos es costosa y, por lo tanto, se debe evitar a menos que las ganancias obtenidas al mover un objeto a un host con más potencia de procesamiento (y así reducir el tiempo de ejecución) superen el mayor tiempo de invocación remota. Finalmente, el Número de Invocaciones (NI) se utiliza principalmente como un factor de ponderación o multiplicador para permitir que el motor de adaptación prediga el valor a lo largo del tiempo de una decisión de adaptación particular. 3.2 Medición de Métricas Esta subsección discute cómo se pueden obtener cada una de las métricas en el subconjunto bajo investigación en términos de medición directa o derivación, y dónde en el <br>marco</br> de objetos móviles dichas métricas deben ser medidas en realidad. De las métricas de recursos ambientales, el Uso del Procesador (PU) y el Uso de la Red (NU) están relacionados con una máquina individual, y por lo tanto pueden medirse directamente a través del subsistema de monitoreo de recursos que se instancia como parte del servicio MobJeX. Sin embargo, el Uso de Memoria (MU), que representa el estado de la memoria de un proceso en ejecución en lugar del uso de memoria de un host, debería ser recopilado dentro de un tiempo de ejecución individual. La medición de las métricas de Número de Invocaciones (NI) y Tiempo de Ejecución (ET) también se puede realizar a través de una medición directa, sin embargo, en este caso dentro de la implementación del objeto móvil (mobject) en sí mismo. NI implica simplemente incrementar un valor de contador al principio o al final de una llamada de método, dependiendo de la semántica deseada con respecto a las excepciones lanzadas, mientras que ET se puede medir comenzando un temporizador al principio del método y deteniéndolo al final del método, luego recuperando la duración registrada por el temporizador. Por el contrario, la recolección del Tiempo de Invocación (TI) no es tan directa, ya que el tiempo tomado para invocar un método solo se puede medir después de que el método termine su ejecución y regrese al llamante. Para recopilar métricas de TI, se necesita otra métrica adicional. Ryan y Rossi [9] definen el tiempo de respuesta métrico (RT), como el tiempo total que tarda una llamada a un método en finalizar, que es la suma de IT y ET. El Tiempo de Respuesta se puede medir directamente utilizando la misma técnica basada en temporizador que se utiliza para medir ET, aunque al inicio y al final de la llamada de proxy en lugar de la implementación del método. Una vez que se conoce el Tiempo de Respuesta (RT), se puede obtener el Tiempo de Ejecución (ET) restando RT de ET. Aunque esta derivación parece simple, en la práctica se complica por el hecho de que los valores de RT y ET a partir de los cuales se deriva el IT necesariamente se miden utilizando código de temporizador en diferentes ubicaciones, es decir. RT medido en el proxy, ET medido en el cuerpo del método de implementación del objeto. Además, los proxies no forman parte de la jerarquía de contención de MobJeX por definición, ya que aunque los proxies tienen una referencia a su objeto objetivo, no es eficiente que un objeto móvil (mobject) tenga referencias inversas a todos los numerosos proxies que lo referencian (uno por objeto fuente). Afortunadamente, este problema se puede resolver utilizando el mecanismo de propagación basado en push descrito en la sección 3.5, en el cual la métrica RT se empuja al mobjeto para que IT pueda derivarse del valor ET almacenado allí. El valor derivado de TI se almacena y se propaga según sea necesario de acuerdo con los criterios de la sección 3.6, cuya relación estructural se muestra en la Figura 1. 3.3 Inicio de la Medición Se identificó el enfoque de encuesta como el método más apropiado para recopilar métricas de utilización de recursos, como el Uso del Procesador (PU), Uso de la Red (NU) y Uso de la Memoria (MU), ya que no forman parte ni están relacionados con el flujo directo de la aplicación. Para medir PU o NU, el monitor de recursos sondea el Sistema Operativo para obtener la carga actual de la CPU o la red respectivamente. En el caso del Uso de Memoria (MU), la Máquina Virtual de Java (JVM) [16] es consultada para conocer la carga de memoria actual. Ten en cuenta que para minimizar el impacto en el tiempo de respuesta de la aplicación, la acción de sondeo debe realizarse de forma asíncrona en un hilo separado. Las métricas que son adecuadas para la recolección iniciada por la aplicación (es decir, como parte de una llamada de método normal) son métricas relacionadas con el software y el rendimiento, como el Número de Invocaciones (NI), Tiempo de Ejecución (ET) y Tiempo de Invocación (IT), que están explícitamente relacionadas con la invocación normal de un método, y por lo tanto pueden medirse directamente en este momento. 3.4 Agregación de Métricas En la solución presentada en este documento, todas las métricas recolectadas en el mismo lugar se agregan en un Contenedor de Métricas con contenedores individuales correspondientes a componentes funcionales en el <br>marco de objetos</br> móviles. ",
            "candidates": [],
            "error": [
                [
                    "marco de objetos móviles",
                    "marco",
                    "marco",
                    "marco",
                    "marco",
                    "marco de objetos"
                ]
            ]
        },
        "adaptation": {
            "translated_key": "adaptación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported <br>adaptation</br> of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application <br>adaptation</br> via object mobility using a mobile object framework and supporting middleware.",
                "The solution is based upon an abstract representation of the mobile object system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application <br>adaptation</br> [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective <br>adaptation</br> requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing <br>adaptation</br> is dependent upon the type of <br>adaptation</br> required.",
                "For example, service-based <br>adaptation</br>, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, <br>adaptation</br> via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing mobile object systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated <br>adaptation</br>, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an <br>adaptation</br> engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in mobile object frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support <br>adaptation</br> via object mobility for mobile applications.",
                "This problem is non-trivial since typical mobile object frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the <br>adaptation</br> engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of mobile object frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "Mobile object frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a mobile object framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application mobile object container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on <br>adaptation</br> mode, MobJeX can have a centralised system controller incorporating a global <br>adaptation</br> engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the <br>adaptation</br> of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application <br>adaptation</br> as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real <br>adaptation</br> scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global <br>adaptation</br> [9] and thereby satisfy a range of real <br>adaptation</br> scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an <br>adaptation</br> scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the <br>adaptation</br> engine to predict the value over time of a particular <br>adaptation</br> decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the mobile object framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the mobile object implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a mobile object (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the mobile object framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the <br>adaptation</br> engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based <br>adaptation</br>, the local <br>adaptation</br> algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the <br>adaptation</br> metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the <br>adaptation</br> engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. mobile object), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the mobile object), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the <br>adaptation</br> engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global <br>adaptation</br> [9].",
                "Local <br>adaptation</br> is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global <br>adaptation</br> is handled by a centralised <br>adaptation</br> engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the <br>adaptation</br> engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the <br>adaptation</br> engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the <br>adaptation</br> engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an <br>adaptation</br> engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the <br>adaptation</br> engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the <br>adaptation</br> engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the <br>adaptation</br> decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the <br>adaptation</br> engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To <br>adaptation</br> engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global <br>adaptation</br> engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external <br>adaptation</br> engine implemented within the MobJeX system controller, thereby simulating a global <br>adaptation</br> scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the <br>adaptation</br> engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with <br>adaptation</br> gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for <br>adaptation</br> using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform <br>adaptation</br> on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to <br>adaptation</br> engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the <br>adaptation</br> engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on <br>adaptation</br> showing that such an overhead could easily be recovered by the efficiency gains made by <br>adaptation</br> [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the <br>adaptation</br> engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application <br>adaptation</br>, this paper has proposed and implemented an online metrics collection strategy to assist such <br>adaptation</br> using a mobile object framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for <br>adaptation</br> using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the <br>adaptation</br> engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of <br>adaptation</br> scenarios on the MobJeX framework to quantity the gains that can be made via <br>adaptation</br> through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., <br>adaptation</br> and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service <br>adaptation</br>. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware <br>adaptation</br> for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware <br>adaptation</br> for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local <br>adaptation</br> for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application <br>adaptation</br> through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Runtime Metrics Collection for Middleware Supported <br>adaptation</br> of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application <br>adaptation</br> via object mobility using a mobile object framework and supporting middleware.",
                "One solution which is receiving increasing attention in the research community is application <br>adaptation</br> [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective <br>adaptation</br> requires detailed and up to date information about both the system and the software itself.",
                "Furthermore, the type of metrics required for performing <br>adaptation</br> is dependent upon the type of <br>adaptation</br> required.",
                "For example, service-based <br>adaptation</br>, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4]."
            ],
            "translated_annotated_samples": [
                "Recopilación de métricas en tiempo de ejecución para la <br>adaptación</br> de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la <br>adaptación</br> de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte.",
                "Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la <br>adaptación</br> de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria.",
                "La <br>adaptación</br> efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo.",
                "Además, el tipo de métricas necesarias para realizar la <br>adaptación</br> depende del tipo de <br>adaptación</br> requerida.",
                "Por ejemplo, la <br>adaptación</br> basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la <br>adaptación</br> de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la <br>adaptación</br> de aplicaciones a través de la movilidad de objetos utilizando un marco de objetos móviles y middleware de soporte. La solución se basa en una representación abstracta del sistema de objetos móviles, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los objetos móviles. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la <br>adaptación</br> de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La <br>adaptación</br> efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la <br>adaptación</br> depende del tipo de <br>adaptación</br> requerida. Por ejemplo, la <br>adaptación</br> basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mobile object": {
            "translated_key": "objetos móviles",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object</br> framework and supporting middleware.",
                "The solution is based upon an abstract representation of the <br>mobile object</br> system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "A key feature of the solution is the specification of multiple configurable criteria to control the measurement and propagation of metrics through the system.",
                "The MobJeX platform was used as the basis for implementation and testing with a number of laboratory tests conducted to measure scalability, efficiency and the application of simple measurement and propagation criteria to reduce collection overhead.",
                "Categories and Subject Descriptors C.2.4 Distributed Systems; D.2.8 Metrics General Terms Measurement, Performance. 1.",
                "INTRODUCTION The different capabilities of mobile devices, plus the varying speed, error rate and disconnection characteristics of mobile networks [1], make it difficult to predict in advance the exact execution environment of mobile applications.",
                "One solution which is receiving increasing attention in the research community is application adaptation [2-7], in which applications adjust their behaviour in response to factors such as network, processor, or memory usage.",
                "Effective adaptation requires detailed and up to date information about both the system and the software itself.",
                "Metrics related to system wide information (e.g. processor, memory and network load) are referred to as environmental metrics [5], while metrics representing application behaviour are referred as software metrics [8].",
                "Furthermore, the type of metrics required for performing adaptation is dependent upon the type of adaptation required.",
                "For example, service-based adaptation, in which service quality or service behaviour is modified in response to changes in the runtime environment, generally requires detailed environmental metrics but only simple software metrics [4].",
                "On the other hand, adaptation via object mobility [6], also requires detailed software metrics [9] since object placement is dependent on the execution characteristics of the mobile objects themselves.",
                "With the exception of MobJeX [6], existing <br>mobile object</br> systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in <br>mobile object</br> frameworks, and no existing means of automatically collecting them.",
                "Consequently, the main contribution of this paper is a solution for dynamic metrics collection to support adaptation via object mobility for mobile applications.",
                "This problem is non-trivial since typical <br>mobile object</br> frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine.",
                "Furthermore, in some cases the location where each metric should be collected is not fixed (i.e. it could be done in several places) and thus a decision must be made based on the efficiency of the chosen solution (see section 3).",
                "The rest of this paper is organised as follows: Section 2 describes the general structure and implementation of <br>mobile object</br> frameworks in order to understand the challenges related to the collection, propagation and delivery of metrics as described in section 3.",
                "Section 4 describes some initial testing and results and section 5 closes with a summary, conclusions and discussion of future work. 2.",
                "BACKGROUND In general, an object-oriented application consists of objects collaborating to provide the functionality required by a given problem domain.",
                "<br>mobile object</br> frameworks allow some of these objects to be tagged as mobile objects, providing middleware support for such objects to be moved at runtime to other hosts.",
                "At a minimum, a <br>mobile object</br> framework with at least one running mobile application consists of the following components: runtimes, mobile objects, and proxies [14], although the terminology used by individual frameworks can differ [6, 10-13].",
                "A runtime is a container process for the management of mobile objects.",
                "For example, in FarGo [15] this component is known as a core and in most systems separate runtimes are required to allow different applications to run independently, although this is not the case with MobJeX, which can run multiple applications in a single runtime using threads.",
                "The applications themselves comprise mobile objects, which interact with each other through proxies [14].",
                "Proxies, which have the same method interface as the object itself but add remote communication and object tracking functionality, are required for each target object that a source object communicates with.",
                "Upon migration, proxy objects move with the source object.",
                "The Java based system MobJeX, which is used as the implementation platform for the metrics collection solution described in this paper, adds a number of additional middleware components.",
                "Firstly, a host manager (known as a service in MobJeX) provides a central point of communication by running on a known port on a per host basis, thus facilitating the enumeration or lookup of components such as runtimes or mobile objects.",
                "Secondly, MobJeX has a per-application <br>mobile object</br> container called a transport manager (TM).",
                "As such the host and transport managers are considered in the solution provided in the next section but could be omitted in the general case.",
                "Finally, depending on adaptation mode, MobJeX can have a centralised system controller incorporating a global adaptation engine for performing system wide optimisation. 3.",
                "METRICS COLLECTION This section discusses the design and derivation of a solution for collecting metrics in order to support the adaptation of applications via object migration.",
                "The solution, although implemented within the MobJeX framework, is for the most part discussed in generic terms, except where explicitly stated to be MobJeX specific. 3.1 Metrics Selection The metrics of Ryan and Rossi [9] have been chosen as the basis for this solution, since they are specifically intended for mobile application adaptation as well as having been derived from a series of mathematical models and empirically validated.",
                "Furthermore, the metrics were empirically shown to improve the application performance in a real adaptation scenario following a change in the execution environment.",
                "It would however be beyond the scope of this paper to implement and test the full suite of metrics listed in [9], and thus in order to provide a useful non-random subset, we chose to implement the minimum set of metrics necessary to implement local and global adaptation [9] and thereby satisfy a range of real adaptation scenarios.",
                "As such the solution presented in this section is discussed primarily in terms of these metrics, although the structure of the solution is intended to support the implementation of the remaining metrics, as well as other unspecified metrics such as those related to quality and resource utilisation.",
                "This subset is listed below and categorised according to metric type.",
                "Note that some additional metrics were used for implementation purposes in order to derive core metrics or assist the evaluation, and as such are defined in context where appropriate. 1.",
                "Software metrics - Number of Invocations (NI), the frequency of invocations on methods of a class. 2.",
                "Performance metrics - Method Execution Time (ET), the time taken to execute a method body (ms). - Method Invocation Time (IT), the time taken to invoke a method, excluding the method execution time (ms). 3.",
                "Resource utilization metrics - Memory Usage (MU), the memory usage of a process (in bytes). - Processor Usage (PU), the percentage of the CPU load of a host. - Network Usage (NU), the network bandwidth between two hosts (in bytes/sec).",
                "Following are brief examples of a number of these metrics in order to demonstrate their usage in an adaptation scenario.",
                "As Processor Usage (PU) on a certain host increases, the Execution Time (ET) of a given method executed on that host also increases [9], thus facilitating the decision of whether to move an object with high ET to another host with low PU.",
                "Invocation Time (IT) shows the overhead of invoking a certain method, with the invocation overhead of marshalling parameters and transmitting remote data for a remote call being orders of magnitude higher than the cost of pushing and popping data from the method call stack.",
                "In other words, remote method invocation is expensive and thus should be avoided unless the gains made by moving an object to a host with more processing power (thereby reducing ET) outweigh the higher IT of the remote call.",
                "Finally, Number of Invocations (NI) is used primarily as a weighting factor or multiplier in order to enable the adaptation engine to predict the value over time of a particular adaptation decision. 3.2 Metrics Measurement This subsection discusses how each of the metrics in the subset under investigation can be obtained in terms of either direct measurement or derivation, and where in the <br>mobile object</br> framework such metrics should actually be measured.",
                "Of the environmental resource metrics, Processor Usage (PU) and Network Usage (NU) both relate to an individual machine, and thus can be directly measured through the resource monitoring subsystem that is instantiated as part of the MobJeX service.",
                "However, Memory Usage (MU), which represents the memory state of a running process rather than the memory usage of a host, should instead be collected within an individual runtime.",
                "The measurement of Number of Invocations (NI) and Execution Time (ET) metrics can be also be performed via direct measurement, however in this case within the <br>mobile object</br> implementation (mobject) itself.",
                "NI involves simply incrementing a counter value at either the start or end of a method call, depending upon the desired semantics with regard to thrown exceptions, while ET can be measured by starting a timer at the beginning of the method and stopping it at the end of the method, then retrieving the duration recorded by the timer.",
                "In contrast, collecting Invocation Time (IT) is not as straight forward because the time taken to invoke a method can only be measured after the method finishes its execution and returns to the caller.",
                "In order to collect IT metrics, another additional metric is needed.",
                "Ryan and Rossi [9] define the metric Response Time (RT), as the total time taken for a method call to finish, which is the sum of IT and ET.",
                "The Response Time can be measured directly using the same timer based technique used to measure ET, although at the start and end of the proxy call rather than the method implementation.",
                "Once the Response Time (RT) is known, IT can derived by subtracting RT from ET.",
                "Although this derivation appears simple, in practice it is complicated by the fact that the RT and ET values from which the IT is derived are by necessity measured using timer code in different locations i.e.",
                "RT measured in the proxy, ET measured in the method body of the object implementation.",
                "In addition, the proxies are by definition not part of the MobJeX containment hierarchy, since although proxies have a reference to their target object, it is not efficient for a <br>mobile object</br> (mobject) to have backward references to all of the many proxies which reference it (one per source object).",
                "Fortunately, this problem can be solved using the push based propagation mechanism described in section 3.5 in which the RT metric is pushed to the mobject so that IT can be derived from the ET value stored there.",
                "The derived value of IT is then stored and propagated further as necessary according to the criteria of section 3.6, the structural relationship of which is shown in Figure 1. 3.3 Measurement Initiation The polling approach was identified as the most appropriate method for collecting resource utilisation metrics, such as Processor Usage (PU), Network Usage (NU) and Memory Usage (MU), since they are not part of, or related to, the direct flow of the application.",
                "To measure PU or NU, the resource monitor polls the Operating System for the current CPU or network load respectively.",
                "In the case of Memory Usage (MU), the Java Virtual Machine (JVM) [16] is polled for the current memory load.",
                "Note that in order to minimise the impact on application response time, the polling action should be done asynchronously in a separate thread.",
                "Metrics that are suitable for application initiated collection (i.e. as part of a normal method call) are software and performance related metrics, such as Number of Invocations (NI), Execution Time (ET), and Invocation Time (IT), which are explicitly related to the normal invocation of a method, and thus can be measured directly at this time. 3.4 Metrics Aggregation In the solution presented in this paper, all metrics collected in the same location are aggregated in a MetricsContainer with individual containers corresponding to functional components in the <br>mobile object</br> framework.",
                "The primary advantage of aggregating metrics in containers is that it allows them to be propagated easily as a cohesive unit through the components of the mobility framework so that they can be delivered to the adaptation engine, as discussed in the following subsection.",
                "Note that this containment captures the different granularity of measurement attributes and their corresponding metrics.",
                "Consider the case of measuring memory consumption.",
                "At a coarse level of granularity this could be measured for an entire application or even a system, but could also be measured at the level of an individual object; or for an even finer level of granularity, the memory consumption during the execution of a specific method.",
                "As an example of the level of granularity required for mobility based adaptation, the local adaptation algorithm proposed by Ryan and Rossi [9] requires metrics representing both the duration of a method execution and the overhead of a method invocation.",
                "The use of metrics containers facilitates the collection of metrics at levels of granularity ranging from a single machine down to the individual method level.",
                "Note that some metrics containers do not contain any Metric objects, since as previously described, the sample implementation uses only a subset of the adaptation metrics from [9].",
                "However, for the sake of consistency and to promote flexibility in terms of adding new metrics in the future, these containers are still considered in the present design for completeness and for future work. 3.5 Propagation and Delivery of Metrics The solution in this paper identifies two stages in the metrics collection and delivery process.",
                "Firstly, the propagation of metrics through the components of the mobility framework and secondly, the delivery of those metrics from the host manager/service (or runtime if the host manager is not present) to the adaptation engine.",
                "Regarding propagation, in brief, it is proposed that when a lower level system component detects the arrival of a new metric update (e.g. <br>mobile object</br>), the metric is pushed (possibly along with other relevant metrics) to the next level component (i.e. runtime or transport manager containing the <br>mobile object</br>), which at some later stage, again determined by a configurable criteria (for example when there are a sufficient number of changed mobjects) will get pushed to the next level component (i.e. the host manager or the adaptation engine).",
                "A further incentive for treating propagation separately from delivery is due to the distinction between local and global adaptation [9].",
                "Local adaptation is performed by an engine running on the local host (for example in MobJeX this would occur within the service) and thus in this case the delivery phase would be a local inter-process call.",
                "Conversely, global adaptation is handled by a centralised adaptation engine running on a remote host and thus the delivery of metrics is via a remote call, and in the case where multiple runtimes exist without a separate host manager the delivery process would be even more expensive.",
                "Therefore, due to the presence of network communication latency, it is important for the host manager to pass as many metrics as possible to the adaptation engine in one invocation, implying the need to gather these metrics in the host manager, through some form of push or propagation, before sending them to the adaptation engine.",
                "Consequently, an abstract representation or model [17] of the system needs to be maintained.",
                "Such a model would contain model entities, corresponding to each of the main system components, connected in a tree like hierarchy, which precisely reflects the structure and containment hierarchy of the actual system.",
                "Attaching metrics containers to model entities allows a model entity representing a host manager to be delivered to the adaptation engine enabling it to access all metrics in that component and any of its children (i.e. runtimes, and mobile objects).",
                "Furthermore it would generally be expected that an adaptation engine or system controller would already maintain a model of the system that can not only be reused for propagation but also provides an effective means of delivering metrics information from the host manager to the adaptation engine.",
                "The relationship between model entities and metrics containers is captured in Figure 1. 3.6 Propagation and Delivery Criteria This subsection proposes flexible criteria to allow each component to decide when it should propagate its metrics to the next component in line (Figure 1), in order to reduce the overhead incurred when metrics are unnecessarily propagated through the components of the mobility framework and delivered to the adaptation engine.",
                "This paper proposes four different types of criterion that are executed at various stages of the measurement and propagation process in order to determine whether the next action should be taken or not.",
                "This approach was designed such that whenever a single criterion is not satisfied, the subsequent criteria are not tested.",
                "These four criteria are described in the following subsections.",
                "Measure Metric Criterion - This criterion is attached to individual Metric objects to decide whether a new metric value should be measured or not.",
                "This is most useful in the case where it is expensive to measure a particular metric.",
                "Furthermore, this criterion can be used as a mechanism for limiting storage requirements and manipulation overhead in the case where metric history is maintained.",
                "Simple examples would be either time or frequency based whereas more complex criteria could be domain specific for a particular metric, or based upon information stored in the metrics history.",
                "Notify Metrics Container Criterion - This criterion is also attached to individual Metric objects and is used to determine the circumstances under which the Metric object should notify its MetricsContainer.",
                "This is based on the assumption that there may be cases where it is desirable to measure and store a metric in the history for the analysis of temporal behaviour, but is not yet significant enough to notify the MetricsContainer for further processing.",
                "A simple example of this criterion would be threshold based in which the newest metric value is compared with the previously stored value to determine whether the difference is significant enough to be of any interest to the MetricsContainer.",
                "A more complex criterion could involve analysis of the history to determine whether a pattern of recent changes is significant enough to warrant further processing and possible metrics delivery.",
                "Notify Model Entity Criterion - Unlike the previous two criteria, this criterion is associated with a MetricsContainer.",
                "Since a MetricsContainer can have multiple Metric objects, of which it has explicit domain knowledge, it is able to determine if, when, and how many of these metrics should be propagated to the ModelEntity and thus become candidates for being part of the hierarchical ModelEntity push process as described below.",
                "This decision making is facilitated by the notifications received from individual Metric objects as described above.",
                "A simple implementation would be waiting for a certain number of updates before sending a notification to the model entity.",
                "For example, since the MobjectMetricsContainer object contains three metrics, a possible criteria would be to check if two or more of the metrics have changed.",
                "A slightly more advanced implementation can be done by giving each metric a weight to indicate how significant it is in the adaptation decision making process.",
                "Push Criterion - The push criterion applies to all of the ModelEntites which are containers, that is the TransportManagerModelEntity, RuntimeModelEntity and ServiceModelEntity, as well as the special case of the ProxyMetricsContainer.",
                "The purpose of this criterion is twofold.",
                "For the TransportManagerModelEntity this serves as a criterion to determine notification since as with the previously described criteria, a local reference is involved.",
                "For the other model entities, this serves as an opportunity to determine both when and what metrics should be pushed to the parent container wherein the case of the ServiceModelEntity the parent is the adaptation engine itself or in the case of the ProxyMetricsContainer the target of the push is the MobjectMetricsContainer.",
                "Furthermore, this criterion is evaluated using information from two sources.",
                "Firstly, it responds to the notification received from its own MetricsContainer but more importantly it serves to keep track of notifications from its child ModelEntities so as to determine when and what metrics information should be pushed to its parent or target.",
                "In the specialised case of the push criterion for the proxy, the decision making is based on both the ProxyMetricsContainer itself, as well as the information accumulated from the individual ProxyMethodMetricsContainers.",
                "Note that a push criterion is not required for a mobject since it does not have any containment or aggregating responsibilities since this is already Service Model Entity Service Metrics Container Notify Model Entity Criterion Runtime Model Entity Runtime Metrics Container Notify Model Entity Criterion Transport Manager Model Entity Transport Manager Metrics Container Notify Model Entity Criterion Push Criterion Mobject Model Entity Mobject Method Metrics Notify Model Entity Criterion Push Criterion Push Criterion To adaptation engine Mobject Metrics Container Notify Metrics Container Criterion Measure Metric Criterion Metric 1 NotifyMetrics Container Criterion Notify Metrics Container Criterion Measure Metric CriterionProxyMethod Metrics Containers RT Metric Notify Metrics Container Criterion ProxyMetrics Container Push Criterion Measure Metric Criterion Metric 2 Measure Metric Criterion Metric 1 1..n not currently implemented Notify Metrics Container Criterion Metric 1 Metric 2 Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion MU Metric Measure Metric Criterion Notify Metrics Container Criterion ET Metric IT Metric NI Metric Measure Metric Criterion Measure Metric Criterion Measure Metric Criterion Notify Metrics Container Criterion NU Metric PU Metric Measure Metric Criterion Measure Metric Criterion 1..n Figure 1.",
                "Structural overview of the hierarchical and criteriabased notification relationships between Metrics, Metrics Containers, and Model Entities handled by the MobjectMetricsContainer and its individual MobjectMethodMetricsContainers.",
                "Although it is always important to reduce the number of pushes, this is especially so from a service to a centralised global adaptation engine, or from a proxy to a mobject.",
                "This is because these relationships involve a remote call [18] which is expensive due to connection setup and data marshalling and unmarshalling overhead, and thus it is more efficient to send a given amount of data in aggregate form rather than sending smaller chunks multiple times.",
                "A simple implementation for reducing the number of pushes can be done using the concept of a process period [19] in which case the model entity accumulates pushes from its child entities until the process period expires at which time it pushes the accumulated metrics to its parent.",
                "Alternatively it could be based on frequency using domain knowledge about the type of children for example when a significant number of mobjects in a particular application (i.e.",
                "TransportManager) have undergone substantial changes.",
                "For reducing the size of pushed data, two types of pushes were considered: shallow push and deep push.",
                "With shallow push, a list of metrics containers that contain updated metrics is pushed.",
                "In a deep push, the model entity itself is pushed, along with its metrics container and its child entities, which also have reference to metrics containers but possibly unchanged metrics.",
                "In the case of the proxy, a deep push involves pushing the ProxyMetricsContainer and all of the ProxyMethodMetricsContainers whereas a shallow push means only the ProxyMethodMetricsContainers that meet a certain criterion. 4.",
                "EVALUATION The preliminary tests presented in this section aim to analyse the performance and scalability of the solution and evaluate the impact on application execution in terms of metrics collection overhead.",
                "All tests were executed using two Pentium 4 3.0 GHz PCs with 1,024 MB of RAM, running Java 1.4.2_08.",
                "The two machines were connected to a router with a third computer acting as a file server and hosting the external adaptation engine implemented within the MobJeX system controller, thereby simulating a global adaptation scenario.",
                "Since only a limited number of tests could be executed, this evaluation chose to measure the worst case scenario in which all metrics collection was initiated in mobjects, wherein the propagation cost is higher than for any other metrics collected in the system.",
                "In addition, since exhaustive testing of criteria is beyond the scope of this paper, two different types of criteria were used in the tests.",
                "The measure metrics criterion was chosen, since this represents the starting point of the measurement process and can control under what circumstances and how frequently metrics are measured.",
                "In addition, the push criterion was also implemented on the service, in order to provide an evaluation of controlling the frequency of metrics delivery to the adaptation engine.",
                "All other (update and push) criteria were set to always meaning that they always evaluated to true and thus a notification was posted.",
                "Figure 2 shows the metric collection overhead in the mobject (MMCO), for different numbers of mobjects and methods when all criteria are set to always to provide the maximum measurement and propagation of metrics and thus an absolute worst case performance scenario.",
                "It can be seen that the independent factors of increasing the number of mobjects and methods independently are linear.",
                "Although combining these together provides an exponential growth that is approximately n-squared, the initial results are not discouraging since delivering all of the metrics associated with 20 mobjects, each having 20 methods (which constitutes quite a large application given that mobjects typically represent coarse grained object clusters) is approximately 400ms, which could reasonably be expected to be offset with adaptation gains.",
                "Note that in contrast, the proxy metrics collection overhead (PMCO) was relatively small and constant at < 5ms, since in the absence of a proxy push criterion (this was only implemented on the service) the response time (RT) data for a single method is pushed during every invocation. 50 150 250 350 450 550 1 5 10 15 20 25 Number of Mobjects/Methods MobjectMetricsCollectionOverheadMMCO(ms) Methods Mobjects Both Figure 2.",
                "Worst case performance characteristics The next step was to determine the percentage metrics collection overhead compared with execution time in order to provide information about the execution characteristics of objects that would be suitable for adaptation using this metric collection approach.",
                "Clearly, it is not practical to measure metrics and perform adaptation on objects with short execution times that cannot benefit from remote execution on hosts with greater processing power, thereby offsetting IT overhead of remote compared with local execution as well as the cost of object migration and the metrics collection process itself.",
                "In addition, to demonstrate the effect of using simple frequency based criteria, the MMCO results as a percentage of method execution time were plotted as a 3-dimensional graph in Figure 3 with the z-axis representing the frequency used in both the measure metrics criterion and the service to adaptation engine push criterion.",
                "This means that for a frequency value of 5 (n=5), metrics are only measured on every fifth method call, which then results in a notification through the model entity hierarchy to the service, on this same fifth invocation.",
                "Furthermore, the value of n=5 was also applied to the service push criterion so that metrics were only pushed to the adaptation engine after five such notifications, that is for example five different mobjects had updated their metrics.",
                "These results are encouraging since even for the worst case scenario of n=1 the metric collection overhead is an acceptable 20% for a method of 1500ms duration (which is relatively short for a component or service level object in a distributed enterprise class application) with previous work on adaptation showing that such an overhead could easily be recovered by the efficiency gains made by adaptation [5].",
                "Furthermore, the measurement time includes delivering the results synchronously via a remote call to the adaptation engine on a different host, which would normally be done asynchronously, thus further reducing the impact on method execution performance.",
                "The graph also demonstrates that even using modest criteria to reduce the metrics measurement to more realistic levels, has a rapid improvement on collection overhead at 20% for 500ms of ET. 0 1000 2000 3000 4000 5000 1 2 3 4 5 6 0 20 40 60 80 100 120 MMCO (%) ET (milliseconds) N (interval) MMCO (%) Figure 3.",
                "Performance characteristics with simple criteria 5.",
                "SUMMARY AND CONCLUSIONS Given the challenges of developing mobile applications that run in dynamic/heterogeneous environments, and the subsequent interest in application adaptation, this paper has proposed and implemented an online metrics collection strategy to assist such adaptation using a <br>mobile object</br> framework and supporting middleware.",
                "Controlled lab studies were conducted to determine worst case performance, as well as show the reduction in collection overhead when applying simple collection criteria.",
                "In addition, further testing provided an initial indication of the characteristics of application objects (based on method execution time) that would be good candidates for adaptation using the worst case implementation of the proposed metrics collection strategy.",
                "A key feature of the solution was the specification of multiple configurable criteria to control the propagation of metrics through the system, thereby reducing collection overhead.",
                "While the potentially efficacy of this approach was tested using simple criteria, given the flexibility of the approach we believe there are many opportunities to significantly reduce collection overhead through the use of more sophisticated criteria.",
                "One such approach could be based on maintaining metrics history in order to determine the temporal behaviour of metrics and thus make more intelligent and conservative decisions regarding whether a change in a particular metric is likely to be of interest to the adaptation engine and should thus serve as a basis for notification for inclusion in the next metrics push.",
                "Furthermore, such a temporal history could also facilitate intelligent decisions regarding the collection of metrics since for example a metric that is known to be largely constant need not be frequently measured.",
                "Future work will also involve the evaluation of a broad range of adaptation scenarios on the MobJeX framework to quantity the gains that can be made via adaptation through object mobility and thus demonstrate in practise, the efficacy of the solution described in this paper.",
                "Finally, the authors wish to explore applying the metrics collection concepts described in this paper to a more general and reusable context management system [20]. 6.",
                "REFERENCES 1.",
                "Katz, R.H., Adaptation and Mobility in Wireless Information Systems.",
                "IEEE Personal Communications, 1994. 1: p. 6-17. 2.",
                "Hirschfeld, R. and Kawamura, K. Dynamic Service Adaptation. in ICDCS Workshops04. 2004. 3.",
                "Lemlouma, T. and Layaida, N. Context-Aware Adaptation for Mobile Devices. in Proceedings of IEEE International Conference on Mobile Data Management 2004. 2004. 4.",
                "Noble, B.D., et al.",
                "Agile Application-Aware Adaptation for Mobility. in Proc. of the 16th ACM Symposium on Operating Systems and Principles SOSP. 1997.",
                "Saint-Malo, France. 5.",
                "Rossi, P. and Ryan, C. An Empirical Evaluation of Dynamic Local Adaptation for Distributed Mobile Applications. in Proc. of 2005 International Symposium on Distributed Objects and Applications (DOA 2005). 2005.",
                "Larnaca, Cyprus: SpringerVerlag. 6.",
                "Ryan, C. and Westhorpe, C. Application Adaptation through Transparent and Portable Object Mobility in Java. in International Symposium on Distributed Objects and Applications (DOA 2004). 2004.",
                "Larnaca, Cyprus: SpringerVerlag. 7. da Silva e Silva, F.J., Endler, M., and Kon, F. Developing Adaptive Distributed Applications: A Framework Overview and Experimental Results. in On The Move to Meaningful Internet Systems 2003: CoopIS, DOA, and ODBASE (LNCS 2888). 2003. 8.",
                "Rossi, P. and Fernandez, G. Definition and validation of design metrics for distributed applications. in Ninth International Software Metrics Symposium. 2003.",
                "Sydney: IEEE. 9.",
                "Ryan, C. and Rossi, P. Software, Performance and Resource Utilisation Metrics for Context Aware Mobile Applications. in Proceedings of International Software Metrics Symposium IEEE Metrics 2005. 2005.",
                "Como, Italy. 10.",
                "Recursion Software Inc. Voyager URL: http://www.recursionsw.com/voyager.htm. 2005. 11.",
                "Holder, O., Ben-Shaul, I., and Gazit, H., System Support for Dynamic Layout of Distributed Applications. 1998, TechinonIsrael Institute of Technology. p. 163 - 173. 12.",
                "Holder, O., Ben-Shaul, I., and Gazit, H. Dynamic Layout of Distributed Applications in FarGo. in 21st Intl Conf.",
                "Software Engineering (ICSE99). 1999: ACM Press. 13.",
                "Philippsen, M. and Zenger, M., JavaParty - Transparent Remote Objects in Java.",
                "Concurrency: Practice and Experience, 1997. 9(11): p. 1225-1242. 14.",
                "Shapiro, M. Structure and Encapsulation in Distributed Systems: the Proxy Principle. in Proc.6th Intl.",
                "Conference on Distributed Computing Systems. 1986.",
                "Cambridge, Mass. (USA): IEEE. 15.",
                "Gazit, H., Ben-Shaul, I., and Holder, O. Monitoring-Based Dynamic Relocation of Components in Fargo. in Proceedings of the Second International Symposium on Agent Systems and Applications and Fourth International Symposium on Mobile Agents. 2000. 16.",
                "Lindholm, T. and Yellin, F., The Java Virtual Machine Specification 2nd Edition. 1999: Addison-Wesley. 17.",
                "Randell, L.G., Holst, L.G., and Bolmsjö, G.S.",
                "Incremental System Development of Large Discrete-Event Simulation Models. in Proceedings of the 31st conference on Winter Simulation. 1999.",
                "Phoenix, Arizona. 18.",
                "Waldo, J., Remote Procedure Calls and Java Remote Method Invocation.",
                "IEEE Concurrency, 1998. 6(3): p. 5-7. 19.",
                "Rolia, J. and Lin, B.",
                "Consistency Issues in Distributed Application Performance Metrics. in Proceedings of the 1994 Conference of the Centre for Advanced Studies on Collaborative Research. 1994.",
                "Toronto, Canada. 20.",
                "Henricksen, K. and Indulska, J.",
                "A software engineering framework for context-aware pervasive computing. in Proceedings of the 2nd IEEE Conference on Pervasive Computing and Communications (PerCom). 2004.",
                "Orlando."
            ],
            "original_annotated_samples": [
                "Runtime Metrics Collection for Middleware Supported Adaptation of Mobile Applications Hendrik Gani School of Computer Science and Information Technology, RMIT University, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan School of Computer Science and Information Technology, RMIT University, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi School of Computer Science and Information Technology, RMIT University, Melbourne, Australia pablo@cs.rmit.edu.au ABSTRACT This paper proposes, implements, and evaluates in terms of worst case performance, an online metrics collection strategy to facilitate application adaptation via object mobility using a <br>mobile object</br> framework and supporting middleware.",
                "The solution is based upon an abstract representation of the <br>mobile object</br> system, which holds containers aggregating metrics for each specific component including host managers, runtimes and mobile objects.",
                "With the exception of MobJeX [6], existing <br>mobile object</br> systems such as Voyager [10], FarGo [11, 12], and JavaParty [13] do not provide automated adaptation, and therefore lack the metrics collection process required to support this process.",
                "In the case of MobJeX, although an adaptation engine has been implemented [5], preliminary testing was done using synthetic pre-scripted metrics since there is little prior work on the dynamic collection of software metrics in <br>mobile object</br> frameworks, and no existing means of automatically collecting them.",
                "This problem is non-trivial since typical <br>mobile object</br> frameworks consist of multiple application and middleware components, and thus metrics collection must be performed at different locations and the results efficiently propagated to the adaptation engine."
            ],
            "translated_annotated_samples": [
                "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de <br>objetos móviles</br> y middleware de soporte.",
                "La solución se basa en una representación abstracta del sistema de <br>objetos móviles</br>, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los <br>objetos móviles</br>.",
                "Con la excepción de MobJeX [6], los sistemas de <br>objetos móviles</br> existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso.",
                "En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de <br>objetos móviles</br> y no existen medios existentes para recopilarlas automáticamente.",
                "Este problema no es trivial ya que los marcos de <br>objetos móviles</br> típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación."
            ],
            "translated_text": "Recopilación de métricas en tiempo de ejecución para la adaptación de aplicaciones móviles con soporte de middleware. Hendrik Gani, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia hgani@cs.rmit.edu.au Caspar Ryan, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia caspar@cs.rmit.edu.au Pablo Rossi, Escuela de Ciencias de la Computación y Tecnología de la Información, Universidad RMIT, Melbourne, Australia pablo@cs.rmit.edu.au RESUMEN Este artículo propone, implementa y evalúa en términos de rendimiento en el peor caso, una estrategia de recopilación de métricas en línea para facilitar la adaptación de aplicaciones a través de la movilidad de objetos utilizando un marco de <br>objetos móviles</br> y middleware de soporte. La solución se basa en una representación abstracta del sistema de <br>objetos móviles</br>, que contiene contenedores que agregan métricas para cada componente específico, incluidos los administradores de host, los tiempos de ejecución y los <br>objetos móviles</br>. Una característica clave de la solución es la especificación de múltiples criterios configurables para controlar la medición y propagación de métricas a través del sistema. La plataforma MobJeX se utilizó como base para la implementación y prueba, con una serie de pruebas de laboratorio realizadas para medir la escalabilidad, eficiencia y la aplicación de criterios simples de medición y propagación para reducir la sobrecarga de recolección. Categorías y Descriptores de Asignaturas C.2.4 Sistemas Distribuidos; D.2.8 Métricas Términos Generales Medición, Rendimiento. 1. INTRODUCCIÓN Las diferentes capacidades de los dispositivos móviles, junto con las variadas velocidades, tasas de error y características de desconexión de las redes móviles [1], hacen difícil predecir de antemano el entorno de ejecución exacto de las aplicaciones móviles. Una solución que está recibiendo cada vez más atención en la comunidad de investigación es la adaptación de aplicaciones [2-7], en la que las aplicaciones ajustan su comportamiento en respuesta a factores como el uso de red, procesador o memoria. La adaptación efectiva requiere información detallada y actualizada tanto sobre el sistema como sobre el software en sí mismo. Las métricas relacionadas con la información del sistema en su totalidad (por ejemplo, carga del procesador, memoria y red) se denominan métricas ambientales [5], mientras que las métricas que representan el comportamiento de la aplicación se denominan métricas de software [8]. Además, el tipo de métricas necesarias para realizar la adaptación depende del tipo de adaptación requerida. Por ejemplo, la adaptación basada en servicios, en la que la calidad del servicio o el comportamiento del servicio se modifica en respuesta a los cambios en el entorno de ejecución, generalmente requiere métricas ambientales detalladas pero solo métricas de software simples [4]. Por otro lado, la adaptación a través de la movilidad de objetos [6] también requiere métricas de software detalladas [9] ya que la ubicación de los objetos depende de las características de ejecución de los propios objetos móviles. Con la excepción de MobJeX [6], los sistemas de <br>objetos móviles</br> existentes como Voyager [10], FarGo [11, 12] y JavaParty [13] no proporcionan adaptación automatizada, y por lo tanto carecen del proceso de recopilación de métricas necesario para respaldar este proceso. En el caso de MobJeX, aunque se ha implementado un motor de adaptación [5], las pruebas preliminares se realizaron utilizando métricas predefinidas sintéticas, ya que hay poco trabajo previo sobre la recopilación dinámica de métricas de software en marcos de <br>objetos móviles</br> y no existen medios existentes para recopilarlas automáticamente. Por consiguiente, la principal contribución de este artículo es una solución para la recolección de métricas dinámicas que respalda la adaptación a través de la movilidad de objetos para aplicaciones móviles. Este problema no es trivial ya que los marcos de <br>objetos móviles</br> típicos consisten en múltiples componentes de aplicación y middleware, por lo que la recopilación de métricas debe realizarse en diferentes ubicaciones y los resultados deben propagarse eficientemente al motor de adaptación. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}