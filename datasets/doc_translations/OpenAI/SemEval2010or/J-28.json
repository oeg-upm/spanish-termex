{
    "id": "J-28",
    "original_text": "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem. The bidding language in our auctions allows marginal-decreasing piecewise constant curves. First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces. Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n). The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome. Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics. General Terms Algorithms, Economics. 1. INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem. Our scheme is both approximately efficient and approximately strategyproof. The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing. We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves. In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function. In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply. The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots. In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function. A buyer can also express a lower bound, or minimum lot size, on the number of units she demands. The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots. We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem. The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system. However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer. Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate. This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17]. The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable. For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces. Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT). We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption. Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i. Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i. This upper-bound tends to 1 as the number of sellers increases. The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation. This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation. As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation. Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms. We also prove our claims about ε-strategyproofness. Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme. Section 4 defines the approximation scheme for the payments in the VCG mechanism. Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items. The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]). Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases. We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve. The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention. For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem. Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies. Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome. VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design. Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges. Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model. This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data. Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good. The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design. Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2. APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions. Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes. We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language. This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities. See Figure 1 for an example. In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount. Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids. In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25]. Her valuation is zero for quantities outside the range [10, 25]. In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25]. In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity. The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit. Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i . This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞). We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1. In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i . A sellers bid is similarly defined in the reverse auction. The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit. Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i . Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity. We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism. We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13]. We will use the term payoff interchangeably for utility. In the forward auction, there is a seller with M units to sell. We assume that this seller has no intrinsic value for the items. Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold. Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i. Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i. The VCG mechanism is defined as follows: 1. Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2. Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3. Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller. In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers. In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system. In the reverse auction, there is a buyer with M units to buy, and n suppliers. We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise. To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V . Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i. We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I). Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments. The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller. The total payment is collected from the buyer. Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I). Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value. Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers. This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed. This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them. This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V . In words, there would be no efficient trade without the seller. Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller. Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i. In other words, there must be no pivotal sellers. Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units. The payments to the sellers would never exceed the buyers value in this case. Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost. The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50. Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100. In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20). In the second case, the payoffs are π = (−10, 30, 50, 30). One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem. We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy. We describe the result for the forward auction direction, but it is quite a general observation. As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i. Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0. We provide such an approximation scheme for our setting later in the paper. Let ˆx denote the allocation implemented by the approximation scheme. The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis. However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism. In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj). If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest. However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium. Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]). We can now analyze the best possible gain from manipulation to an agent in our setting. We first assume that the other agents are truthful, and then relax this. In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case. With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε). Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I). Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution. The analysis is very similar when the other agents are not truthful. In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents. Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1. A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy. Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term. However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3. THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions. We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction. In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution. We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack. In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS). One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions. We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings. The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces. The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers. The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers. Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized. This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack. In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent. Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected. Choosing interval [uj i , uj+1 i ) has cost pj i per unit. The goal is to procure at least M units of the good at minimum possible cost. The problem has some flavor of the continuous knapsack problem. However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition. Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor. Recall that these tuples represent the breakpoints in the piecewise constant curve bids. We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset. PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset). However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i . The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i . In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i . Otherwise, we say that xi is midrange. We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange. If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor. See Figure 2 for an example. LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element. All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored. We use the anchor property to first obtain a polynomial-time 2-approximation scheme. We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval. Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero. This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost. Element x is assumed to have already contributed uj units. The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units. We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack. The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj . This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed. In any other group, we can choose at most one anchor. The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem. U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ). R is the number of units that remain to be acquired. S is the set of tuples accepted in the current tentative 170 solution. Best is the best solution found so far. Variable Skip is only used in the proof of correctness. Algorithm Greedy( , j) 1. Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2. Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3. Scan the tuples in U in the sorted order. Suppose the next tuple is tk i , i.e. the kth anchor from agent i. If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack. Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost. If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i . If size(tk i ) is greater than R, then S along with tk i forms a feasible solution. However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best. One exception to this rule is the tuple t . Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement. The algorithm terminates in either of the first two cases, or when all tuples are scanned. In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution. LEMMA 2. Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution. Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF. Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j). Consider the set Skip at the termination of Greedy( , j). There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j). In the first case, let St be the tentative solution S at the time t was added to Skip. Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t). Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t). On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t). These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip. Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original. Suppose our approximation algorithm returns the value V ( , j) for this modified instance. Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step. Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ). We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions. Therefore, dropping the tuples in the set Skip can only make the solution worse. The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j). We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem. Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange. Let x− to be set of the remaining elements, either zero or anchors, in this solution. Furthermore, define x = xj − uj . Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j). Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2. It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time. We have our first polynomial approximation algorithm. THEOREM 2. A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length). PROOF. We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange. There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ). By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed. The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem. The high level idea is fairly standard, but the details require technical care. We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table. Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ). In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack. Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack. Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i. As convention, agent i will index the row, and cost r will index the column. This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost. However, we can convert it into a FPTAS by scaling the cost dimension. Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A). Let ε denote the desired approximation factor. We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost. However, the computed solution might not be an optimal solution for the original problem. We show that the error introduced is within a factor of ε of the optimal solution. As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A). LEMMA 3. Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements. If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A). PROOF. Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0. Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples. Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r]. These entries correspond to optimal solutions with all agents except l, for different levels of cost. In particular, we consider the entries that provide at least M − uj+1 units. Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r]. It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation. LEMMA 4. Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution. Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF. Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj . Let r = scost(x− ) be the scaled cost associated with the vector x− . Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r]. Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm. Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists. Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A). Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution. Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units. Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj . Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ). Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions. For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list. Thus, we have the following result. THEOREM 3. We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε). The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4. COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents. A naive approach requires solving the allocation problem n times, removing each agent in turn. In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once. This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction. Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i. Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once. The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order. The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents. As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table. Similarly, (n− i)th row of the backward table will contain an approximation for the second part. We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm. Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently. In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed. This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i. We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1. We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl. The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme. In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε. Therefore, the cost dimension of our dynamic programs table will be nα/ε. FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j). Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors. These first i agents are a different subset of agents in the forward and the backward tables. By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j). We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries. To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations. Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry. We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5. Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution. Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i . PROOF. From earlier, we define cost(A−i ) = C(I \\ i). We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i). We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i). Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively. From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation. Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units. Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x. Now, define yj l = max(uj l , M −size(yi)−size(y−i)). From the preceding inequalities, we have yj l ≤ xj l . Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof. A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i. In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right. As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively. To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets. For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l . Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively. We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left. Let (g, h) be the current pair. If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer. The feasible pairs found during the walk are used to compute Eq. 6. The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost. However, the elements are still sorted in quantity and we use this property to compute Eq. 7. Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l . Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60. Begin and End represent the start and end pointers to the feasible set. Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively. We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set. We maintain the feasible set as a min heap, where the key is modified cost. To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements. For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap. So, the main complexity of the computation lies in heap updates. Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows. First, using the 2 approximation algorithm, we compute an upper bound on C(I). We use this bound to scale down the tuple costs. Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j). The forward tables are used to compute C(I). To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme. Among all the locally optimal solutions we choose one with the minimum total cost. The most expensive step in the algorithm is computation of C(I \\ i). The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5. In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ). THEOREM 4. We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ). It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents. Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant. Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem. The speed up comes from the way we solve iKnapsack−i ( , j). Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ). We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently. Currently, the algorithm uses heap, which has logarithmic update time. In worst case, we can have two heap update operations for each element, which makes the time complexity super linear. If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5. CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language. Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0. As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem. It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6. REFERENCES [1] L M Ausubel and P R Milgrom. Ascending auctions with package bidding. Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra. Linear programming and Vickrey auctions. Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy. The package assignment model. Journal of Economic Theory, 2002. Forthcoming. [4] K Chatterjee and W Samuelson. Bargaining under incomplete information. Operations Research, 31:835-851, 1983. [5] E H Clarke. Multipart pricing of public goods. Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra. Combinatorial auctions: A survey. Informs Journal on Computing, 2002. Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi. Bid evaluation in procurement auctions with piece-wise linear supply curves. Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker. Distributed Algorithmic Mechanism Design: Recent Results and Future Directions. In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson. Computers and Intractability: A Guide to the Theory of NP-Completeness. W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner. Computational complexity of approximation algorithms for combinatorial problems. In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves. Incentives in teams. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee. Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand. Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna. Auction Theory. Academic Press, 2002. [14] V Krishna and M Perry. Efficient mechanism design. Technical report, Pennsylvania State University, 1998. Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham. Truth revelation in approximately efficient combinatorial auctions. JACM, 49(5):577-602, September 2002. [16] R B Myerson. Optimal auction design. Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite. Efficient mechanisms for bilateral trading. Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen. Computationally feasible VCG mechanisms. In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso. Achieving budget-balance with Vickrey-based payment schemes in exchanges. In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad. Computationally manageable combinatorial auctions. Management Science, 44(8):1131-1147, 1998. [21] J Schummer. Almost dominant strategy implementation. Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey. Counterspeculation, auctions, and competitive sealed tenders. Journal of Finance, 16:8-37, 1961. 175",
    "original_translation": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades. Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r]. Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε). LEMMA 4. \n\nLEMMA 4. Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN. Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj. Sea r = scost(x− ) el costo escalado asociado con el vector x− . Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r]. Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica. Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas. Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A). Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades. Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗). Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones. Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. TEOREMA 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε). La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n. CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno. En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez. Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta. De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i. Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez. La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso. La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes. Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante. De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado. Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1. Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl. El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones. En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε. Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε. Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j). Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas. Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás. Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j). Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones. Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada. Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5. Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i. PRUEBA. Desde antes, definimos el costo(A−i) = C(I \\ i). Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i). Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i). Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente. A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2. Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades. Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x. Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)). A partir de las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i. En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha. Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente. Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos. Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l. Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda. Que (g, h) sea el par actual. Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs. Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6. La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto. Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7. Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l. Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60. \"Begin y End representan los punteros de inicio y fin al conjunto factible.\" Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles. Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo. Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo. Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I). Utilizamos este límite para reducir los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j). Las tablas de avance se utilizan para calcular C(I). Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más costoso en el algoritmo es el cálculo de C(I \\ i). La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5. En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε). TEOREMA 4. Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ). Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada. La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j). La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ). Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente. Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico. En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal. Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5. CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0. Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual. REFERENCIAS [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Revista de Teoría Económica, 2002. Próximamente. [4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra. Subastas combinatorias: Un estudio. Revista Informs sobre Computación, 2002. Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos. Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker. Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones. En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud. W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee. Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible. Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna. Teoría de subastas. Academic Press, 2002. [14] V Krishna y M Perry. Diseño de mecanismos eficientes. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios. En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer. Casi implementación de estrategia dominante. Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey. Contrarreforma, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. 175",
    "original_sentences": [
        "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
        "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
        "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
        "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
        "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
        "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
        "General Terms Algorithms, Economics. 1.",
        "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
        "Our scheme is both approximately efficient and approximately strategyproof.",
        "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
        "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
        "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
        "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
        "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
        "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
        "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
        "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
        "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
        "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
        "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
        "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
        "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
        "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
        "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
        "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
        "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
        "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
        "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
        "This upper-bound tends to 1 as the number of sellers increases.",
        "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
        "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
        "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
        "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
        "We also prove our claims about ε-strategyproofness.",
        "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
        "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
        "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
        "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
        "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
        "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
        "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
        "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
        "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
        "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
        "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
        "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
        "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
        "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
        "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
        "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
        "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
        "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
        "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
        "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
        "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
        "See Figure 1 for an example.",
        "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
        "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
        "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
        "Her valuation is zero for quantities outside the range [10, 25].",
        "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
        "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
        "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
        "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
        "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
        "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
        "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
        "A sellers bid is similarly defined in the reverse auction.",
        "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
        "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
        "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
        "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
        "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
        "We will use the term payoff interchangeably for utility.",
        "In the forward auction, there is a seller with M units to sell.",
        "We assume that this seller has no intrinsic value for the items.",
        "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
        "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
        "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
        "The VCG mechanism is defined as follows: 1.",
        "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
        "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
        "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
        "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
        "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
        "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
        "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
        "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
        "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
        "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
        "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
        "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
        "The total payment is collected from the buyer.",
        "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
        "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
        "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
        "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
        "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
        "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
        "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
        "In words, there would be no efficient trade without the seller.",
        "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
        "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
        "In other words, there must be no pivotal sellers.",
        "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
        "The payments to the sellers would never exceed the buyers value in this case.",
        "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
        "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
        "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
        "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
        "In the second case, the payoffs are π = (−10, 30, 50, 30).",
        "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
        "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
        "We describe the result for the forward auction direction, but it is quite a general observation.",
        "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
        "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
        "We provide such an approximation scheme for our setting later in the paper.",
        "Let ˆx denote the allocation implemented by the approximation scheme.",
        "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
        "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
        "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
        "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
        "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
        "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
        "We can now analyze the best possible gain from manipulation to an agent in our setting.",
        "We first assume that the other agents are truthful, and then relax this.",
        "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
        "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
        "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
        "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
        "The analysis is very similar when the other agents are not truthful.",
        "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
        "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
        "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
        "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
        "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
        "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
        "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
        "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
        "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
        "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
        "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
        "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
        "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
        "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
        "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
        "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
        "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
        "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
        "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
        "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
        "The goal is to procure at least M units of the good at minimum possible cost.",
        "The problem has some flavor of the continuous knapsack problem.",
        "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
        "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
        "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
        "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
        "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
        "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
        "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
        "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
        "Otherwise, we say that xi is midrange.",
        "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
        "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
        "See Figure 2 for an example.",
        "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
        "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
        "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
        "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
        "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
        "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
        "Element x is assumed to have already contributed uj units.",
        "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
        "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
        "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
        "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
        "In any other group, we can choose at most one anchor.",
        "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
        "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
        "R is the number of units that remain to be acquired.",
        "S is the set of tuples accepted in the current tentative 170 solution.",
        "Best is the best solution found so far.",
        "Variable Skip is only used in the proof of correctness.",
        "Algorithm Greedy( , j) 1.",
        "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
        "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
        "Scan the tuples in U in the sorted order.",
        "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
        "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
        "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
        "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
        "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
        "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
        "One exception to this rule is the tuple t .",
        "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
        "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
        "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
        "LEMMA 2.",
        "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
        "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
        "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
        "Consider the set Skip at the termination of Greedy( , j).",
        "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
        "In the first case, let St be the tentative solution S at the time t was added to Skip.",
        "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
        "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
        "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
        "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
        "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
        "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
        "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
        "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
        "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
        "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
        "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
        "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
        "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
        "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
        "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
        "Furthermore, define x = xj − uj .",
        "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
        "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
        "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
        "We have our first polynomial approximation algorithm.",
        "THEOREM 2.",
        "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
        "PROOF.",
        "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
        "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
        "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
        "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
        "The high level idea is fairly standard, but the details require technical care.",
        "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
        "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
        "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
        "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
        "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
        "As convention, agent i will index the row, and cost r will index the column.",
        "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
        "However, we can convert it into a FPTAS by scaling the cost dimension.",
        "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
        "Let ε denote the desired approximation factor.",
        "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
        "However, the computed solution might not be an optimal solution for the original problem.",
        "We show that the error introduced is within a factor of ε of the optimal solution.",
        "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
        "LEMMA 3.",
        "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
        "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
        "PROOF.",
        "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
        "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
        "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
        "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
        "In particular, we consider the entries that provide at least M − uj+1 units.",
        "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
        "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
        "LEMMA 4.",
        "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
        "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
        "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
        "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
        "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
        "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
        "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
        "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
        "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
        "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
        "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
        "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
        "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
        "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
        "Thus, we have the following result.",
        "THEOREM 3.",
        "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
        "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
        "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
        "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
        "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
        "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
        "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
        "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
        "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
        "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
        "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
        "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
        "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
        "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
        "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
        "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
        "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
        "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
        "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
        "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
        "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
        "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
        "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
        "These first i agents are a different subset of agents in the forward and the backward tables.",
        "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
        "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
        "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
        "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
        "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
        "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
        "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
        "PROOF.",
        "From earlier, we define cost(A−i ) = C(I \\ i).",
        "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
        "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
        "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
        "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
        "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
        "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
        "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
        "From the preceding inequalities, we have yj l ≤ xj l .",
        "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
        "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
        "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
        "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
        "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
        "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
        "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
        "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
        "Let (g, h) be the current pair.",
        "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
        "The feasible pairs found during the walk are used to compute Eq. 6.",
        "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
        "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
        "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
        "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
        "Begin and End represent the start and end pointers to the feasible set.",
        "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
        "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
        "We maintain the feasible set as a min heap, where the key is modified cost.",
        "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
        "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
        "So, the main complexity of the computation lies in heap updates.",
        "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
        "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
        "We use this bound to scale down the tuple costs.",
        "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
        "The forward tables are used to compute C(I).",
        "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
        "Among all the locally optimal solutions we choose one with the minimum total cost.",
        "The most expensive step in the algorithm is computation of C(I \\ i).",
        "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
        "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
        "THEOREM 4.",
        "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
        "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
        "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
        "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
        "The speed up comes from the way we solve iKnapsack−i ( , j).",
        "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
        "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
        "Currently, the algorithm uses heap, which has logarithmic update time.",
        "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
        "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
        "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
        "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
        "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
        "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
        "REFERENCES [1] L M Ausubel and P R Milgrom.",
        "Ascending auctions with package bidding.",
        "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
        "Linear programming and Vickrey auctions.",
        "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
        "The package assignment model.",
        "Journal of Economic Theory, 2002.",
        "Forthcoming. [4] K Chatterjee and W Samuelson.",
        "Bargaining under incomplete information.",
        "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
        "Multipart pricing of public goods.",
        "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
        "Combinatorial auctions: A survey.",
        "Informs Journal on Computing, 2002.",
        "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
        "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
        "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
        "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
        "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
        "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
        "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
        "Computational complexity of approximation algorithms for combinatorial problems.",
        "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
        "Incentives in teams.",
        "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
        "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
        "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
        "Auction Theory.",
        "Academic Press, 2002. [14] V Krishna and M Perry.",
        "Efficient mechanism design.",
        "Technical report, Pennsylvania State University, 1998.",
        "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
        "Truth revelation in approximately efficient combinatorial auctions.",
        "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
        "Optimal auction design.",
        "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
        "Efficient mechanisms for bilateral trading.",
        "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
        "Computationally feasible VCG mechanisms.",
        "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
        "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
        "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
        "Computationally manageable combinatorial auctions.",
        "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
        "Almost dominant strategy implementation.",
        "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
        "Counterspeculation, auctions, and competitive sealed tenders.",
        "Journal of Finance, 16:8-37, 1961. 175"
    ],
    "translated_text_sentences": [
        "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien.",
        "El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal.",
        "Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas.",
        "Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n).",
        "La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente.",
        "Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía.",
        "Términos generales Algoritmos, Economía. 1.",
        "En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien.",
        "Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias.",
        "Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas.",
        "Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal.",
        "En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos.",
        "Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar.",
        "Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible.",
        "En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos.",
        "Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda.",
        "Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible.",
        "Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples.",
        "El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema.",
        "Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador.",
        "De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente.",
        "Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17].",
        "El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable.",
        "Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos.",
        "Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT).",
        "Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio.",
        "Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i.",
        "Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i.",
        "Este límite superior tiende a 1 a medida que aumenta el número de vendedores.",
        "El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima.",
        "Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente.",
        "Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación.",
        "La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG.",
        "También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba.",
        "La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo.",
        "La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG.",
        "La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes.",
        "El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]).",
        "Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales.",
        "Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta.",
        "La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa.",
        "Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado.",
        "Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias.",
        "Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado.",
        "El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos.",
        "Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios.",
        "Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente.",
        "Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados.",
        "Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible.",
        "El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes.",
        "Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual.",
        "En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG.",
        "Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG.",
        "También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente.",
        "Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades.",
        "Consulta la Figura 1 para ver un ejemplo.",
        "Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica.",
        "Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos.",
        "En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25].",
        "Su valoración es cero para cantidades fuera del rango [10, 25].",
        "En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25].",
        "En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad.",
        "La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad.",
        "Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i.",
        "Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞).",
        "Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1.",
        "Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i.",
        "Una oferta de vendedor se define de manera similar en la subasta inversa.",
        "La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad.",
        "Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i.",
        "De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito.",
        "Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG.",
        "Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13].",
        "Usaremos el término \"pago\" de forma intercambiable con \"utilidad\".",
        "En la subasta ascendente, hay un vendedor con M unidades para vender.",
        "Suponemos que este vendedor no tiene un valor intrínseco para los artículos.",
        "Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo.",
        "Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i.",
        "De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i.",
        "El mecanismo VCG se define de la siguiente manera: 1.",
        "Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2.",
        "Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3.",
        "Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor.",
        "En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores.",
        "Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema.",
        "En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores.",
        "Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario.",
        "Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V.",
        "Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i.",
        "Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I).",
        "De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos.",
        "El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor.",
        "El pago total se recoge del comprador.",
        "Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I).",
        "Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores.",
        "De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores.",
        "Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes.",
        "Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos.",
        "Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave.",
        "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V.",
        "En otras palabras, no habría comercio eficiente sin el vendedor.",
        "Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador.",
        "Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i.",
        "En otras palabras, no debe haber vendedores clave.",
        "Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales.",
        "Los pagos a los vendedores nunca superarían el valor de los compradores en este caso.",
        "Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero).",
        "Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50.",
        "La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100.",
        "En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20).",
        "En el segundo caso, los pagos son π = (−10, 30, 50, 30).",
        "Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente.",
        "Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad.",
        "Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general.",
        "Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i.",
        "Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0.",
        "Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo.",
        "Que ˆx denote la asignación implementada por el esquema de aproximación.",
        "El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos.",
        "Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo.",
        "En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj).",
        "Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto.",
        "Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo.",
        "Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]).",
        "Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno.",
        "Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto.",
        "En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible.",
        "Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε).",
        "Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I).",
        "Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima.",
        "El análisis es muy similar cuando los otros agentes no son sinceros.",
        "En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes.",
        "Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1.",
        "Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz.",
        "Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término.",
        "Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG.",
        "En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG.",
        "Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente.",
        "Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila.",
        "Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada.",
        "A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS).",
        "Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores.",
        "Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones.",
        "El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos.",
        "La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros.",
        "El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos.",
        "Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice.",
        "Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1.",
        "En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente.",
        "Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo.",
        "Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad.",
        "El objetivo es adquirir al menos M unidades del bien al menor costo posible.",
        "El problema tiene cierto sabor del problema de la mochila continua.",
        "Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición.",
        "Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla.",
        "Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos.",
        "Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto.",
        "Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto).",
        "Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i.",
        "El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i.",
        "En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i.",
        "De lo contrario, decimos que xi es el rango medio.",
        "Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio.",
        "Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla.",
        "Consulte la Figura 2 para ver un ejemplo.",
        "LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio.",
        "Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada.",
        "Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico.",
        "Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular.",
        "Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero.",
        "Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo.",
        "El elemento x se asume que ya ha contribuido uj unidades.",
        "El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades.",
        "Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada.",
        "El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj.",
        "Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido.",
        "En cualquier otro grupo, podemos elegir como máximo un ancla.",
        "El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada.",
        "U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj).",
        "R es el número de unidades que quedan por adquirir.",
        "S es el conjunto de tuplas aceptadas en la actual solución tentativa 170.",
        "La mejor es la mejor solución encontrada hasta ahora.",
        "La variable Skip solo se utiliza en la demostración de corrección.",
        "Algoritmo Voraz( , j) 1.",
        "Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias.",
        "Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3.",
        "Escanea las tuplas en U en orden ordenado.",
        "Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i.",
        "Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila.",
        "Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente.",
        "Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i.",
        "Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible.",
        "Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor.",
        "Una excepción a esta regla es la tupla t.",
        "Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora.",
        "El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas.",
        "En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible.",
        "LEMMA 2. \n\nLEMMA 2.",
        "Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima.",
        "Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA.",
        "Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j).",
        "Considera el conjunto Skip al finalizar Greedy( , j).",
        "Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j).",
        "En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip.",
        "Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t).",
        "Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t).",
        "Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t).",
        "Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
        "En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip.",
        "Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original.",
        "Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada.",
        "Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso.",
        "Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St).",
        "También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas.",
        "Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución.",
        "El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j).",
        "Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada.",
        "Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio.",
        "Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución.",
        "Además, define x = xj − uj.",
        "Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j).",
        "Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2.",
        "Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n).",
        "Tenemos nuestro primer algoritmo de aproximación polinomial.",
        "TEOREMA 2.",
        "Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante).",
        "PRUEBA.",
        "Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio.",
        "Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2).",
        "Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma.",
        "La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada.",
        "La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico.",
        "Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP).",
        "Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1).",
        "En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada.",
        "Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada.",
        "Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i.",
        "Como convención, el agente i indexará la fila y el costo r indexará la columna.",
        "Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total.",
        "Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo.",
        "Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A).",
        "Que ε denote el factor de aproximación deseado.",
        "Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total.",
        "Sin embargo, la solución calculada podría no ser una solución óptima para el problema original.",
        "Mostramos que el error introducido está dentro de un factor de ε de la solución óptima.",
        "Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A).",
        "LEMMA 3. \n\nLEMMA 3.",
        "Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio.",
        "Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A).",
        "PRUEBA.",
        "Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0.",
        "Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas.",
        "Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r].",
        "Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo.",
        "En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades.",
        "Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r].",
        "Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε).",
        "LEMMA 4. \n\nLEMMA 4.",
        "Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima.",
        "Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN.",
        "Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj.",
        "Sea r = scost(x− ) el costo escalado asociado con el vector x− .",
        "Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r].",
        "Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica.",
        "Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas.",
        "Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A).",
        "Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible.",
        "Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades.",
        "Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj.",
        "Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗).",
        "Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones.",
        "Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista.",
        "Por lo tanto, tenemos el siguiente resultado.",
        "TEOREMA 3.",
        "Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε).",
        "La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n.",
        "CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes.",
        "Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno.",
        "En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez.",
        "Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta.",
        "De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i.",
        "Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez.",
        "La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso.",
        "La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes.",
        "Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante.",
        "De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte.",
        "Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo.",
        "Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente.",
        "En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado.",
        "Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i.",
        "Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1.",
        "Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl.",
        "El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones.",
        "En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε.",
        "Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε.",
        "Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j).",
        "Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas.",
        "Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás.",
        "Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j).",
        "Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas.",
        "Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones.",
        "Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada.",
        "Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5.",
        "Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima.",
        "Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i.",
        "PRUEBA.",
        "Desde antes, definimos el costo(A−i) = C(I \\ i).",
        "Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i).",
        "Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i).",
        "Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente.",
        "A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2.",
        "Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades.",
        "Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x.",
        "Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)).",
        "A partir de las desigualdades anteriores, tenemos yj l ≤ xj l.",
        "Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba.",
        "Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i.",
        "En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha.",
        "Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente.",
        "Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos.",
        "Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l.",
        "Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente.",
        "Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda.",
        "Que (g, h) sea el par actual.",
        "Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs.",
        "Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6.",
        "La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto.",
        "Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7.",
        "Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l.",
        "Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60.",
        "\"Begin y End representan los punteros de inicio y fin al conjunto factible.\"",
        "Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente.",
        "Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual.",
        "Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado.",
        "Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles.",
        "Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo.",
        "Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo.",
        "Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera.",
        "Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I).",
        "Utilizamos este límite para reducir los costos de la tupla.",
        "Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j).",
        "Las tablas de avance se utilizan para calcular C(I).",
        "Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior.",
        "Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo.",
        "El paso más costoso en el algoritmo es el cálculo de C(I \\ i).",
        "La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5.",
        "En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε).",
        "TEOREMA 4.",
        "Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ).",
        "Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes.",
        "Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante.",
        "Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada.",
        "La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j).",
        "La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ).",
        "Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente.",
        "Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico.",
        "En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal.",
        "Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5.",
        "CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente.",
        "Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0.",
        "Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable.",
        "Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual.",
        "REFERENCIAS [1] L M Ausubel y P R Milgrom.",
        "Subastas ascendentes con ofertas de paquetes.",
        "Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra.",
        "Programación lineal y subastas de Vickrey.",
        "Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy.",
        "El modelo de asignación de paquetes.",
        "Revista de Teoría Económica, 2002.",
        "Próximamente. [4] K Chatterjee y W Samuelson.",
        "Negociación bajo información incompleta.",
        "Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke.",
        "Precios escalonados de bienes públicos.",
        "Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra.",
        "Subastas combinatorias: Un estudio.",
        "Revista Informs sobre Computación, 2002.",
        "Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi.",
        "Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos.",
        "Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker.",
        "Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones.",
        "En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson.",
        "Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud.",
        "W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner.",
        "Complejidad computacional de algoritmos de aproximación para problemas combinatorios.",
        "En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves.",
        "Incentivos en equipos.",
        "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee.",
        "Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible.",
        "Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna.",
        "Teoría de subastas.",
        "Academic Press, 2002. [14] V Krishna y M Perry.",
        "Diseño de mecanismos eficientes.",
        "Informe técnico, Universidad Estatal de Pensilvania, 1998.",
        "Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham.",
        "Revelación de la verdad en subastas combinatorias aproximadamente eficientes.",
        "JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson.",
        "Diseño óptimo de subasta.",
        "Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite.",
        "Mecanismos eficientes para el comercio bilateral.",
        "Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen.",
        "Mecanismos VCG computacionalmente factibles.",
        "En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso.",
        "Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios.",
        "En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad.",
        "Subastas combinatorias manejables computacionalmente.",
        "Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer.",
        "Casi implementación de estrategia dominante.",
        "Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey.",
        "Contrarreforma, subastas y ofertas selladas competitivas.",
        "Revista de Finanzas, 16:8-37, 1961. 175"
    ],
    "error_count": 9,
    "keys": {
        "approximately-efficient and approximately strategyproof auction mechanism": {
            "translated_key": "mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "single-good multi-unit allocation problem": {
            "translated_key": "problema de asignación multiunidad de un solo bien",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a <br>single-good multi-unit allocation problem</br>.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a <br>single-good multi-unit allocation problem</br>."
            ],
            "translated_annotated_samples": [
                "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un <br>problema de asignación multiunidad de un solo bien</br>."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un <br>problema de asignación multiunidad de un solo bien</br>. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades. Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r]. Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε). LEMMA 4. \n\nLEMMA 4. Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN. Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj. Sea r = scost(x− ) el costo escalado asociado con el vector x− . Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r]. Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica. Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas. Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A). Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades. Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗). Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones. Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. TEOREMA 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε). La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n. CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno. En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez. Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta. De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i. Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez. La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso. La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes. Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante. De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado. Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1. Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl. El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones. En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε. Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε. Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j). Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas. Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás. Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j). Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones. Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada. Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5. Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i. PRUEBA. Desde antes, definimos el costo(A−i) = C(I \\ i). Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i). Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i). Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente. A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2. Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades. Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x. Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)). A partir de las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i. En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha. Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente. Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos. Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l. Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda. Que (g, h) sea el par actual. Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs. Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6. La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto. Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7. Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l. Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60. \"Begin y End representan los punteros de inicio y fin al conjunto factible.\" Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles. Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo. Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo. Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I). Utilizamos este límite para reducir los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j). Las tablas de avance se utilizan para calcular C(I). Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más costoso en el algoritmo es el cálculo de C(I \\ i). La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5. En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε). TEOREMA 4. Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ). Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada. La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j). La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ). Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente. Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico. En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal. Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5. CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0. Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual. REFERENCIAS [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Revista de Teoría Económica, 2002. Próximamente. [4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra. Subastas combinatorias: Un estudio. Revista Informs sobre Computación, 2002. Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos. Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker. Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones. En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud. W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee. Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible. Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna. Teoría de subastas. Academic Press, 2002. [14] V Krishna y M Perry. Diseño de mecanismos eficientes. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios. En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer. Casi implementación de estrategia dominante. Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey. Contrarreforma, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. 175 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "fully polynomial-time approximation scheme": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a <br>fully polynomial-time approximation scheme</br> for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a <br>fully polynomial-time approximation scheme</br> for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our <br>fully polynomial-time approximation scheme</br> (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a <br>fully polynomial-time approximation scheme</br> for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "First, we develop a <br>fully polynomial-time approximation scheme</br> for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "INTRODUCTION In this paper we present a <br>fully polynomial-time approximation scheme</br> for the single-good multi-unit auction problem.",
                "In turn, we use this basic approximation to develop our <br>fully polynomial-time approximation scheme</br> (FPTAS).",
                "CONCLUSIONS We presented a <br>fully polynomial-time approximation scheme</br> for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language."
            ],
            "translated_annotated_samples": [
                "Primero, desarrollamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas.",
                "En este documento presentamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de subasta multiunidad de un solo bien.",
                "A su vez, utilizamos esta aproximación básica para desarrollar nuestro <br>esquema de aproximación en tiempo polinómico completo</br> (FPTAS).",
                "CONCLUSIONES Presentamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro <br>esquema de aproximación en tiempo polinómico completo</br> (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades. Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r]. Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε). LEMMA 4. \n\nLEMMA 4. Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN. Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj. Sea r = scost(x− ) el costo escalado asociado con el vector x− . Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r]. Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica. Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas. Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A). Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades. Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗). Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones. Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. TEOREMA 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε). La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n. CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno. En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez. Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta. De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i. Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez. La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso. La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes. Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante. De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado. Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1. Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl. El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones. En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε. Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε. Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j). Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas. Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás. Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j). Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones. Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada. Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5. Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i. PRUEBA. Desde antes, definimos el costo(A−i) = C(I \\ i). Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i). Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i). Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente. A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2. Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades. Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x. Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)). A partir de las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i. En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha. Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente. Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos. Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l. Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda. Que (g, h) sea el par actual. Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs. Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6. La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto. Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7. Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l. Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60. \"Begin y End representan los punteros de inicio y fin al conjunto factible.\" Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles. Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo. Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo. Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I). Utilizamos este límite para reducir los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j). Las tablas de avance se utilizan para calcular C(I). Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más costoso en el algoritmo es el cálculo de C(I \\ i). La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5. En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε). TEOREMA 4. Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ). Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada. La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j). La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ). Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente. Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico. En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal. Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5. CONCLUSIONES Presentamos un <br>esquema de aproximación de tiempo polinómico completo</br> para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0. Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual. REFERENCIAS [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Revista de Teoría Económica, 2002. Próximamente. [4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra. Subastas combinatorias: Un estudio. Revista Informs sobre Computación, 2002. Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos. Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker. Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones. En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud. W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee. Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible. Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna. Teoría de subastas. Academic Press, 2002. [14] V Krishna y M Perry. Diseño de mecanismos eficientes. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios. En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer. Casi implementación de estrategia dominante. Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey. Contrarreforma, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. 175 ",
            "candidates": [],
            "error": [
                [
                    "esquema de aproximación de tiempo polinómico completo",
                    "esquema de aproximación de tiempo polinómico completo",
                    "esquema de aproximación en tiempo polinómico completo",
                    "esquema de aproximación de tiempo polinómico completo"
                ]
            ]
        },
        "vickrey-clarke-grove": {
            "translated_key": "Vickrey-Clarke-Grove",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "forward auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a <br>forward auction</br> variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the <br>forward auction</br>, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the <br>forward auction</br> and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the <br>forward auction</br> to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price <br>forward auction</br> Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the <br>forward auction</br> bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a <br>forward auction</br>, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the <br>forward auction</br>, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this <br>forward auction</br>, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the <br>forward auction</br> symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the <br>forward auction</br> direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "We consider both a reverse auction variation and a <br>forward auction</br> variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the <br>forward auction</br>, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the <br>forward auction</br> and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the <br>forward auction</br> to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price <br>forward auction</br> Bid Figure 1: Marginal-decreasing, piecewise constant bids."
            ],
            "translated_annotated_samples": [
                "Consideramos tanto una variación de subasta inversa como una variación de <br>subasta directa</br>, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal.",
                "En la <br>subasta ascendente</br>, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos.",
                "El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la <br>subasta ascendente</br> y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema.",
                "Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la <br>subasta hacia adelante</br> establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica.",
                "Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de <br>subasta directa</br>, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la <br>subasta ascendente</br>, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la <br>subasta ascendente</br> y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la <br>subasta hacia adelante</br> establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. ",
            "candidates": [],
            "error": [
                [
                    "subasta directa",
                    "subasta ascendente",
                    "subasta ascendente",
                    "subasta hacia adelante"
                ]
            ]
        },
        "reverse auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a <br>reverse auction</br> variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the <br>reverse auction</br>, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the <br>reverse auction</br>, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the <br>reverse auction</br>, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and <br>reverse auction</br> multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the <br>reverse auction</br> to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "<br>reverse auction</br> Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the <br>reverse auction</br> bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the <br>reverse auction</br>.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the <br>reverse auction</br>, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the <br>reverse auction</br> is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the <br>reverse auction</br> when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the <br>reverse auction</br> symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the <br>reverse auction</br>, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the <br>reverse auction</br> variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a <br>reverse auction</br>, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "We consider both a <br>reverse auction</br> variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the <br>reverse auction</br>, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the <br>reverse auction</br>, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "Specifically, in the <br>reverse auction</br>, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "We also discuss the economic properties of VCG mechanisms in these forward and <br>reverse auction</br> multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language."
            ],
            "translated_annotated_samples": [
                "Consideramos tanto una variación de <br>subasta inversa</br> como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal.",
                "En la <br>subasta inversa</br>, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos.",
                "El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la <br>subasta descendente</br>, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema.",
                "Específicamente, en la <br>subasta inversa</br>, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i.",
                "También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de <br>subasta inversa</br> como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la <br>subasta inversa</br>, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la <br>subasta descendente</br>, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la <br>subasta inversa</br>, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. ",
            "candidates": [],
            "error": [
                [
                    "subasta inversa",
                    "subasta inversa",
                    "subasta descendente",
                    "subasta inversa"
                ]
            ]
        },
        "equilibrium": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the <br>equilibrium</br> prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in <br>equilibrium</br>; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in <br>equilibrium</br> each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in <br>equilibrium</br>, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive <br>equilibrium</br>.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "The focus of this paper is also different: it investigates the <br>equilibrium</br> prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in <br>equilibrium</br>; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "Again, in <br>equilibrium</br> each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in <br>equilibrium</br>, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive <br>equilibrium</br>."
            ],
            "translated_annotated_samples": [
                "El enfoque de este artículo también es diferente: investiga los <br>precios de equilibrio</br> utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes.",
                "Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en <br>equilibrio</br>; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema.",
                "Nuevamente, en <br>equilibrio</br>, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I).",
                "Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en <br>equilibrio</br>, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i.",
                "Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un <br>equilibrio</br> competitivo."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los <br>precios de equilibrio</br> utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en <br>equilibrio</br>; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en <br>equilibrio</br>, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en <br>equilibrio</br>, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un <br>equilibrio</br> competitivo. ",
            "candidates": [],
            "error": [
                [
                    "precios de equilibrio",
                    "equilibrio",
                    "equilibrio",
                    "equilibrio",
                    "equilibrio"
                ]
            ]
        },
        "marginal-decreasing piecewise constant curve": {
            "translated_key": "curvas constantes por tramos con disminución marginal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows <br>marginal-decreasing piecewise constant curve</br>s.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows <br>marginal-decreasing piecewise constant curve</br>s.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "The bidding language in our auctions allows <br>marginal-decreasing piecewise constant curve</br>s.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows <br>marginal-decreasing piecewise constant curve</br>s."
            ],
            "translated_annotated_samples": [
                "El lenguaje de oferta en nuestras subastas permite <br>curvas constantes por tramos con disminución marginal</br>.",
                "Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite <br>curvas constantes por tramos con disminución marginal</br>."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite <br>curvas constantes por tramos con disminución marginal</br>. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite <br>curvas constantes por tramos con disminución marginal</br>. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades. Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r]. Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε). LEMMA 4. \n\nLEMMA 4. Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN. Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj. Sea r = scost(x− ) el costo escalado asociado con el vector x− . Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r]. Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica. Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas. Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A). Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades. Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗). Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones. Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. TEOREMA 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε). La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n. CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno. En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez. Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta. De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i. Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez. La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso. La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes. Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante. De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado. Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1. Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl. El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones. En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε. Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε. Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j). Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas. Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás. Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j). Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones. Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada. Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5. Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i. PRUEBA. Desde antes, definimos el costo(A−i) = C(I \\ i). Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i). Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i). Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente. A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2. Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades. Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x. Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)). A partir de las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i. En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha. Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente. Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos. Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l. Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda. Que (g, h) sea el par actual. Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs. Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6. La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto. Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7. Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l. Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60. \"Begin y End representan los punteros de inicio y fin al conjunto factible.\" Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles. Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo. Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo. Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I). Utilizamos este límite para reducir los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j). Las tablas de avance se utilizan para calcular C(I). Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más costoso en el algoritmo es el cálculo de C(I \\ i). La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5. En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε). TEOREMA 4. Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ). Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada. La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j). La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ). Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente. Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico. En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal. Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5. CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0. Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual. REFERENCIAS [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Revista de Teoría Económica, 2002. Próximamente. [4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra. Subastas combinatorias: Un estudio. Revista Informs sobre Computación, 2002. Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos. Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker. Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones. En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud. W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee. Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible. Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna. Teoría de subastas. Academic Press, 2002. [14] V Krishna y M Perry. Diseño de mecanismos eficientes. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios. En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer. Casi implementación de estrategia dominante. Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey. Contrarreforma, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. 175 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "bidding language": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The <br>bidding language</br> in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive <br>bidding language</br> that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or <br>bidding language</br> quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor <br>bidding language</br>-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise <br>bidding language</br> that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing <br>bidding language</br>.",
                "This <br>bidding language</br> is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise <br>bidding language</br> is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant <br>bidding language</br>.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "The <br>bidding language</br> in our auctions allows marginal-decreasing piecewise constant curves.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive <br>bidding language</br> that allows marginal-decreasing piecewise constant curves.",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or <br>bidding language</br> quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor <br>bidding language</br>-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise <br>bidding language</br> that is used in our forward and reverse auctions."
            ],
            "translated_annotated_samples": [
                "El <br>lenguaje de oferta</br> en nuestras subastas permite curvas constantes por tramos con disminución marginal.",
                "Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un <br>lenguaje de oferta</br> compacto y expresivo que permite curvas constantes por tramos con disminución marginal.",
                "Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un <br>lenguaje de oferta exclusiva-o</br> expresivo rápidamente rompe estos casos especiales.",
                "Identificamos un problema de asignación no trivial pero aproximable con un <br>lenguaje de oferta</br> exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta.",
                "En esta sección, primero describimos el <br>lenguaje de oferta por tramos decrecientes marginales</br> que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El <br>lenguaje de oferta</br> en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un <br>lenguaje de oferta</br> compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un <br>lenguaje de oferta exclusiva-o</br> expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un <br>lenguaje de oferta</br> exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el <br>lenguaje de oferta por tramos decrecientes marginales</br> que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. ",
            "candidates": [],
            "error": [
                [
                    "lenguaje de oferta",
                    "lenguaje de oferta",
                    "lenguaje de oferta exclusiva-o",
                    "lenguaje de oferta",
                    "lenguaje de oferta por tramos decrecientes marginales"
                ]
            ]
        },
        "dynamic programming": {
            "translated_key": "programación dinámica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a <br>dynamic programming</br> algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the <br>dynamic programming</br> (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a <br>dynamic programming</br> table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the <br>dynamic programming</br> table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This <br>dynamic programming</br> algorithm is only pseudo-polynomial, since the number of column in the <br>dynamic programming</br> table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the <br>dynamic programming</br> table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the <br>dynamic programming</br> table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our <br>dynamic programming</br> tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of <br>dynamic programming</br> table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two <br>dynamic programming</br> tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled <br>dynamic programming</br> algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new <br>dynamic programming</br> table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "We use a <br>dynamic programming</br> algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the <br>dynamic programming</br> (DP) table.",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a <br>dynamic programming</br> table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the <br>dynamic programming</br> table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "This <br>dynamic programming</br> algorithm is only pseudo-polynomial, since the number of column in the <br>dynamic programming</br> table depends upon the total cost.",
                "Finally, given the <br>dynamic programming</br> table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r]."
            ],
            "translated_annotated_samples": [
                "Utilizamos un algoritmo de <br>programación dinámica</br> para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de <br>programación dinámica</br> (DP).",
                "En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de <br>programación dinámica</br> para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada.",
                "Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de <br>programación dinámica</br>: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i.",
                "Este algoritmo de <br>programación dinámica</br> es solo seudo-polinómico, ya que el número de columnas en la tabla de <br>programación dinámica</br> depende del costo total.",
                "Finalmente, dado la tabla de <br>programación dinámica</br> para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de <br>programación dinámica</br> para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de <br>programación dinámica</br> (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de <br>programación dinámica</br> para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de <br>programación dinámica</br>: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de <br>programación dinámica</br> es solo seudo-polinómico, ya que el número de columnas en la tabla de <br>programación dinámica</br> depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de <br>programación dinámica</br> para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "approximation algorithm": {
            "translated_key": "algoritmo de aproximación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the <br>approximation algorithm</br> to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the <br>approximation algorithm</br>, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The <br>approximation algorithm</br> is very similar to the <br>approximation algorithm</br> for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our <br>approximation algorithm</br> returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the <br>approximation algorithm</br> before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial <br>approximation algorithm</br>.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-<br>approximation algorithm</br> presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-<br>approximation algorithm</br> providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy <br>approximation algorithm</br> to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 <br>approximation algorithm</br>, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the <br>approximation algorithm</br> to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the <br>approximation algorithm</br>, and make the algorithm implement the allocation with value V (I).",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The <br>approximation algorithm</br> is very similar to the <br>approximation algorithm</br> for knapsack.",
                "Suppose our <br>approximation algorithm</br> returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the <br>approximation algorithm</br> before termination on the modified instance, and let St be the corresponding tentative solution set in that step."
            ],
            "translated_annotated_samples": [
                "Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el <br>algoritmo de aproximación</br> implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo.",
                "Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el <br>algoritmo de aproximación</br> y hacer que el algoritmo implemente la asignación con valor V (I).",
                "Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El <br>algoritmo de aproximación</br> es muy similar al <br>algoritmo de aproximación</br> para la mochila.",
                "Supongamos que nuestro <br>algoritmo de aproximación</br> devuelve el valor V( , j) para esta instancia modificada.",
                "Sea t la última tupla considerada por el <br>algoritmo de aproximación</br> antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el <br>algoritmo de aproximación</br> implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el <br>algoritmo de aproximación</br> y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El <br>algoritmo de aproximación</br> es muy similar al <br>algoritmo de aproximación</br> para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro <br>algoritmo de aproximación</br> devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el <br>algoritmo de aproximación</br> antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "multi-unit auction": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-Strategyproof and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good <br>multi-unit auction</br> problem.",
                "Our scheme is both approximately efficient and approximately strategyproof.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-strategyproof for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and strategyproof approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price <br>multi-unit auction</br> for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-STRATEGYPROOF VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-strategyproof multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is strategyproof for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains strategyproof for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) strategyproof for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-strategyproof approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good <br>multi-unit auction</br> problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately strategyproof within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good <br>multi-unit auction</br> problem.",
                "Ausubel [1] has proposed an ascending-price <br>multi-unit auction</br> for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good <br>multi-unit auction</br> problem, using marginal decreasing piecewise constant bidding language."
            ],
            "translated_annotated_samples": [
                "En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de <br>subasta multiunidad</br> de un solo bien.",
                "Ausubel ha propuesto una <br>subasta de múltiples unidades</br> con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual.",
                "CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de <br>subasta multiunidad</br> de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente a prueba de estrategias para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de <br>subasta multiunidad</br> de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente a prueba de estrategias. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-estrategia-veraz para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y a prueba de estrategias para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una <br>subasta de múltiples unidades</br> con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente a prueba de estrategias VCG. Continuando, introducimos el mecanismo VCG para el problema y los resultados de ε-dominancia para aproximaciones a los resultados de VCG. También discutimos las propiedades económicas de los mecanismos VCG en estos entornos de subasta multiunidad de tipo forward y reverse. 2.1 Pujas por tramos decrecientes marginalmente Proporcionamos un lenguaje de pujas constante por tramos y decreciente marginalmente. Este lenguaje de oferta es expresivo para una clase natural de funciones de valoración y costos: precios unitarios fijos sobre intervalos de cantidades. Consulta la Figura 1 para ver un ejemplo. Además, relajamos ligeramente el requisito de disminución marginal para permitir que: un postor en la subasta hacia adelante establezca un monto mínimo de compra, de modo que tenga un valor cero para cantidades menores a ese monto; un vendedor en la subasta inversa establezca una restricción de capacidad, de modo que tenga un costo efectivamente infinito para suministrar cantidades superiores a una cantidad específica. Subasta inversa Oferta 7 5 10 20 25 10 8 Cantidad Precio 7 5 10 20 25 10 8 Cantidad Precio Subasta directa Oferta Figura 1: Ofertas marginales decrecientes y constantes por tramos. En la subasta de oferta ascendente, el postor ofrece $10 por unidad para cantidades en el rango [5, 10), $8 por unidad en el rango [10, 20), y $7 en el rango [20, 25]. Su valoración es cero para cantidades fuera del rango [10, 25]. En la subasta inversa, el costo del vendedor es ∞ fuera del rango [10, 25]. En detalle, en una subasta ascendente, una oferta del comprador i puede ser escrita como una lista de tuplas (rango de cantidad, precio unitario), ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), con un límite superior umi i en la cantidad. La interpretación es que la valoración de los postores en el rango de cantidad 167 (semiabierto) [uj i , uj+1 i ) es pj i para cada unidad. Además, se asume que la valoración es 0 para cantidades menores que u1 i, así como para cantidades mayores que um i. Esto se implementa añadiendo dos tuplas de oferta ficticias, con precios de cero en el rango [0, u1 i ) y (umi i , ∞). Interpretamos la lista de ofertas como la definición de una función de precio, pbid,i(q) = qpj i , si uj i ≤ q < uj+1 i , donde j = 1, 2, . . . , mi −1. Para resolver la condición de límite, asumimos que el precio de oferta para la cantidad límite superior umi i es pbid,i(umi i ) = umi i pmi−1 i. Una oferta de vendedor se define de manera similar en la subasta inversa. La interpretación es que el costo de los postores en el rango de cantidad (semiabierto) [uj i , uj+1 i ) es pj i por cada unidad. Además, se asume que el costo es ∞ para cantidades menores que u1 i y también para cantidades mayores que um i. De manera equivalente, los precios unitarios en los rangos [0, u1 i ) y (um i , ∞) son infinito. Interpretamos la lista de ofertas como la definición de una función de precio, pask,i(q) = qpj i , si uj i ≤ q < uj+1 i. 2.2 Subastas Multiunidad basadas en VCG Construimos subastas multiunidad manejables y aproximadamente a prueba de estrategias alrededor de un mecanismo VCG. Suponemos que todos los agentes tienen funciones de utilidad cuasilineales; es decir, ui(q, p) = vi(q)− p, para un comprador i con valoración vi(q) por q unidades a un precio p, y ui(q, p) = p − ci(q) para un vendedor i con costo ci(q) a un precio p. Esta es una suposición estándar en la literatura de subastas, equivalente a asumir agentes neutrales al riesgo [13]. Usaremos el término \"pago\" de forma intercambiable con \"utilidad\". En la subasta ascendente, hay un vendedor con M unidades para vender. Suponemos que este vendedor no tiene un valor intrínseco para los artículos. Dado un conjunto de ofertas de I agentes, sea V(I) el ingreso máximo para el vendedor, dado que se puede seleccionar como máximo un punto en la curva de oferta de cada agente y no se pueden vender más de M unidades del artículo. Sea x∗ = (x∗ 1, . . . , x∗ N ) la solución a este problema de determinación del ganador, donde x∗ i es el número de unidades vendidas al agente i. De manera similar, sea V (I \\ i) el ingreso máximo para el vendedor sin ofertas del agente i. El mecanismo VCG se define de la siguiente manera: 1. Recibe curvas de oferta constantes por tramos y restricciones de capacidad de todos los compradores. 2. Implementar el resultado x∗ que resuelve el problema de determinación del ganador con todos los compradores. 3. Recauda el pago pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] de cada comprador y pasa los pagos al vendedor. En esta subasta ascendente, el mecanismo VCG es a prueba de estrategias para los compradores, lo que significa que hacer ofertas honestas es una estrategia dominante, es decir, maximiza la utilidad independientemente de las ofertas de otros compradores. Además, el mecanismo VCG es eficiente en términos de asignación, y los pagos de cada comprador son siempre positivos. Además, cada comprador paga menos que su valor, y recibe un beneficio de V(I) - V(I \\ i) en equilibrio; esto es precisamente el valor marginal que el comprador i contribuye a la eficiencia económica del sistema. En la subasta inversa, hay un comprador con M unidades para comprar y n proveedores. Suponemos que el comprador tiene un valor V > 0 para comprar todas las M unidades, pero un valor de cero en caso contrario. Para simplificar el problema de diseño del mecanismo, asumimos que el comprador anunciará sinceramente este valor al mecanismo. De hecho, el mecanismo VCG maximiza el pago esperado al vendedor entre todos los mecanismos eficientes, incluso permitiendo implementaciones de Bayes-Nash. Sin esta suposición, el resultado de imposibilidad de Myerson-Satterthwaite ya implicaría que no deberíamos esperar un mecanismo de intercambio eficiente en este escenario. El problema de determinación del ganador en la subasta inversa es determinar la asignación, x∗, que minimiza el costo para el comprador, o renunciar al intercambio si el costo mínimo es mayor que el valor, V. Que C(I) denote el costo mínimo dado los presupuestos de todos los vendedores, y que C(I \\i) denote el costo mínimo sin los presupuestos del vendedor i. Podemos asumir, sin pérdida de generalidad, que existe un comercio eficiente y V ≥ C(I). De lo contrario, el resultado eficiente es la ausencia de intercambio, y el resultado del mecanismo VCG es la ausencia de intercambio y de pagos. El mecanismo VCG implementa el resultado x∗ que minimiza el costo basado en las ofertas de todos los vendedores, y luego proporciona el pago pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] a cada vendedor. El pago total se recoge del comprador. Nuevamente, en equilibrio, la ganancia de cada vendedor es exactamente el valor marginal que el vendedor contribuye a la eficiencia económica del sistema; en el caso simple en el que V ≥ C(I \\ i) para todos los vendedores i, esto es precisamente C(I \\ i) − C(I). Aunque el mecanismo VCG sigue siendo a prueba de estrategias para los vendedores en la dirección inversa, su aplicabilidad está limitada a casos en los que los pagos totales a los vendedores son menores que el valor de los compradores. De lo contrario, habrá casos en los que el comprador no elija participar voluntariamente en el mecanismo, basándose en su propio valor y sus creencias sobre los costos de los vendedores. Esto conduce a una pérdida de eficiencia cuando el comprador elige no participar, ya que se pierden intercambios eficientes. Este problema con el tamaño de los pagos no ocurre en subastas inversas simples de un solo artículo, ni siquiera en subastas inversas de múltiples unidades con un comprador que tiene una valoración marginal constante para cada artículo adicional que adquiere. Intuitivamente, el problema ocurre en el entorno de subastas inversas de múltiples unidades porque el comprador demanda un número fijo de artículos y no tiene valor sin ellos. Esto lleva a la posibilidad de que el comercio esté condicionado a la presencia de vendedores particulares, llamados vendedores clave. Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V. \n\nDefine a un vendedor i como pivotal, si C(I) ≤ V pero C(I\\i) > V. En otras palabras, no habría comercio eficiente sin el vendedor. Cada vez que hay un vendedor clave, los pagos VCG a ese vendedor le permiten extraer todo el excedente, y los pagos son demasiado grandes para sostenerse con el valor de los compradores a menos que este sea el único vendedor ganador. Concretamente, tenemos este problema de participación en la subasta inversa cuando el pago total a los vendedores, en equilibrio, supera el pago total de la asignación eficiente: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] Como se mencionó anteriormente, primero notemos que requerimos V > C(I \\ i) para todos los vendedores i. En otras palabras, no debe haber vendedores clave. Dado esto, es entonces necesario y suficiente que: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) Para que la subasta inversa sea simétrica con la dirección hacia adelante, necesitaríamos un comprador con un valor marginal constante para comprar las primeras M unidades, y un valor cero para unidades adicionales. Los pagos a los vendedores nunca superarían el valor de los compradores en este caso. Por el contrario, para hacer la subasta ascendente simétrica con la subasta descendente, necesitaríamos un vendedor con un costo marginal constante (y alto) para vender cualquier cosa menos de las primeras M unidades, y luego un costo marginal bajo (o cero). Los pagos totales recibidos por el vendedor pueden ser inferiores al costo del vendedor por el resultado en este caso. En palabras, el excedente de la asignación eficiente debe ser mayor que el excedente marginal total proporcionado por cada vendedor. Considera un ejemplo con 3 agentes {1, 2, 3}, y V = 150 y C(123) = 50. La condición (1) se cumple cuando C(12) = C(23) = 70 y C(13) = 100, pero no cuando C(12) = C(23) = 80 y C(13) = 100. En el primer caso, las ganancias del agente π = (π0, π1, π2, π3), donde 0 es el vendedor, son (10, 20, 50, 20). En el segundo caso, los pagos son π = (−10, 30, 50, 30). Una cosa que sabemos, porque el mecanismo VCG maximizará el pago al comprador a través de todos los mecanismos eficientes [14], es que siempre que la Ec. 1 no se cumpla, no puede haber un mecanismo de subasta eficiente. 2.3 ε-Strategyproofness Ahora consideramos el mismo mecanismo VCG, pero con un esquema de aproximación para el problema de asignación subyacente. Obtenemos un resultado de ε-estrategia a prueba de manipulaciones, que limita la ganancia máxima en el pago que un agente puede esperar lograr a través de una desviación unilateral de seguir una estrategia simple que revela la verdad. Describimos el resultado para la dirección de la subasta hacia adelante, pero es una observación bastante general. Como antes, sea V(I) el valor de la solución óptima al problema de asignación con ofertas veraces de todos los agentes, y V(I \\i) el valor de la solución óptima calculada sin las ofertas del agente i. Que ˆV (I) y ˆV (I \\ i) denoten el valor de la asignación calculado con un esquema de aproximación, y suponga que la aproximación cumple con: (1 + ) ˆV (I) ≥ V (I) para algún > 0. Proporcionamos un esquema de aproximación para nuestra configuración más adelante en el artículo. Que ˆx denote la asignación implementada por el esquema de aproximación. El pago para el agente i, al anunciar la valoración ˆvi, es: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) El término final es independiente del valor anunciado por los agentes, y puede ser ignorado en un análisis de incentivos. Sin embargo, el agente i puede intentar mejorar su recompensa a través del efecto de su valor anunciado en la asignación ˆx implementada por el mecanismo. En particular, el agente i desea que el mecanismo seleccione ˆx para maximizar la suma de su valor real, vi(ˆxi), y el valor reportado de los otros agentes, Èj=i ˆvj (ˆxj). Si el algoritmo de asignación de mecanismos es óptimo, entonces todo lo que el agente necesita hacer es declarar honestamente su valor y el mecanismo hará el resto. Sin embargo, ante un algoritmo de asignación aproximado, el agente puede intentar mejorar su recompensa anunciando un valor que corrija la aproximación, y provoque que el algoritmo de aproximación implemente la asignación que maximiza exactamente el valor total informado de los otros agentes junto con su propio valor real. Esta condición está implícita en el requisito de que los agentes sean sustitutos, que ha recibido cierta atención en la literatura de subastas combinatorias porque caracteriza el caso en el que los pagos VCG pueden ser respaldados en un equilibrio competitivo. Las caracterizaciones útiles de las condiciones que satisfacen a los agentes como sustitutos, en términos de las valoraciones subyacentes de los agentes, han resultado bastante esquivas. Además, aunque existe una pequeña literatura sobre mecanismos de eficiencia máxima sujetos a requisitos de participación voluntaria y equilibrio presupuestario (es decir, con el mecanismo sin introducir o eliminar dinero), los resultados analíticos solo se conocen para problemas simples (por ejemplo, [16, 4]). Ahora podemos analizar la mejor ganancia posible de la manipulación para un agente en nuestro entorno. Primero asumimos que los otros agentes son veraces, y luego flexibilizamos esto. En ambos casos, el beneficio máximo para el agente i ocurre cuando la aproximación inicial es la peor posible. Con informes veraces de otros agentes, esto ocurre cuando el valor de la elección ˆx es V (I)/(1 + ε). Entonces, un agente podría esperar recibir un beneficio mejorado de: V (I) − V (I) 1 + ε = ε 1 + ε V (I). Esto es posible si el agente es capaz de seleccionar un tipo informado para corregir el algoritmo de aproximación y hacer que el algoritmo implemente la asignación con valor V (I). Por lo tanto, si otros agentes son veraces, y con un esquema de aproximación (1 + ε) para el problema de asignación, entonces ningún agente puede mejorar su ganancia en más de un factor ε/(1 + ε) del valor de la solución óptima. El análisis es muy similar cuando los otros agentes no son sinceros. En este caso, un agente individual puede mejorar su recompensa en no más de un factor /(1 + ) del valor de la solución óptima dada los valores reportados por los otros agentes. Que V en el siguiente teorema defina el valor total de la asignación eficiente, dado los valores reportados de los agentes j = i, y el valor real del agente i. TEOREMA 1. Un mecanismo basado en VCG con un algoritmo de asignación (1 + ε) es (1+ −V ) a prueba de estrategias para el agente i, y el agente i puede obtener como máximo esta ganancia a través de alguna estrategia no veraz. Observa que no fue necesario acotar el error en los problemas de asignación sin cada agente, ya que el resultado de ser -estrictamente veraz se sigue de la precisión del primer término en el pago VCG y es independiente de la precisión del segundo término. Sin embargo, la precisión de la solución al problema sin cada agente es importante para implementar una buena aproximación a las propiedades de ingresos del mecanismo VCG. En esta sección, diseñamos un esquema de aproximación polinómica completa para el problema de la mochila generalizada, que modela el problema de determinación de ganadores para las subastas multiunidad basadas en VCG. Describimos nuestros resultados para la variación de la subasta inversa, pero la formulación es completamente simétrica para la subasta ascendente. Al describir nuestro esquema de aproximación, comenzamos con una propiedad simple (la propiedad Ancla) de una solución óptima de la mochila. Utilizamos esta propiedad para desarrollar una aproximación de 2 tiempos O(n2) para la mochila generalizada. A su vez, utilizamos esta aproximación básica para desarrollar nuestro esquema de aproximación en tiempo polinómico completo (FPTAS). Uno de los principales atractivos de nuestro lenguaje de oferta por tramos es su representación compacta de las funciones de valoración de los postores. Nos esforzamos por preservar esto, y presentamos un esquema de aproximación que dependerá solo del número de postores, y no de la cantidad máxima, M, que puede ser muy grande en entornos realistas de adquisiciones. El FPTAS implementa una aproximación (1 + ε) a la solución óptima x∗, en un tiempo de peor caso T = O(n3 /ε), donde n es el número de postores, y donde asumimos que la oferta segmentada para cada postor tiene O(1) segmentos. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de 169 piezas c, entonces el tiempo de ejecución se puede derivar sustituyendo nc por cada ocurrencia de n. 3.1 Preliminares Antes de comenzar, recordemos el clásico problema de la mochila 0/1: se nos da un conjunto de n elementos, donde el elemento i tiene un valor vi y un tamaño si, y una mochila de capacidad M; todos los tamaños son enteros. El objetivo es determinar un subconjunto de elementos de valor máximo con un tamaño total de como máximo M. Dado que queremos enfocarnos en una subasta inversa, el problema de la mochila equivalente será elegir un conjunto de elementos con valor mínimo (es decir, costo) cuyo tamaño exceda M. El problema de la mochila generalizado de interés para nosotros se puede definir de la siguiente manera: Problema de la mochila generalizado: Instancia: Un objetivo M y un conjunto de n listas, donde la i-ésima lista tiene la forma Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , donde uj i son crecientes con j y pj i son decrecientes con j, y uj i , pj i , M son enteros positivos. Problema: Determinar un conjunto de enteros xj i de manera que 1. (Uno por lista) Como máximo un xj i es distinto de cero para cualquier i, 2. (Pertenencia) xj i = 0 implica xj i ∈ [uj i , uj+1 i ), 3. (Objetivo) Èi Èj xj i ≥ M, y 4. (Objetivo) Èi Èj pj i xj i se minimice. Esta formulación generalizada de la mochila es una generalización clara de la clásica mochila 0/1. En este último, cada lista consiste en un único punto (si, vi). La conexión entre la mochila generalizada y nuestro problema de subasta es transparente. Cada lista codifica una oferta, representando múltiples intervalos de cantidad mutuamente excluyentes, y se puede elegir cualquier cantidad en un intervalo, pero como máximo se puede seleccionar un intervalo. Elegir el intervalo [uj i , uj+1 i ) tiene un costo de pj i por unidad. El objetivo es adquirir al menos M unidades del bien al menor costo posible. El problema tiene cierto sabor del problema de la mochila continua. Sin embargo, hay dos diferencias principales que hacen que nuestro problema sea significativamente más difícil: (1) los intervalos tienen límites, por lo que elegir el intervalo [uj i , uj+1 i ) requiere que se tomen al menos uj i y como máximo uj+1 i unidades; (2) a diferencia de la mochila clásica, no podemos ordenar los elementos (ofertas) por valor/tamaño, ya que diferentes intervalos en una lista tienen costos unitarios diferentes. 3.2 Un Esquema de Aproximación de 2 We comenzamos con una definición. Dado una instancia de la mochila generalizada, llamamos a cada tupla tj i = (uj i , pj i ) un ancla. Recuerde que estas tuplas representan los puntos de quiebre en las ofertas de curva constante por tramos. Decimos que el tamaño de un ancla tj i es uj i, 8 De hecho, debido a la restricción de uno por lista, el problema generalizado se asemeja más al problema de la mochila de selección múltiple [9], donde el conjunto subyacente de elementos se divide en subconjuntos disjuntos U1, U2, . . . , Uk, y se puede elegir como máximo un elemento de cada subconjunto. Existen PTAS para este problema [10], y de hecho, se puede convertir nuestro problema en una gran instancia del problema de la mochila de selección múltiple, creando un grupo para cada lista; colocar un par de puntos (cantidad, precio) (x, p) para cada cantidad posible para un postor en su grupo (subconjunto). Sin embargo, esta conversión hace que el tamaño del problema explote, volviéndolo inviable para todos menos los casos más triviales. el número mínimo de unidades disponibles a este precio de anclaje pj i. El costo del ancla tj i se define como el precio total mínimo asociado con esta tupla, es decir, coste(tj i) = pj i uj i si j < mi, y coste(tmi i) = pmi−1 i umi i. En una solución factible {x1, x2, . . . , xn} del problema de la mochila generalizado, decimos que un elemento xi = 0 es un ancla si xi = uj i , para algún ancla uj i. De lo contrario, decimos que xi es el rango medio. Observamos que una solución óptima de la mochila siempre se puede construir de manera que como máximo un elemento de la solución esté en el rango medio. Si hay dos elementos de rango medio x y x, para ofertas de dos agentes diferentes, con x ≤ x, entonces podemos incrementar x y decrementar x, hasta que uno de ellos se convierta en un ancla. Consulte la Figura 2 para ver un ejemplo. LEMMA 1. [Propiedad de Anclaje] Existe una solución óptima del problema de la mochila generalizada con a lo sumo un elemento de rango medio. Todos los demás elementos son anclas. 1 oferta de rango medio 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad 5 20 15 10 25 5 25 30201510 35 3 2 1 Precio Cantidad (i) Solución óptima con 2 ofertas de rango medio (ii) Solución óptima con Figura 2: (i) Una solución óptima con más de una oferta no anclada (2,3); (ii) una solución óptima con solo una oferta (3) no anclada. Utilizamos la propiedad del ancla para obtener primero un esquema de aproximación 2 en tiempo polinómico. Esto lo hacemos resolviendo varias instancias de un problema de mochila generalizado restringido, al que llamamos iKnapsack, donde un elemento debe estar en el rango medio para un intervalo particular. Específicamente, supongamos que el elemento x para el agente l está obligado a estar en su rango j-ésimo, [uj, uj+1), mientras que todos los demás elementos, x1, ..., xl−1, xl+1, xn, deben ser anclas o cero. Esto corresponde al problema restringido iKnapsack( , j), en el que el objetivo es obtener al menos M − uj unidades con el costo mínimo. El elemento x se asume que ya ha contribuido uj unidades. El valor de una solución para iKnapsack( , j) representa el costo adicional mínimo para comprar el resto de las unidades. Creamos n − 1 grupos de posibles anclas, donde el grupo i-ésimo contiene todas las anclas de la lista i en la mochila generalizada. El grupo para el agente l contiene un único elemento que representa el intervalo [0, uj+1 −uj), y el precio unitario asociado pj. Este intervalo representa el número excedente de unidades que se pueden tomar del agente l en iKnapsack( , j), además de uj, que ya ha sido comprometido. En cualquier otro grupo, podemos elegir como máximo un ancla. El siguiente pseudocódigo describe nuestro algoritmo para esta restricción del problema de la mochila generalizada. U es la unión de todas las tuplas en n grupos, incluyendo una tupla t para el agente l. El tamaño de esta tupla especial se define como uj+1 − uj, y el costo se define como pj l (uj+1 − uj). R es el número de unidades que quedan por adquirir. S es el conjunto de tuplas aceptadas en la actual solución tentativa 170. La mejor es la mejor solución encontrada hasta ahora. La variable Skip solo se utiliza en la demostración de corrección. Algoritmo Voraz( , j) 1. Ordena todas las tuplas de U en orden ascendente según el precio unitario; en caso de empate, ordénalas en orden ascendente según las cantidades unitarias. Establecer mark(i) = 0, para todas las listas i = 1, 2, . . . , n. Inicializar R = M − uj, S = Best = Skip = ∅. 3. Escanea las tuplas en U en orden ordenado. Supongamos que la siguiente tupla es tk i, es decir, el k-ésimo ancla del agente i. Si mark(i) = 1, ignora esta tupla; de lo contrario, sigue los siguientes pasos: • si size(tk i ) > R e i = return min {cost(S) + Rpj , cost(Best)}; • si size(tk i ) > R y cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • si size(tk i ) > R y cost(tk i ) > cost(S) Agregar tk i a Skip; Establecer Best como S ∪ {tk i } si el costo mejora; • si size(tk i ) ≤ R entonces agregar tk i a S; mark(i) = 1; restar size(tk i ) de R. El algoritmo de aproximación es muy similar al algoritmo de aproximación para la mochila. Dado que deseamos minimizar el costo total, consideramos las tuplas en orden de costo por unidad creciente. Si el tamaño de la tupla tk i es menor que R, entonces la agregamos a S, actualizamos R y eliminamos de U todas las tuplas que pertenecen al mismo grupo que tk i. Si el tamaño de tk i es mayor que R, entonces S junto con tk i forma una solución factible. Sin embargo, esta solución puede estar lejos de ser óptima si el tamaño de tk i es mucho mayor que R. Si el costo total de S y tk i es menor que la mejor solución actual, actualizamos Mejor. Una excepción a esta regla es la tupla t. Dado que esta tupla puede ser tomada fraccionalmente, actualizamos Mejor si la suma del costo de Ss y el costo fraccional de t es una mejora. El algoritmo termina en cualquiera de los dos primeros casos, o cuando se escanean todas las tuplas. En particular, termina cuando encontramos un tk i tal que el tamaño(tk i) es mayor que R pero el costo(tk i) es menor que el costo(S), o cuando alcanzamos la tupla que representa al agente l y proporciona una solución factible. LEMMA 2. \n\nLEMMA 2. Supongamos que A∗ es una solución óptima del problema de la mochila generalizado, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, el costo V (l, j), devuelto por Greedy( , j), satisface: V ( , j) + costo(tj ) ≤ 2costo(A∗ ) PRUEBA. Sea V( , j) el valor devuelto por Greedy( , j) y sea V ∗ ( , j) una solución óptima para iKnapsack( , j). Considera el conjunto Skip al finalizar Greedy( , j). Hay dos casos a considerar: o bien algún conjunto t ∈ Skip también está en V ∗ ( , j), o ningún conjunto en Skip está en V ∗ ( , j). En el primer caso, sea St la solución tentativa S en el momento en que se agregó a Skip. Dado que t ∈ Skip entonces size(t) > R, y St junto con t forman una solución factible, y tenemos: V( , j) ≤ coste(Mejor) ≤ coste(St) + coste(t). Nuevamente, dado que t ∈ Skip entonces cost(t) > cost(St), y tenemos V( , j) < 2cost(t). Por otro lado, dado que t está incluido en V ∗ ( , j), tenemos que V ∗ ( , j) ≥ cost(t). Estas dos desigualdades implican el límite deseado: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j). En el segundo caso, imagina una instancia modificada de iKnapsack( , j), que excluye todas las tuplas del conjunto Skip. Dado que ninguno de estos pares ordenados fue incluido en V ∗ ( , j), la solución óptima para el problema modificado debería ser la misma que la del original. Supongamos que nuestro algoritmo de aproximación devuelve el valor V( , j) para esta instancia modificada. Sea t la última tupla considerada por el algoritmo de aproximación antes de la terminación en la instancia modificada, y sea St el conjunto de soluciones tentativas correspondiente en ese paso. Dado que consideramos las tuplas en orden de precio por unidad creciente, y ninguna de las tuplas va a ser colocada en el conjunto Skip, debemos tener cost(St) < V ∗ ( , j) porque St es la forma óptima de obtener size(St). También tenemos cost(t) ≤ cost(St), y las siguientes desigualdades: V( , j) ≤ V( , j) ≤ cost(St) + cost(t) < 2V ∗( , j). La desigualdad V( , j) ≤ V( , j) se sigue del hecho de que una tupla en la lista de omisión solo puede afectar a la Mejor solución pero no a las soluciones tentativas. Por lo tanto, eliminar las tuplas en el conjunto Skip solo puede empeorar la solución. El argumento anterior ha demostrado que el valor devuelto por Greedy( , j) está dentro de un factor 2 de la solución óptima para iKnapsack( , j). Ahora demostramos que el valor V( , j) más el costo(tj) es una aproximación de 2 del problema original de la mochila generalizada. Sea A∗ una solución óptima del problema de la mochila generalizada, y supongamos que el elemento xj es de rango medio. Deje x− ser el conjunto de los elementos restantes, ya sea cero o anclas, en esta solución. Además, define x = xj − uj. Por lo tanto, el costo(A∗) = costo(xl) + costo(tj l) + costo(x−l). Es fácil ver que (x−, x) es una solución óptima para iKnapsack( , j). Dado que V( , j) es una aproximación de 2 para esta solución óptima, tenemos las siguientes desigualdades: V( , j) + costo(tj) ≤ costo(tj) + 2(costo(x) + costo(x−)) ≤ 2(costo(x) + costo(tj) + costo(x−)) ≤ 2costo(A∗). Esto completa la prueba del Lema 2. Es fácil ver que, después de una clasificación inicial de las tuplas en U, el algoritmo Greedy( , j) toma tiempo O(n). Tenemos nuestro primer algoritmo de aproximación polinomial. TEOREMA 2. Una aproximación de 2 del problema de la mochila generalizada se puede encontrar en tiempo O(n2), donde n es el número de listas de elementos (cada una de longitud constante). PRUEBA. Ejecutamos el algoritmo Greedy( , j) una vez por cada tupla (l, j) como candidato para el rango medio. Hay O(n) tuplas, y basta con ordenarlas una vez, el costo total del algoritmo es O(n^2). Por el Lema 1, hay una solución óptima con a lo sumo un elemento de rango medio, por lo que nuestro algoritmo encontrará una aproximación de 2, como se afirma. La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución es O((nc)2). 171 3.3 Un Esquema de Aproximación Ahora utilizamos el algoritmo de aproximación 2 presentado en la sección anterior para desarrollar un esquema de aproximación completamente polinómico (FPTAS) para el problema de la mochila generalizada. La idea de alto nivel es bastante estándar, pero los detalles requieren cuidado técnico. Utilizamos un algoritmo de programación dinámica para resolver iKnapsack( , j) para cada posible elemento de rango medio, con el algoritmo de aproximación 2 proporcionando un límite superior en el valor de la solución y permitiendo el uso de escalado en la dimensión de coste de la tabla de programación dinámica (DP). Consideremos, por ejemplo, el caso en que el elemento de rango medio es x, que cae en el rango [uj, uj+1). En nuestro FPTAS, en lugar de utilizar un algoritmo de aproximación voraz para resolver iKnapsack( , j), construimos una tabla de programación dinámica para calcular el costo mínimo al cual se pueden obtener al menos M − uj+1 unidades utilizando las n − 1 listas restantes en la mochila generalizada. Supongamos que G[i, r] denota el número máximo de unidades que se pueden obtener a un costo de como máximo r utilizando solo las primeras i listas en la mochila generalizada. Entonces, la siguiente relación de recurrencia describe cómo construir la tabla de programación dinámica: G[0, r] = 0 G[i, r] = máximo ´ G[i − 1, r] máximo j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ donde β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, es el conjunto de anclas para el agente i. Como convención, el agente i indexará la fila y el costo r indexará la columna. Este algoritmo de programación dinámica es solo seudo-polinómico, ya que el número de columnas en la tabla de programación dinámica depende del costo total. Sin embargo, podemos convertirlo en un FPTAS escalando la dimensión del costo. Que A denote la aproximación de 2 al problema de la mochila generalizada, con costo total, coste(A). Que ε denote el factor de aproximación deseado. Calculamos el costo escalado de una tupla tj i, denotado como scost(tj i), como scost(tj i) = n cost(tj i) εcost(A) (2). Este escalado mejora el tiempo de ejecución del algoritmo porque el número de columnas en la tabla modificada es a lo sumo n ε, e independiente del costo total. Sin embargo, la solución calculada podría no ser una solución óptima para el problema original. Mostramos que el error introducido está dentro de un factor de ε de la solución óptima. Como preludio a nuestra garantía de aproximación, primero demostramos que si dos soluciones diferentes al problema de la mochila escalada tienen un costo escalado igual, entonces sus costos originales (no escalados) no pueden diferir en más de εcost(A). LEMMA 3. \n\nLEMMA 3. Sean x e y dos soluciones factibles distintas de iKnapsack( , j), excluyendo sus elementos de rango medio. Si x e y tienen costos escalados iguales, entonces sus costos no escalados no pueden diferir en más de εcosto(A). PRUEBA. Que Ix e Iy, respectivamente, denoten las funciones indicadoras asociadas con los vectores ancla x e y, hay un 1 en la posición Ix[i, k] si el xk i > 0. Dado que x e y tienen un costo escalado igual, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) Sin embargo, por (2), los costos escalados satisfacen las siguientes desigualdades: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Sustituyendo el límite superior del costo escalado de (4) por el costo(x), el límite inferior del costo escalado de (4) por el costo(y), y usando la igualdad (3) para simplificar, obtenemos: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), La última desigualdad utiliza el hecho de que como máximo n componentes de un vector indicador son diferentes de cero; es decir, cualquier solución factible contiene como máximo n tuplas. Finalmente, dado la tabla de programación dinámica para iKnapsack( , j), consideramos todas las entradas en la última fila de esta tabla, G[n−1, r]. Estas entradas corresponden a soluciones óptimas con todos los agentes excepto l, para diferentes niveles de costo. En particular, consideramos las entradas que proporcionan al menos M − uj+1 unidades. Junto con una contribución del agente l, elegimos la entrada en este conjunto que minimiza el costo total, definido de la siguiente manera: costo(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj, donde costo() es el costo original y no escalado asociado con la entrada G[n−1, r]. Vale la pena señalar que, a diferencia del esquema de aproximación 2 para iKnapsack( , j), el valor calculado con este FPTAS incluye el costo de adquirir uj l unidades de l. El siguiente lema muestra que logramos una aproximación (1+ε). LEMMA 4. \n\nLEMMA 4. Supongamos que A∗ es una solución óptima del problema de la mochila generalizada, y supongamos que el elemento (l, j) está en la mitad de la solución óptima. Entonces, la solución A(l, j) obtenida al ejecutar el algoritmo de programación dinámica escalado en iKnapsack( , j) satisface que el costo de A(l, j) es menor o igual a (1 + 2ε) veces el costo de A∗. DEMOSTRACIÓN. Sea x− el vector de los elementos en la solución A∗ sin el elemento l. Entonces, por definición, el costo(A∗) = costo(x−) + pj xj. Sea r = scost(x− ) el costo escalado asociado con el vector x− . Ahora considera la tabla de programación dinámica construida para iKnapsack( , j), y considera su entrada G[n − 1, r]. Que A denote la aproximación de 2 al problema de la mochila generalizada, y A(l, j) denote la solución del algoritmo de programación dinámica. Supongamos que y− es la solución asociada con esta entrada en nuestro programa dinámico; los componentes del vector y− son las cantidades de diferentes listas. Dado que tanto x− como y− tienen costos escalados iguales, por el Lema 3, sus costos no escalados están dentro de εcost(A) uno del otro; es decir, cost(y−) − cost(x−) ≤ εcost(A). Ahora, define yj = max{uj , M − Σi=1 Σj yji}; esta es la contribución necesaria de yj para hacer que (y− , yj ) sea una solución factible. Entre todas las soluciones de igual costo, nuestras tablas de programación dinámica eligen la que tiene el máximo de unidades. Por lo tanto, i= j yj i ≥ i= j xj i 172 Por lo tanto, debe ser el caso que yj ≤ xj. Dado que (yj, y−) es también una solución factible, si nuestro algoritmo devuelve una solución con costo coste(A(l, j)), entonces debemos tener coste(A(l, j)) ≤ coste(y−) + pj yj ≤ coste(x−) + εcoste(A) + pj xj ≤ (1 + 2ε)coste(A∗), donde utilizamos el hecho de que coste(A) ≤ 2coste(A∗). Al juntar esto, nuestro esquema de aproximación para el problema de la mochila generalizada iterará el esquema descrito anteriormente para cada elección del elemento de rango medio (l, j), y elegirá la mejor solución de entre estas O(n) soluciones. Para un rango medio dado, el paso más costoso en el algoritmo es la construcción de la tabla de programación dinámica, la cual puede realizarse en tiempo O(n2 /ε) asumiendo intervalos constantes por lista. Por lo tanto, tenemos el siguiente resultado. TEOREMA 3. Podemos calcular una aproximación (1 + ε) a la solución de un problema de la mochila generalizada en tiempo de peor caso O(n3 /ε). La dependencia del número de piezas también es polinómica: si cada oferta tiene un máximo de c piezas, entonces el tiempo de ejecución se puede derivar sustituyendo cn por cada ocurrencia de n. CALCULANDO LOS PAGOS VCG Ahora consideramos el problema relacionado de calcular los pagos VCG para todos los agentes. Un enfoque ingenuo requiere resolver el problema de asignación n veces, eliminando a cada agente por turno. En esta sección, demostramos que nuestro esquema de aproximación para la mochila generalizada se puede extender para determinar los n pagos en un tiempo total de O(αT log(αn/ε)), donde 1 ≤ C(I\\i)/C(I) ≤ α, para un límite superior constante, α, y T es la complejidad de resolver el problema de asignación una vez. Este límite α puede justificarse como una condición de no monopolio, ya que limita el valor marginal que un único comprador aporta a la subasta. De manera similar, en la variación inversa podemos calcular los pagos VCG a cada vendedor en tiempo O(αT log(αn/ε)), donde α acota la razón C(I\\ i)/C(I) para todos los i. Nuestra estrategia general será construir dos tablas de programación dinámica, una hacia adelante y otra hacia atrás, para cada elemento de rango medio (l, j) una vez. La tabla hacia adelante se construye considerando a los agentes en el orden de sus índices, mientras que la tabla hacia atrás se construye considerándolos en orden inverso. La solución óptima correspondiente a C(I \\ i) se puede dividir en dos partes: una correspondiente a los primeros (i − 1) agentes y la otra correspondiente a los últimos (n − i) agentes. Dado que la fila (i − 1) de la tabla hacia adelante corresponde a los vendedores con los primeros (i−1) índices, una aproximación a la primera parte estará contenida en la fila (i − 1) de la tabla hacia adelante. De manera similar, la fila (n− i) de la tabla inversa contendrá una aproximación para la segunda parte. Primero presentamos una forma simple pero ineficiente de calcular el valor aproximado de C(I \\ i), que ilustra la idea principal de nuestro algoritmo. Luego presentamos un esquema mejorado, que utiliza el hecho de que los elementos en las filas están ordenados, para calcular el valor aproximado de manera más eficiente. En lo siguiente, nos concentramos en calcular una asignación con xj siendo el rango medio, y algún agente i = l eliminado. Esto será un componente en el cálculo de una aproximación a C(I \\ i), el valor de la solución al problema de la mochila generalizada sin ofertas del agente i. Comenzamos con el esquema simple. 4.1 Un Esquema de Aproximación Simple Implementamos el algoritmo de programación dinámica escalado para iKnapsack( , j) con dos órdenes alternativos sobre los otros vendedores, k = l, uno con los vendedores ordenados 1, 2, . . . , n, y otro con los vendedores ordenados n, n − 1, . . . , 1. Llamamos a la primera tabla la tabla hacia adelante, y la denotamos como F, y a la segunda tabla la tabla hacia atrás, y la denotamos como Bl. El subíndice nos recuerda que el agente está en el rango medio. Al construir estas tablas, utilizamos el mismo factor de escala que antes; es decir, el costo de una tupla tj i se escala de la siguiente manera: scost(tj i ) = ncost(tj i ) εcost(A) donde cost(A) es el límite superior en C(I), dado por nuestro esquema de aproximación de 2 aproximaciones. En este caso, dado que C(I \\ i) puede ser α veces C(I), el valor escalado de C(I \\ i) puede ser a lo sumo nα/ε. Por lo tanto, la dimensión de costos de nuestra tabla de programas dinámicos será nα/ε. Tabla F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Tabla Bl Figura 3: Cálculo de pagos VCG. m = nα ε Ahora, supongamos que queremos calcular una aproximación (1 + ) al problema de la mochila generalizada restringido al elemento (l, j) de rango medio, y además restringido para eliminar ofertas de algún vendedor i = l. Llamemos a este problema iKnapsack−i ( , j). Recuerda que la fila i-ésima de nuestra tabla de programación dinámica almacena la mejor solución posible utilizando solo los primeros i agentes, excluyendo al agente l, todos ellos ya sea despejados en cero o en anclas. Estos primeros agentes i son un subconjunto diferente de agentes en las tablas hacia adelante y hacia atrás. Al combinar cuidadosamente una fila de Fl con una fila de Bl, podemos calcular una aproximación a iKnapsack−i( , j). Consideramos la fila de Fl que corresponde a las soluciones construidas a partir de los agentes {1, 2, . . . , i − 1}, omitiendo al agente l. Consideramos la fila de Bl que corresponde a las soluciones construidas a partir de los agentes {i+1, i+2, . . . , n}, nuevamente omitiendo al agente l. Las filas están etiquetadas como Fl(i − 1) y Bl(n − i) respectivamente. Los costos escalados para adquirir estas unidades son los índices de columna para estas entradas. Para resolver iKnapsack−i( , j) elegimos una entrada de la fila F(i−1) y una de la fila B(n−i) de modo que su cantidad total supere a M − uj+1 y su costo combinado sea mínimo entre todas esas combinaciones. Formalmente, sea g ∈ Fl(i − 1) y h ∈ Bl(n − 1) denotando las entradas en cada fila, con size(g), size(h) denotando el número de unidades y cost(g) y cost(h) denotando el costo no escalado asociado con la entrada. Calculamos lo siguiente, sujeto 9 Podríamos etiquetar las tablas con ambos y j, para indicar que la j-ésima tupla está obligada a ser de rango medio, pero omitimos j para evitar desorden. Para ser precisos, el índice de las filas son (i − 2) y (n − i) para Fl y Bl cuando l < i, y (i − 1) y (n − i − 1), respectivamente, cuando l > i. 173 a la condición de que g y h satisfacen size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMA 5. Supongamos que A−i es una solución óptima del problema de la mochila generalizada sin ofertas del agente i, y supongamos que el elemento (l, j) es el elemento de rango medio en la solución óptima. Entonces, la expresión en la Ecuación 5, para el problema restringido iKnapsack−i ( , j), calcula una aproximación (1 + ε) a A−i. PRUEBA. Desde antes, definimos el costo(A−i) = C(I \\ i). Podemos dividir la solución óptima, A−i, en tres partes disjuntas: xl corresponde al vendedor de rango medio, xi corresponde a los primeros i − 1 vendedores (omitir al agente l si l < i), y x−i corresponde a los últimos n − i vendedores (omitir al agente l si l > i). Tenemos: coste(A−i) = coste(xi) + coste(x−i) + pj xj Sea ri = scoste(xi) y r−i = scoste(x−i). Dejen que yi e y−i sean los vectores solución correspondientes a los costos escalados ri y r−i en F(i − 1) y B(n − i), respectivamente. A partir del Lema 3 concluimos que, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) donde cost(A) es la cota superior de C(I) calculada con la aproximación de 2. Entre todas las soluciones de costos escalados iguales, nuestro programa dinámico elige la que tiene el máximo de unidades. Por lo tanto, también tenemos (tamaño(yi) ≥ tamaño(xi)) y (tamaño(y−i) ≥ tamaño(x−i)) donde usamos la abreviatura tamaño(x) para denotar el número total de unidades en todas las tuplas en x. Ahora, define yj l = max(uj l , M −tamaño(yi)−tamaño(y−i)). A partir de las desigualdades anteriores, tenemos yj l ≤ xj l. Dado que (yj l , yi, y−i) también es una solución factible para el problema de la mochila generalizado sin el agente i, el valor devuelto por la Ecuación 5 es a lo sumo cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε. Esto completa la prueba. Una implementación ingenua de este esquema será ineficiente porque podría verificar (nα/ε)2 pares de elementos, para cualquier elección particular de (l, j) y elección del agente eliminado i. En la siguiente sección, presentamos una forma eficiente de calcular la Ecuación 5, y eventualmente calcular los pagos VCG. 4.2 Esquema de Aproximación Mejorado Nuestro esquema de aproximación mejorado para el problema de determinación del ganador sin el agente i utiliza el hecho de que los elementos en F (i − 1) y B (n − i) están ordenados; específicamente, tanto el costo no escalado como la cantidad (es decir, el tamaño) aumentan de izquierda a derecha. Como antes, dejemos que g y h denoten entradas genéricas en F (i − 1) y B (n − i) respectivamente. Para calcular la Ecuación 5, consideramos todos los pares de tuplas y primero dividimos las tuplas que satisfacen la condición tamaño(g) + tamaño(h) > M − uj+1 l en dos conjuntos disjuntos. Para cada conjunto calculamos la mejor solución, y luego tomamos la mejor entre los dos conjuntos. [caso I: tamaño(g) + tamaño(h) ≥ M − uj l ] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l uj Ó (6) Definimos un par (g, h) como factible si tamaño(g) + tamaño(h) ≥ M − uj l. Ahora, para calcular la Ecuación 6, realizamos un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Empezamos desde el índice más pequeño de F (i − 1) y nos movemos hacia la derecha, y desde el índice más alto de B (n − i) y nos movemos hacia la izquierda. Que (g, h) sea el par actual. Si (g, h) es factible, decrementamos el puntero de Bs (es decir, retrocedemos); de lo contrario, incrementamos el puntero de Fs. Las parejas factibles encontradas durante la caminata se utilizan para calcular la Ecuación 6. La complejidad de este paso es lineal en el tamaño de F (i − 1), que es O(nα/ε). [caso II: M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l] El problema se reduce a min g∈F (i−1), h∈B (n−i) Òcosto(g) + costo(h) + pj l (M − tamaño(g) − tamaño(h)) Ó Para calcular la ecuación anterior, transformamos el problema anterior en otro problema utilizando un costo modificado, que se define como: mcosto(g) = costo(g) − pj l · tamaño(g) mcosto(h) = costo(h) − pj l · tamaño(h) El nuevo problema es calcular min g∈F (i−1), h∈B (n−i) Òmcosto(g) + mcosto(h) + pj l M Ó (7) El costo modificado simplifica el problema, pero desafortunadamente los elementos en F (i − 1) y B (n − i) ya no están ordenados con respecto a mcosto. Sin embargo, los elementos siguen ordenados por cantidad y utilizamos esta propiedad para calcular la Ec. 7. Llama a un par (g, h) factible si M − uj+1 l ≤ tamaño(g) + tamaño(h) ≤ M − uj l. Define el conjunto factible de g como los elementos h ∈ B (n − i) que son factibles dados g. Dado que los elementos están ordenados por cantidad, el conjunto factible de g es un subconjunto contiguo de B (n − i) y se desplaza hacia la izquierda a medida que g aumenta. 2 3 4 5 10 20 30 40 50 60 Comienzo Fin B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figura 4: El conjunto factible de g = 3, definido en B (n − i), es {2, 3, 4} cuando M − uj+1 l = 50 y M − uj l = 60. \"Begin y End representan los punteros de inicio y fin al conjunto factible.\" Por lo tanto, podemos calcular la Ec. 7 realizando un recorrido hacia adelante y hacia atrás en F (i − 1) y B (n − i) respectivamente. Caminamos en B (n − i), comenzando desde el índice más alto, utilizando dos punteros, Inicio y Fin, para indicar el inicio y el final del conjunto factible actual. Mantenemos el conjunto factible como un montículo mínimo, donde la clave es el costo modificado. Para actualizar el conjunto factible, al incrementar el puntero Fs (avanzar), caminamos hacia la izquierda en B, primero utilizando End para eliminar elementos del conjunto factible que ya no son factibles y luego utilizando Begin para agregar nuevos elementos factibles. Para un valor dado de g, el único elemento que necesitamos considerar en el conjunto factible de gs es aquel con el costo modificado mínimo, el cual puede ser calculado en tiempo constante con el montículo mínimo. Por lo tanto, la principal complejidad del cálculo radica en las actualizaciones del montículo. Dado que cualquier elemento se agrega o elimina a lo sumo una vez, hay O(nα ε ) actualizaciones de montículo y la complejidad temporal de este paso es O(nα ε log nα ε ). 4.3 Recopilando las piezas. El algoritmo funciona de la siguiente manera. Primero, utilizando el algoritmo de aproximación 2, calculamos una cota superior en C(I). Utilizamos este límite para reducir los costos de la tupla. Usando los costos escalados, construimos las tablas hacia adelante y hacia atrás correspondientes a cada tupla (l, j). Las tablas de avance se utilizan para calcular C(I). Para calcular C(I \\ i), iteramos sobre todas las posibles tuplas de rango medio y utilizamos las tablas correspondientes de avance y retroceso para calcular la solución localmente óptima utilizando el esquema anterior. Entre todas las soluciones localmente óptimas, elegimos una con el costo total mínimo. El paso más costoso en el algoritmo es el cálculo de C(I \\ i). La complejidad temporal de este paso es O(n2 α ε log nα ε ) ya que tenemos que iterar sobre todas las O(n) opciones de tj l , para todos los l = i, y cada vez usar el esquema anterior para calcular la Ec. 5. En el peor de los casos, podríamos necesitar calcular C(I \\ i) para todos los n vendedores, en cuyo caso la complejidad final del algoritmo será O(n3 α ε log nα ε). TEOREMA 4. Podemos calcular una aproximación a la estrategia-proof de /(1+ ) al mecanismo VCG en las subastas de unidades múltiples hacia adelante y hacia atrás en un tiempo de peor caso O(n3 α ε log nα ε ). Es interesante recordar que T = O(n3 ε ) es la complejidad temporal del FPTAS para el problema de la mochila generalizada con todos los agentes. Nuestro esquema combinado calcula una aproximación al mecanismo VCG completo, incluyendo pagos a O(n) agentes, en complejidad temporal O(T log(n/ε)), tomando el parámetro de no-monopolio, α, como una constante. Por lo tanto, nuestro algoritmo funciona mucho mejor que el esquema ingenuo, que calcula el pago VCG para cada agente resolviendo una nueva instancia del problema de la mochila generalizada. La aceleración proviene de la forma en que resolvemos iKnapsack−i( , j). La complejidad temporal de calcular iKnapsack−i ( , j) creando una nueva tabla de programación dinámica será O(n2 ε ), pero al usar las tablas hacia adelante y hacia atrás, la complejidad se reduce a O(n ε log n ε ). Podemos mejorar aún más la complejidad temporal de nuestro algoritmo al calcular la Ec. 5 de manera más eficiente. Actualmente, el algoritmo utiliza un montículo, que tiene un tiempo de actualización logarítmico. En el peor de los casos, podemos tener dos operaciones de actualización de montículos por cada elemento, lo que hace que la complejidad temporal sea superlineal. Si podemos calcular la Ec. 5 en tiempo lineal, entonces la complejidad de calcular el pago VCG será la misma que la complejidad de resolver un único problema de la mochila generalizada. 5. CONCLUSIONES Presentamos un esquema de aproximación de tiempo polinómico completo para el problema de <br>subasta multiunidad</br> de un solo bien, utilizando un lenguaje de oferta constante por tramos decreciente marginalmente. Nuestro esquema es aproximadamente eficiente y aproximadamente a prueba de estrategias dentro de cualquier factor especificado ε > 0. Como tal, es un ejemplo de un resultado de dominancia ε computacionalmente tratable, así como un ejemplo de un problema de asignación no trivial pero aproximable. Es particularmente interesante que podamos calcular los pagos a n agentes en un mecanismo basado en VCG en un tiempo de peor caso O(T log n), donde T es la complejidad temporal para calcular la solución a un problema de asignación individual. REFERENCIAS [1] L M Ausubel y P R Milgrom. Subastas ascendentes con ofertas de paquetes. Fronteras de la Economía Teórica, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer y R V Vohra. Programación lineal y subastas de Vickrey. Informe técnico, Escuela de Posgrado Anderson de Administración, U.C.L.A., 2001. [3] S Bikchandani y J M Ostroy. El modelo de asignación de paquetes. Revista de Teoría Económica, 2002. Próximamente. [4] K Chatterjee y W Samuelson. Negociación bajo información incompleta. Investigación de Operaciones, 31:835-851, 1983. [5] E H Clarke. Precios escalonados de bienes públicos. Elección Pública, 11:17-33, 1971. [6] S de Vries y R V Vohra. Subastas combinatorias: Un estudio. Revista Informs sobre Computación, 2002. Próximo. [7] M Eso, S Ghosh, J R Kalagnanam y L Ladanyi. Evaluación de ofertas en subastas de adquisiciones con curvas de oferta lineales por tramos. Informe técnico, Centro de Investigación IBM TJ Watson, 2001. En preparación. [8] J Feigenbaum y S Shenker. Diseño de Mecanismos Algorítmicos Distribuidos: Resultados Recientes y Futuras Direcciones. En Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para Computación y Comunicaciones Móviles, páginas 1-13, 2002. [9] M R Garey y D S Johnson. Computadoras e Intractabilidad: Una Guía de la Teoría de NP-Completitud. W.H. Freeman and Company, Nueva York, 1979. [10] G V Gens y E V Levner. Complejidad computacional de algoritmos de aproximación para problemas combinatorios. En Fundamentos Matemáticos de la Ciencia de la Computación, 292-300, 1979. [11] T Groves. Incentivos en equipos. Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport y H S Lee. Aspectos computacionales de la compensación de subastas dobles continuas con restricciones de asignación y demanda indivisible. Revista de Comercio Electrónico, 1(3):221-238, 2001. [13] V Krishna. Teoría de subastas. Academic Press, 2002. [14] V Krishna y M Perry. Diseño de mecanismos eficientes. Informe técnico, Universidad Estatal de Pensilvania, 1998. Disponible en: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan y Y Shoham. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. JACM, 49(5):577-602, septiembre de 2002. [16] R B Myerson. Diseño óptimo de subasta. Matemáticas de la Investigación de Operaciones, 6:58-73, 1981. [17] R B Myerson y M A Satterthwaite. Mecanismos eficientes para el comercio bilateral. Revista de Teoría Económica, 28:265-281, 1983. [18] N Nisan y A Ronen. Mecanismos VCG computacionalmente factibles. En ACM-EC, páginas 242-252, 2000. [19] D C Parkes, J R Kalagnanam y M Eso. Lograr el equilibrio presupuestario con esquemas de pago basados en Vickrey en intercambios. En IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc y R M Harstad. Subastas combinatorias manejables computacionalmente. Ciencia de la Gestión, 44(8):1131-1147, 1998. [21] J Schummer. Casi implementación de estrategia dominante. Informe técnico, Departamento de MEDS, Escuela de Posgrado de Administración Kellogg, 2001. [22] W Vickrey. Contrarreforma, subastas y ofertas selladas competitivas. Revista de Finanzas, 16:8-37, 1961. 175 ",
            "candidates": [],
            "error": [
                [
                    "subasta multiunidad",
                    "subasta de múltiples unidades",
                    "subasta multiunidad"
                ]
            ]
        },
        "strategyproof": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Approximately-<br>strategyproof</br> and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "The bidding language in our auctions allows marginal-decreasing piecewise constant curves.",
                "First, we develop a fully polynomial-time approximation scheme for the multi-unit allocation problem, which computes a (1 + )approximation in worst-case time T = O(n3 / ), given n bids each with a constant number of pieces.",
                "Second, we embed this approximation scheme within a Vickrey-Clarke-Groves (VCG) mechanism and compute payments to n agents for an asymptotic cost of O(T log n).",
                "The maximal possible gain from manipulation to a bidder in the combined scheme is bounded by /(1+ )V , where V is the total surplus in the efficient outcome.",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-Economics.",
                "General Terms Algorithms, Economics. 1.",
                "INTRODUCTION In this paper we present a fully polynomial-time approximation scheme for the single-good multi-unit auction problem.",
                "Our scheme is both approximately efficient and approximately <br>strategyproof</br>.",
                "The auction settings considered in our paper are motivated by recent trends in electronic commerce; for instance, corporations are increasingly using auctions for their strategic sourcing.",
                "We consider both a reverse auction variation and a forward auction variation, and propose a compact and expressive bidding language that allows marginal-decreasing piecewise constant curves.",
                "In the reverse auction, we consider a single buyer with a demand for M units of a good and n suppliers, each with a marginal-decreasing piecewise-constant cost function.",
                "In addition, each supplier can also express an upper bound, or capacity constraint on the number of units she can supply.",
                "The reverse variation models, for example, a procurement auction to obtain raw materials or other services (e.g. circuit boards, power suppliers, toner cartridges), with flexible-sized lots.",
                "In the forward auction, we consider a single seller with M units of a good and n buyers, each with a marginal-decreasing piecewise-constant valuation function.",
                "A buyer can also express a lower bound, or minimum lot size, on the number of units she demands.",
                "The forward variation models, for example, an auction to sell excess inventory in flexible-sized lots.",
                "We consider the computational complexity of implementing the Vickrey-Clarke-Groves [22, 5, 11] mechanism for the multiunit auction problem.",
                "The Vickrey-Clarke-Groves (VCG) mechanism has a number of interesting economic properties in this setting, including strategyproofness, such that truthful bidding is a dominant strategy for buyers in the forward auction and sellers in the reverse auction, and allocative efficiency, such that the outcome maximizes the total surplus in the system.",
                "However, as we discuss in Section 2, the application of the VCG-based approach is limited in the reverse direction to instances in which the total payments to the sellers are less than the value of the outcome to the buyer.",
                "Otherwise, either the auction must run at a loss in these instances, or the buyer cannot be expected to voluntarily choose to participate.",
                "This is an example of the budget-deficit problem that often occurs in efficient mechanism design [17].",
                "The computational problem is interesting, because even with marginal-decreasing bid curves, the underlying allocation problem turns out to (weakly) intractable.",
                "For instance, the classic 0/1 knapsack is a special case of this problem.1 We model the 1 However, the problem can be solved easily by a greedy scheme if we remove all capacity constraints from the seller and all 166 allocation problem as a novel and interesting generalization of the classic knapsack problem, and develop a fully polynomialtime approximation scheme, computing a (1 + )-approximation in worst-case time T = O(n3 /ε), where each bid has a fixed number of piecewise constant pieces.",
                "Given this scheme, a straightforward computation of the VCG payments to all n agents requires time O(nT).",
                "We compute approximate VCG payments in worst-case time O(αT log(αn/ε)), where α is a constant that quantifies a reasonable no-monopoly assumption.",
                "Specifically, in the reverse auction, suppose that C(I) is the minimal cost for procuring M units with all sellers I, and C(I \\ i) is the minimal cost without seller i.",
                "Then, the constant α is defined as an upper bound for the ratio C(I \\i)/C(I), over all sellers i.",
                "This upper-bound tends to 1 as the number of sellers increases.",
                "The approximate VCG mechanism is ( ε 1+ε )-<br>strategyproof</br> for an approximation to within (1 + ) of the optimal allocation.",
                "This means that a bidder can gain at most ( ε 1+ε )V from a nontruthful bid, where V is the total surplus from the efficient allocation.",
                "As such, this is an example of a computationally-tractable ε-dominance result.2 In practice, we can have good confidence that bidders without good information about the bidding strategies of other participants will have little to gain from attempts at manipulation.",
                "Section 2 formally defines the forward and reverse auctions, and defines the VCG mechanisms.",
                "We also prove our claims about ε-strategyproofness.",
                "Section 3 provides the generalized knapsack formulation for the multi-unit allocation problems and introduces the fully polynomial time approximation scheme.",
                "Section 4 defines the approximation scheme for the payments in the VCG mechanism.",
                "Section 5 concludes. 1.1 Related Work There has been considerable interest in recent years in characterizing polynomial-time or approximable special cases of the general combinatorial allocation problem, in which there are multiple different items.",
                "The combinatorial allocation problem (CAP) is both NP-complete and inapproximable (e.g. [6]).",
                "Although some polynomial-time cases have been identified for the CAP [6, 20], introducing an expressive exclusive-or bidding language quickly breaks these special cases.",
                "We identify a non-trivial but approximable allocation problem with an expressive exclusiveor bidding language-the bid taker in our setting is allowed to accept at most one point on the bid curve.",
                "The idea of using approximations within mechanisms, while retaining either full-strategyproofness or ε-dominance has received some previous attention.",
                "For instance, Lehmann et al. [15] propose a greedy and <br>strategyproof</br> approximation to a single-minded combinatorial auction problem.",
                "Nisan & Ronen [18] discussed approximate VCG-based mechanisms, but either appealed to particular maximal-in-range approximations to retain full strategyproofness, or to resource-bounded agents with information or computational limitations on the ability to compute strategies.",
                "Feigenminimum-lot size constraints from the buyers. 2 However, this may not be an example of what Feigenbaum & Shenker refer to as a tolerably-manipulable mechanism [8] because we have not tried to bound the effect of such a manipulation on the efficiency of the outcome.",
                "VCG mechanism do have a natural self-correcting property, though, because a useful manipulation to an agent is a reported value that improves the total value of the allocation based on the reports of other agents and the agents own value. baum & Shenker [8] have defined the concept of strategically faithful approximations, and proposed the study of approximations as an important direction for algorithmic mechanism design.",
                "Schummer [21] and Parkes et al [19] have previously considered ε-dominance, in the context of economic impossibility results, for example in combinatorial exchanges.",
                "Eso et al. [7] have studied a similar procurement problem, but for a different volume discount model.",
                "This earlier work formulates the problem as a general mixed integer linear program, and gives some empirical results on simulated data.",
                "Kalagnanam et al. [12] address double auctions, where multiple buyers and sellers trade a divisible good.",
                "The focus of this paper is also different: it investigates the equilibrium prices using the demand and supply curves, whereas our focus is on efficient mechanism design.",
                "Ausubel [1] has proposed an ascending-price multi-unit auction for buyers with marginal-decreasing values [1], with an interpretation as a primal-dual algorithm [2]. 2.",
                "APPROXIMATELY-<br>strategyproof</br> VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions.",
                "Continuing, we introduce the VCG mechanism for the problem and the ε-dominance results for approximations to VCG outcomes.",
                "We also discuss the economic properties of VCG mechanisms in these forward and reverse auction multi-unit settings. 2.1 Marginal-Decreasing Piecewise Bids We provide a piecewise-constant and marginal-decreasing bidding language.",
                "This bidding language is expressive for a natural class of valuation and cost functions: fixed unit prices over intervals of quantities.",
                "See Figure 1 for an example.",
                "In addition, we slightly relax the marginal-decreasing requirement to allow: a bidder in the forward auction to state a minimal purchase amount, such that she has zero value for quantities smaller than that amount; a seller in the reverse auction to state a capacity constraint, such that she has an effectively infinite cost to supply quantities in excess of a particular amount.",
                "Reverse Auction Bid 7 5 10 20 25 10 8 Quantity Price 7 5 10 20 25 10 8 Quantity Price Forward Auction Bid Figure 1: Marginal-decreasing, piecewise constant bids.",
                "In the forward auction bid, the bidder offers $10 per unit for quantity in the range [5, 10), $8 per unit in the range [10, 20), and $7 in the range [20, 25].",
                "Her valuation is zero for quantities outside the range [10, 25].",
                "In the reverse auction bid, the cost of the seller is ∞ outside the range [10, 25].",
                "In detail, in a forward auction, a bid from buyer i can be written as a list of (quantity-range, unit-price) tuples, ((u1 i , p1 i ), (u2 i , p2 i ), . . . , (umi−1 i , pmi−1 i )), with an upper bound umi i on the quantity.",
                "The interpretation is that the bidders valuation in the 167 (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the valuation is 0 for quantities less than u1 i as well as for quantities more than um i .",
                "This is implemented by adding two dummy bid tuples, with zero prices in the range [0, u1 i ) and (umi i , ∞).",
                "We interpret the bid list as defining a price function, pbid,i(q) = qpj i , if uj i ≤ q < uj+1 i , where j = 1, 2, . . . , mi −1.",
                "In order to resolve the boundary condition, we assume that the bid price for the upper bound quantity umi i is pbid,i(umi i ) = umi i pmi−1 i .",
                "A sellers bid is similarly defined in the reverse auction.",
                "The interpretation is that the bidders cost in the (semi-open) quantity range [uj i , uj+1 i ) is pj i for each unit.",
                "Additionally, it is assumed that the cost is ∞ for quantities less than u1 i as well as for quantities more than um i .",
                "Equivalently, the unit prices in the ranges [0, u1 i ) and (um i , ∞) are infinity.",
                "We interpret the bid list as defining a price function, pask,i(q) = qpj i , if uj i ≤ q < uj+1 i . 2.2 VCG-Based Multi-Unit Auctions We construct the tractable and approximately-<br>strategyproof</br> multiunit auctions around a VCG mechanism.",
                "We assume that all agents have quasilinear utility functions; that is, ui(q, p) = vi(q)− p, for a buyer i with valuation vi(q) for q units at price p, and ui(q, p) = p − ci(q) for a seller i with cost ci(q) at price p. This is a standard assumption in the auction literature, equivalent to assuming risk-neutral agents [13].",
                "We will use the term payoff interchangeably for utility.",
                "In the forward auction, there is a seller with M units to sell.",
                "We assume that this seller has no intrinsic value for the items.",
                "Given a set of bids from I agents, let V (I) denote the maximal revenue to the seller, given that at most one point on the bid curve can be selected from each agent and no more than M units of the item can be sold.",
                "Let x∗ = (x∗ 1, . . . , x∗ N ) denote the solution to this winner- determination problem, where x∗ i is the number of units sold to agent i.",
                "Similarly, let V (I \\ i) denote the maximal revenue to the seller without bids from agent i.",
                "The VCG mechanism is defined as follows: 1.",
                "Receive piecewise-constant bid curves and capacity constraints from all the buyers. 2.",
                "Implement the outcome x∗ that solves the winner-determination problem with all buyers. 3.",
                "Collect payment pvcg,i = pbid,i(x∗ i ) − [V (I) − V (I \\ i)] from each buyer, and pass the payments to the seller.",
                "In this forward auction, the VCG mechanism is <br>strategyproof</br> for buyers, which means that truthful bidding is a dominant strategy, i.e. utility maximizing whatever the bids of other buyers.",
                "In addition, the VCG mechanism is allocatively-efficient, and the payments from each buyer are always positive.3 Moreover, each buyer pays less than its value, and receives payoff V (I)−V (I \\ i) in equilibrium; this is precisely the marginal-value that buyer i contributes to the economic efficiency of the system.",
                "In the reverse auction, there is a buyer with M units to buy, and n suppliers.",
                "We assume that the buyer has value V > 0 to purchase all M units, but zero value otherwise.",
                "To simplify the mechanism design problem we assume that the buyer will truthfully announce this value to the mechanism.4 The winner3 In fact, the VCG mechanism maximizes the expected payoff to the seller across all efficient mechanisms, even allowing for Bayesian-Nash implementations [14]. 4 Without this assumption, the Myerson-Satterthwaite [17] impossibility result would already imply that we should not expect an efficient trading mechanism in this setting. determination problem in the reverse auction is to determine the allocation, x∗ , that minimizes the cost to the buyer, or forfeits trade if the minimal cost is greater than value, V .",
                "Let C(I) denote the minimal cost given bids from all sellers, and let C(I \\i) denote the minimal cost without bids from seller i.",
                "We can assume, without loss of generality, that there is an efficient trade and V ≥ C(I).",
                "Otherwise, then the efficient outcome is no trade, and the outcome of the VCG mechanism is no trade and no payments.",
                "The VCG mechanism implements the outcome x∗ that minimizes cost based on bids from all sellers, and then provides payment pvcg,i = pask,i(x∗ i )+[V −C(I)−max(0, V −C(I\\i))] to each seller.",
                "The total payment is collected from the buyer.",
                "Again, in equilibrium each sellers payoff is exactly the marginal-value that the seller contributes to the economic efficiency of the system; in the simple case that V ≥ C(I \\ i) for all sellers i, this is precisely C(I \\ i) − C(I).",
                "Although the VCG mechanism remains <br>strategyproof</br> for sellers in the reverse direction, its applicability is limited to cases in which the total payments to the sellers are less than the buyers value.",
                "Otherwise, there will be instances in which the buyer will not choose to voluntarily participate in the mechanism, based on its own value and its beliefs about the costs of sellers.",
                "This leads to a loss in efficiency when the buyer chooses not to participate, because efficient trades are missed.",
                "This problem with the size of the payments, does not occur in simple single-item reverse auctions, or even in multi-unit reverse auctions with a buyer that has a constant marginal-valuation for each additional item that she procures.5 Intuitively, the problem occurs in the reverse multi-unit setting because the buyer demands a fixed number of items, and has zero value without them.",
                "This leads to the possibility of the trade being contingent on the presence of particular, so-called pivotal sellers.",
                "Define a seller i as pivotal, if C(I) ≤ V but C(I\\i) > V .",
                "In words, there would be no efficient trade without the seller.",
                "Any time there is a pivotal seller, the VCG payments to that seller allow her to extract all of the surplus, and the payments are too large to sustain with the buyers value unless this is the only winning seller.",
                "Concretely, we have this participation problem in the reverse auction when the total payoff to the sellers, in equilibrium, exceeds the total payoff from the efficient allocation: V − C(I) ≥ i [V − C(I) − max(0, V − C(I \\ i))] As stated above, first notice that we require V > C(I \\ i) for all sellers i.",
                "In other words, there must be no pivotal sellers.",
                "Given this, it is then necessary and sufficient that: V − C(I) ≥ i (C(I \\ i) − C(I)) (1) 5 To make the reverse auction symmetric with the forward direction, we would need a buyer with a constant marginal-value to buy the first M units, and zero value for additional units.",
                "The payments to the sellers would never exceed the buyers value in this case.",
                "Conversely, to make the forward auction symmetric with the reverse auction, we would need a seller with a constant (and high) marginal-cost to sell anything less than the first M units, and then a low (or zero) marginal cost.",
                "The total payments received by the seller can be less than the sellers cost for the outcome in this case. 168 In words, the surplus of the efficient allocation must be greater than the total marginal-surplus provided by each seller.6 Consider an example with 3 agents {1, 2, 3}, and V = 150 and C(123) = 50.",
                "Condition (1) holds when C(12) = C(23) = 70 and C(13) = 100, but not when C(12) = C(23) = 80 and C(13) = 100.",
                "In the first case, the agent payoffs π = (π0, π1, π2, π3), where 0 is the seller, is (10, 20, 50, 20).",
                "In the second case, the payoffs are π = (−10, 30, 50, 30).",
                "One thing we do know, because the VCG mechanism will maximize the payoff to the buyer across all efficient mechanisms [14], is that whenever Eq. 1 is not satisfied there can be no efficient auction mechanism.7 2.3 ε-Strategyproofness We now consider the same VCG mechanism, but with an approximation scheme for the underlying allocation problem.",
                "We derive an ε-strategyproofness result, that bounds the maximal gain in payoff that an agent can expect to achieve through a unilateral deviation from following a simple truth-revealing strategy.",
                "We describe the result for the forward auction direction, but it is quite a general observation.",
                "As before, let V (I) denote the value of the optimal solution to the allocation problem with truthful bids from all agents, and V (I \\i) denote the value of the optimal solution computed without bids from agent i.",
                "Let ˆV (I) and ˆV (I \\ i) denote the value of the allocation computed with an approximation scheme, and assume that the approximation satisfies: (1 + ) ˆV (I) ≥ V (I) for some > 0.",
                "We provide such an approximation scheme for our setting later in the paper.",
                "Let ˆx denote the allocation implemented by the approximation scheme.",
                "The payoff to agent i, for announcing valuation ˆvi, is: vi(ˆxi) + j=i ˆvj (ˆxj) − ˆV (I \\ i) The final term is independent of the agents announced value, and can be ignored in an incentive-analysis.",
                "However, agent i can try to improve its payoff through the effect of its announced value on the allocation ˆx implemented by the mechanism.",
                "In particular, agent i wants the mechanism to select ˆx to maximize the sum of its true value, vi(ˆxi), and the reported value of the other agents, Èj=i ˆvj (ˆxj).",
                "If the mechanisms allocation algorithm is optimal, then all the agent needs to do is truthfully state its value and the mechanism will do the rest.",
                "However, faced with an approximate allocation algorithm, the agent can try to improve its payoff by announcing a value that corrects for the approximation, and causes the approximation algorithm to implement the allocation that exactly maximizes the total reported value of the other agents together with its own actual value [18]. 6 This condition is implied by the agents are substitutes requirement [3], that has received some attention in the combinatorial auction literature because it characterizes the case in which VCG payments can be supported in a competitive equilibrium.",
                "Useful characterizations of conditions that satisfy agents are substitutes, in terms of the underlying valuations of agents have proved quite elusive. 7 Moreover, although there is a small literature on maximallyefficient mechanisms subject to requirements of voluntaryparticipation and budget-balance (i.e. with the mechanism neither introducing or removing money), analytic results are only known for simple problems (e.g. [16, 4]).",
                "We can now analyze the best possible gain from manipulation to an agent in our setting.",
                "We first assume that the other agents are truthful, and then relax this.",
                "In both cases, the maximal benefit to agent i occurs when the initial approximation is worst-case.",
                "With truthful reports from other agents, this occurs when the value of choice ˆx is V (I)/(1 + ε).",
                "Then, an agent could hope to receive an improved payoff of: V (I) − V (I) 1 + ε = ε 1 + ε V (I) This is possible if the agent is able to select a reported type to correct the approximation algorithm, and make the algorithm implement the allocation with value V (I).",
                "Thus, if other agents are truthful, and with a (1 + ε)-approximation scheme to the allocation problem, then no agent can improve its payoff by more than a factor ε/(1 + ε) of the value of the optimal solution.",
                "The analysis is very similar when the other agents are not truthful.",
                "In this case, an individual agent can improve its payoff by no more than a factor /(1 + ) of the value of the optimal solution given the values reported by the other agents.",
                "Let V in the following theorem define the total value of the efficient allocation, given the reported values of agents j = i, and the true value of agent i. THEOREM 1.",
                "A VCG-based mechanism with a (1 + ε)allocation algorithm is (1+ −V ) <br>strategyproof</br> for agent i, and agent i can gain at most this payoff through some non-truthful strategy.",
                "Notice that we did not need to bound the error on the allocation problems without each agent, because the -strategyproofness result follows from the accuracy of the first-term in the VCG payment and is independent of the accuracy of the second-term.",
                "However, the accuracy of the solution to the problem without each agent is important to implement a good approximation to the revenue properties of the VCG mechanism. 3.",
                "THEGENERALIZED KNAPSACK PROBLEM In this section, we design a fully polynomial approximation scheme for the generalized knapsack, which models the winnerdetermination problem for the VCG-based multi-unit auctions.",
                "We describe our results for the reverse auction variation, but the formulation is completely symmetric for the forward-auction.",
                "In describing our approximation scheme, we begin with a simple property (the Anchor property) of an optimal knapsack solution.",
                "We use this property to develop an O(n2 ) time 2-approximation for the generalized knapsack.",
                "In turn, we use this basic approximation to develop our fully polynomial-time approximation scheme (FPTAS).",
                "One of the major appeals of our piecewise bidding language is its compact representation of the bidders valuation functions.",
                "We strive to preserve this, and present an approximation scheme that will depend only on the number of bidders, and not the maximum quantity, M, which can be very large in realistic procurement settings.",
                "The FPTAS implements an (1 + ε) approximation to the optimal solution x∗ , in worst-case time T = O(n3 /ε), where n is the number of bidders, and where we assume that the piecewise bid for each bidder has O(1) pieces.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum 169 of c pieces, then the running time can be derived by substituting nc for each occurrence of n. 3.1 Preliminaries Before we begin, let us recall the classic 0/1 knapsack problem: we are given a set of n items, where the item i has value vi and size si, and a knapsack of capacity M; all sizes are integers.",
                "The goal is to determine a subset of items of maximum value with total size at most M. Since we want to focus on a reverse auction, the equivalent knapsack problem will be to choose a set of items with minimum value (i.e. cost) whose size exceeds M. The generalized knapsack problem of interest to us can be defined as follows: Generalized Knapsack: Instance: A target M, and a set of n lists, where the ith list has the form Bi = (u1 i , p1 i ), . . . , (umi−1 i , pmi−1 i ), (umi i (i), ∞) , where uj i are increasing with j and pj i are decreasing with j, and uj i , pj i , M are positive integers.",
                "Problem: Determine a set of integers xj i such that 1. (One per list) At most one xj i is non-zero for any i, 2. (Membership) xj i = 0 implies xj i ∈ [uj i , uj+1 i ), 3. (Target) Èi Èj xj i ≥ M, and 4. (Objective) Èi Èj pj i xj i is minimized.",
                "This generalized knapsack formulation is a clear generalization of the classic 0/1 knapsack.",
                "In the latter, each list consists of a single point (si, vi).8 The connection between the generalized knapsack and our auction problem is transparent.",
                "Each list encodes a bid, representing multiple mutually exclusive quantity intervals, and one can choose any quantity in an interval, but at most one interval can be selected.",
                "Choosing interval [uj i , uj+1 i ) has cost pj i per unit.",
                "The goal is to procure at least M units of the good at minimum possible cost.",
                "The problem has some flavor of the continuous knapsack problem.",
                "However, there are two major differences that make our problem significantly more difficult: (1) intervals have boundaries, and so to choose interval [uj i , uj+1 i ) requires that at least uj i and at most uj+1 i units must be taken; (2) unlike the classic knapsack, we cannot sort the items (bids) by value/size, since different intervals in one list have different unit costs. 3.2 A 2-Approximation Scheme We begin with a definition.",
                "Given an instance of the generalized knapsack, we call each tuple tj i = (uj i , pj i ) an anchor.",
                "Recall that these tuples represent the breakpoints in the piecewise constant curve bids.",
                "We say that the size of an anchor tj i is uj i , 8 In fact, because of the one per list constraint, the generalized problem is closer in spirit to the multiple choice knapsack problem [9], where the underling set of items is partitioned into disjoint subsets U1, U2, . . . , Uk, and one can choose at most one item from each subset.",
                "PTAS do exist for this problem [10], and indeed, one can convert our problem into a huge instance of the multiple choice knapsack problem, by creating one group for each list; put a (quantity, price) point tuple (x, p) for each possible quantity for a bidder into his group (subset).",
                "However, this conversion explodes the problem size, making it infeasible for all but the most trivial instances. the minimum number of units available at this anchors price pj i .",
                "The cost of the anchor tj i is defined to be the minimum total price associated with this tuple, namely, cost(tj i ) = pj i uj i if j < mi, and cost(tmi i ) = pmi−1 i umi i .",
                "In a feasible solution {x1, x2, . . . , xn} of the generalized knapsack, we say that an element xi = 0 is an anchor if xi = uj i , for some anchor uj i .",
                "Otherwise, we say that xi is midrange.",
                "We observe that an optimal knapsack solution can always be constructed so that at most one solution element is midrange.",
                "If there are two midrange elements x and x , for bids from two different agents, with x ≤ x , then we can increment x and decrement x, until one of them becomes an anchor.",
                "See Figure 2 for an example.",
                "LEMMA 1. [Anchor Property] There exists an optimal solution of the generalized knapsack problem with at most one midrange element.",
                "All other elements are anchors. 1 midrange bid 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity 5 20 15 10 25 5 25 30201510 35 3 2 1 Price Quantity (i) Optimal solution with 2 midrange bids (ii) Optimal soltution with Figure 2: (i) An optimal solution with more than one bid not anchored (2,3); (ii) an optimal solution with only one bid (3) not anchored.",
                "We use the anchor property to first obtain a polynomial-time 2-approximation scheme.",
                "We do this by solving several instances of a restricted generalized-knapsack problem, which we call iKnapsack, where one element is forced to be midrange for a particular interval.",
                "Specifically, suppose element x for agent l is forced to lie in its jth range, [uj , uj+1 ), while all other elements, x1, . . . , xl−1, xl+1, xn, are required to be anchors, or zero.",
                "This corresponds to the restricted problem iKnapsack( , j), in which the goal is to obtain at least M − uj units with minimum cost.",
                "Element x is assumed to have already contributed uj units.",
                "The value of a solution to iKnapsack( , j) represents the minimal additional cost to purchase the rest of the units.",
                "We create n − 1 groups of potential anchors, where ith group contains all the anchors of the list i in the generalized knapsack.",
                "The group for agent l contains a single element that represents the interval [0, uj+1 −uj ), and the associated unit-price pj .",
                "This interval represents the excess number of units that can be taken from agent l in iKnapsack( , j), in addition to uj , which has already been committed.",
                "In any other group, we can choose at most one anchor.",
                "The following pseudo-code describes our algorithm for this restriction of the generalized knapsack problem.",
                "U is the union of all the tuples in n groups, including a tuple t for agent l. The size of this special tuple is defined as uj+1 − uj , and the cost is defined as pj l (uj+1 −uj ).",
                "R is the number of units that remain to be acquired.",
                "S is the set of tuples accepted in the current tentative 170 solution.",
                "Best is the best solution found so far.",
                "Variable Skip is only used in the proof of correctness.",
                "Algorithm Greedy( , j) 1.",
                "Sort all tuples of U in the ascending order of unit price; in case of ties, sort in ascending order of unit quantities. 2.",
                "Set mark(i) = 0, for all lists i = 1, 2, . . . , n. Initialize R = M − uj , S = Best = Skip = ∅. 3.",
                "Scan the tuples in U in the sorted order.",
                "Suppose the next tuple is tk i , i.e. the kth anchor from agent i.",
                "If mark(i) = 1, ignore this tuple; otherwise do the following steps: • if size(tk i ) > R and i = return min {cost(S) + Rpj , cost(Best)}; • if size(tk i ) > R and cost(tk i ) ≤ cost(S) return min {cost(S) + cost(tk i ), cost(Best)}; • if size(tk i ) > R and cost(tk i ) > cost(S) Add tk i to Skip; Set Best to S ∪ {tk i } if cost improves; • if size(tk i ) ≤ R then add tk i to S; mark(i) = 1; subtract size(tk i ) from R. The approximation algorithm is very similar to the approximation algorithm for knapsack.",
                "Since we wish to minimize the total cost, we consider the tuples in order of increasing per unit cost.",
                "If the size of tuple tk i is smaller than R, then we add it to S, update R, and delete from U all the tuples that belong to the same group as tk i .",
                "If size(tk i ) is greater than R, then S along with tk i forms a feasible solution.",
                "However, this solution can be far from optimal if the size of tk i is much larger than R. If total cost of S and tk i is smaller than the current best solution, we update Best.",
                "One exception to this rule is the tuple t .",
                "Since this tuple can be taken fractionally, we update Best if the sum of Ss cost and fractional cost of t is an improvement.",
                "The algorithm terminates in either of the first two cases, or when all tuples are scanned.",
                "In particular, it terminates whenever we find a tk i such that size(tk i ) is greater than R but cost(tk i ) is less than cost(S), or when we reach the tuple representing agent l and it gives a feasible solution.",
                "LEMMA 2.",
                "Suppose A∗ is an optimal solution of the generalized knapsack, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the cost V (l, j), returned by Greedy( , j), satisfies: V ( , j) + cost(tj ) ≤ 2cost(A∗ ) PROOF.",
                "Let V ( , j) be the value returned by Greedy( , j) and let V ∗ ( , j) be an optimal solution for iKnapsack( , j).",
                "Consider the set Skip at the termination of Greedy( , j).",
                "There are two cases to consider: either some tuple t ∈ Skip is also in V ∗ ( , j), or no tuple in Skip is in V ∗ ( , j).",
                "In the first case, let St be the tentative solution S at the time t was added to Skip.",
                "Because t ∈ Skip then size(t) > R, and St together with t forms a feasible solution, and we have: V ( , j) ≤ cost(Best) ≤ cost(St) + cost(t).",
                "Again, because t ∈ Skip then cost(t) > cost(St), and we have V ( , j) < 2cost(t).",
                "On the other hand, since t is included in V ∗ ( , j), we have V ∗ ( , j) ≥ cost(t).",
                "These two inequalities imply the desired bound: V ∗ ( , j) ≤ V ( , j) < 2V ∗ ( , j).",
                "In the second case, imagine a modified instance of iKnapsack( , j), which excludes all the tuples of the set Skip.",
                "Since none of these tuples were included in V ∗ ( , j), the optimal solution for the modified problem should be the same as the one for the original.",
                "Suppose our approximation algorithm returns the value V ( , j) for this modified instance.",
                "Let t be the last tuple considered by the approximation algorithm before termination on the modified instance, and let St be the corresponding tentative solution set in that step.",
                "Since we consider tuples in order of increasing per unit price, and none of the tuples are going to be placed in the set Skip, we must have cost(St ) < V ∗ ( , j) because St is the optimal way to obtain size(St ).",
                "We also have cost(t ) ≤ cost(St ), and the following inequalities: V ( , j) ≤ V ( , j) ≤ cost(St ) + cost(t ) < 2V ∗ ( , j) The inequality V ( , j) ≤ V ( , j) follows from the fact that a tuple in the Skip list can only affect the Best but not the tentative solutions.",
                "Therefore, dropping the tuples in the set Skip can only make the solution worse.",
                "The above argument has shown that the value returned by Greedy( , j) is within a factor 2 of the optimal solution for iKnapsack( , j).",
                "We now show that the value V ( , j) plus cost(tj ) is a 2-approximation of the original generalized knapsack problem.",
                "Let A∗ be an optimal solution of the generalized knapsack, and suppose that element xj is midrange.",
                "Let x− to be set of the remaining elements, either zero or anchors, in this solution.",
                "Furthermore, define x = xj − uj .",
                "Thus, cost(A∗ ) = cost(xl) + cost(tj l ) + cost(x−l) It is easy to see that (x− , x ) is an optimal solution for iKnapsack( , j).",
                "Since V ( , j) is a 2-approximation for this optimal solution, we have the following inequalities: V ( , j) + cost(tj ) ≤ cost(tj ) + 2(cost(x ) + cost(x− )) ≤ 2(cost(x ) + cost(tj ) + cost(x− )) ≤ 2cost(A∗ ) This completes the proof of Lemma 2.",
                "It is easy to see that, after an initial sorting of the tuples in U, the algorithm Greedy( , j) takes O(n) time.",
                "We have our first polynomial approximation algorithm.",
                "THEOREM 2.",
                "A 2-approximation of the generalized knapsack problem can be found in time O(n2 ), where n is number of item lists (each of constant length).",
                "PROOF.",
                "We run the algorithm Greedy( , j) once for each tuple (l, j) as a candidate for midrange.",
                "There are O(n) tuples, and it suffices to sort them once, the total cost of the algorithm is O(n2 ).",
                "By Lemma 1, there is an optimal solution with at most one midrange element, so our algorithm will find a 2-approximation, as claimed.",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time is O((nc)2 ). 171 3.3 An Approximation Scheme We now use the 2-approximation algorithm presented in the preceding section to develop a fully polynomial approximation (FPTAS) for the generalized knapsack problem.",
                "The high level idea is fairly standard, but the details require technical care.",
                "We use a dynamic programming algorithm to solve iKnapsack( , j) for each possible midrange element, with the 2-approximation algorithm providing an upper bound on the value of the solution and enabling the use of scaling on the cost dimension of the dynamic programming (DP) table.",
                "Consider, for example, the case that the midrange element is x , which falls in the range [uj , uj+1 ).",
                "In our FPTAS, rather than using a greedy approximation algorithm to solve iKnapsack( , j), we construct a dynamic programming table to compute the minimum cost at which at least M − uj+1 units can be obtained using the remaining n − 1 lists in the generalized knapsack.",
                "Suppose G[i, r] denotes the maximum number of units that can be obtained at cost at most r using only the first i lists in the generalized knapsack.",
                "Then, the following recurrence relation describes how to construct the dynamic programming table: G[0, r] = 0 G[i, r] = max ´ G[i − 1, r] max j∈β(i,r) {G[i − 1, r − cost(tj i )] + uj i } µ where β(i, r) = {j : 1 ≤ j ≤ mi, cost(tj i ) ≤ r}, is the set of anchors for agent i.",
                "As convention, agent i will index the row, and cost r will index the column.",
                "This dynamic programming algorithm is only pseudo-polynomial, since the number of column in the dynamic programming table depends upon the total cost.",
                "However, we can convert it into a FPTAS by scaling the cost dimension.",
                "Let A denote the 2-approximation to the generalized knapsack problem, with total cost, cost(A).",
                "Let ε denote the desired approximation factor.",
                "We compute the scaled cost of a tuple tj i , denoted scost(tj i ), as scost(tj i ) = n cost(tj i ) εcost(A) (2) This scaling improves the running time of the algorithm because the number of columns in the modified table is at most n ε , and independent of the total cost.",
                "However, the computed solution might not be an optimal solution for the original problem.",
                "We show that the error introduced is within a factor of ε of the optimal solution.",
                "As a prelude to our approximation guarantee, we first show that if two different solutions to the iKnapsack problem have equal scaled cost, then their original (unscaled) costs cannot differ by more than εcost(A).",
                "LEMMA 3.",
                "Let x and y be two distinct feasible solutions of iKnapsack( , j), excluding their midrange elements.",
                "If x and y have equal scaled costs, then their unscaled costs cannot differ by more than εcost(A).",
                "PROOF.",
                "Let Ix and Iy, respectively, denote the indicator functions associated with the anchor vectors x and y-there is 1 in position Ix[i, k] if the xk i > 0.",
                "Since x and y has equal scaled cost, i= k scost(tk i )Ix[i, k] = i= k scost(tk i )Iy[i, k] (3) However, by (2), the scaled costs satisfy the following inequalities: (scost(tk i ) − 1)εcost(A) n ≤ cost(tk i ) ≤ scost(tk i )εcost(A) n (4) Substituting the upper-bound on scaled cost from (4) for cost(x), the lower-bound on scaled cost from (4) for cost(y), and using equality (3) to simplify, we have: cost(x) − cost(y) ≤ εcost(A) n i= k Iy[i, k] ≤ εcost(A), The last inequality uses the fact that at most n components of an indicator vector are non-zero; that is, any feasible solution contains at most n tuples.",
                "Finally, given the dynamic programming table for iKnapsack( , j), we consider all the entries in the last row of this table, G[n−1, r].",
                "These entries correspond to optimal solutions with all agents except l, for different levels of cost.",
                "In particular, we consider the entries that provide at least M − uj+1 units.",
                "Together with a contribution from agent l, we choose the entry in this set that minimizes the total cost, defined as follows: cost(G[n − 1, r]) + max {uj , M − G[n − 1, r]}pj , where cost() is the original, unscaled cost associated with entry G[n−1, r].",
                "It is worth noting, that unlike the 2-approximation scheme for iKnapsack( , j), the value computed with this FPTAS includes the cost to acquire uj l units from l. The following lemma shows that we achieve a (1+ε)-approximation.",
                "LEMMA 4.",
                "Suppose A∗ is an optimal solution of the generalized knapsack problem, and suppose that element (l, j) is midrange in the optimal solution.",
                "Then, the solution A(l, j) from running the scaled dynamic-programming algorithm on iKnapsack( , j) satisfies cost(A(l, j)) ≤ (1 + 2ε)cost(A∗ ) PROOF.",
                "Let x− denote the vector of the elements in solution A∗ without element l. Then, by definition, cost(A∗ ) = cost(x− ) + pj xj .",
                "Let r = scost(x− ) be the scaled cost associated with the vector x− .",
                "Now consider the dynamic programming table constructed for iKnapsack( , j), and consider its entry G[n − 1, r].",
                "Let A denote the 2-approximation to the generalized knapsack problem, and A(l, j) denote the solution from the dynamic-programming algorithm.",
                "Suppose y− is the solution associated with this entry in our dynamic program; the components of the vector y− are the quantities from different lists.",
                "Since both x− and y− have equal scaled costs, by Lemma 3, their unscaled costs are within εcost(A) of each other; that is, cost(y− ) − cost(x− ) ≤ εcost(A).",
                "Now, define yj = max{uj , M − Èi= Èj yj i }; this is the contribution needed from to make (y− , yj ) a feasible solution.",
                "Among all the equal cost solutions, our dynamic programming tables chooses the one with maximum units.",
                "Therefore, i= j yj i ≥ i= j xj i 172 Therefore, it must be the case that yj ≤ xj .",
                "Because (yj , y− ) is also a feasible solution, if our algorithm returns a solution with cost cost(A(l, j)), then we must have cost(A(l, j)) ≤ cost(y− ) + pj yj ≤ cost(x− ) + εcost(A) + pj xj ≤ (1 + 2ε)cost(A∗ ), where we use the fact that cost(A) ≤ 2cost(A∗ ).",
                "Putting this together, our approximation scheme for the generalized knapsack problem will iterate the scheme described above for each choice of the midrange element (l, j), and choose the best solution from among these O(n) solutions.",
                "For a given midrange, the most expensive step in the algorithm is the construction of dynamic programming table, which can be done in O(n2 /ε) time assuming constant intervals per list.",
                "Thus, we have the following result.",
                "THEOREM 3.",
                "We can compute an (1 + ε) approximation to the solution of a generalized knapsack problem in worst-case time O(n3 /ε).",
                "The dependence on the number of pieces is also polynomial: if each bid has a maximum of c pieces, then the running time can be derived by substituting cn for each occurrence of n. 4.",
                "COMPUTING VCG PAYMENTS We now consider the related problem of computing the VCG payments for all the agents.",
                "A naive approach requires solving the allocation problem n times, removing each agent in turn.",
                "In this section, we show that our approximation scheme for the generalized knapsack can be extended to determine all n payments in total time O(αT log(αn/ε)), where 1 ≤ C(I\\i)/C(I) ≤ α, for a constant upper bound, α, and T is the complexity of solving the allocation problem once.",
                "This α-bound can be justified as a no monopoly condition, because it bounds the marginal value that a single buyer brings to the auction.",
                "Similarly, in the reverse variation we can compute the VCG payments to each seller in time O(αT log(αn/ε)), where α bounds the ratio C(I\\ i)/C(I) for all i.",
                "Our overall strategy will be to build two dynamic programming tables, forward and backward, for each midrange element (l, j) once.",
                "The forward table is built by considering the agents in the order of their indices, where as the backward table is built by considering them in the reverse order.",
                "The optimal solution corresponding to C(I \\ i) can be broken into two parts: one corresponding to first (i − 1) agents and the other corresponding to last (n − i) agents.",
                "As the (i − 1)th row of the forward table corresponds to the sellers with first (i−1) indices, an approximation to the first part will be contained in (i − 1)th row of the forward table.",
                "Similarly, (n− i)th row of the backward table will contain an approximation for the second part.",
                "We first present a simple but an inefficient way of computing the approximate value of C(I \\ i), which illustrates the main idea of our algorithm.",
                "Then we present an improved scheme, which uses the fact that the elements in the rows are sorted, to compute the approximate value more efficiently.",
                "In the following, we concentrate on computing an allocation with xj being midrange, and some agent i = l removed.",
                "This will be a component in computing an approximation to C(I \\ i), the value of the solution to the generalized knapsack without bids from agent i.",
                "We begin with the simple scheme. 4.1 A Simple Approximation Scheme We implement the scaled dynamic programming algorithm for iKnapsack( , j) with two alternate orderings over the other sellers, k = l, one with sellers ordered 1, 2, . . . , n, and one with sellers ordered n, n − 1, . . . , 1.",
                "We call the first table the forward table, and denote it F , and the second table the backward table, and denote it Bl.",
                "The subscript reminds us that the agent is midrange.9 In building these tables, we use the same scaling factor as before; namely, the cost of a tuple tj i is scaled as follows: scost(tj i ) = ncost(tj i ) εcost(A) where cost(A) is the upper bound on C(I), given by our 2approximation scheme.",
                "In this case, because C(I \\ i) can be α times C(I), the scaled value of C(I \\ i) can be at most nα/ε.",
                "Therefore, the cost dimension of our dynamic programs table will be nα/ε.",
                "FlTable F (i−1)l 2 3 1 2 i−1 1 m−1 m n−1 g 2 31 m−1 m B (n−i) n−1 n−2 n−i 1 lh Table Bl Figure 3: Computing VCG payments. m = nα ε Now, suppose we want to compute a (1 + )-approximation to the generalized knapsack problem restricted to element (l, j) midrange, and further restricted to remove bids from some seller i = l. Call this problem iKnapsack−i ( , j).",
                "Recall that the ith row of our DP table stores the best solution possible using only the first i agents excluding agent l, all of them either cleared at zero, or on anchors.",
                "These first i agents are a different subset of agents in the forward and the backward tables.",
                "By carefully combining one row of Fl with one row of Bl we can compute an approximation to iKnapsack−i ( , j).",
                "We consider the row of Fl that corresponds to solutions constructed from agents {1, 2, . . . , i − 1}, skipping agent l. We consider the row of Bl that corresponds to solutions constructed from agents {i+1, i+2, . . . , n}, again skipping agent l. The rows are labeled Fl(i − 1) and Bl(n − i) respectively.10 The scaled costs for acquiring these units are the column indices for these entries.",
                "To solve iKnapsack−i ( , j) we choose one entry from row F (i−1) and one from row B (n−i) such that their total quantity exceeds M − uj+1 and their combined cost is minimum over all such combinations.",
                "Formally, let g ∈ Fl(i − 1), and h ∈ Bl(n − 1) denote entries in each row, with size(g), size(h), denoting the number of units and cost(g) and cost(h) denoting the unscaled cost associated with the entry.",
                "We compute the following, subject 9 We could label the tables with both and j, to indicate the jth tuple is forced to be midrange, but omit j to avoid clutter. 10 To be precise, the index of the rows are (i − 2) and (n − i) for Fl and Bl when l < i, and (i − 1) and (n − i − 1), respectively, when l > i. 173 to the condition that g and h satisfy size(g) + size(h) > M − uj+1 : min g∈F (i−1),h∈B (n−i) Òcost(g) + cost(h) + pj · max{uj , M − size(g) − size(h)} Ó (5) LEMMA 5.",
                "Suppose A−i is an optimal solution of the generalized knapsack problem without bids from agent i, and suppose that element (l, j) is the midrange element in the optimal solution.",
                "Then, the expression in Eq. 5, for the restricted problem iKnapsack−i ( , j), computes a (1 + ε)-approximation to A−i .",
                "PROOF.",
                "From earlier, we define cost(A−i ) = C(I \\ i).",
                "We can split the optimal solution, A−i , into three disjoint parts: xl corresponds to the midrange seller, xi corresponds to first i − 1 sellers (skipping agent l if l < i), and x−i corresponds to last n − i sellers (skipping agent l if l > i).",
                "We have: cost(A−i ) = cost(xi) + cost(x−i) + pj xj Let ri = scost(xi) and r−i = scost(x−i).",
                "Let yi and y−i be the solution vectors corresponding to scaled cost ri and r−i in F (i − 1) and B (n − i), respectively.",
                "From Lemma 3 we conclude that, cost(yi) + cost(y−i) − cost(xi) − cost(x−i) ≤ εcost(A) where cost(A) is the upper-bound on C(I) computed with the 2-approximation.",
                "Among all equal scaled cost solutions, our dynamic program chooses the one with maximum units.",
                "Therefore we also have, (size(yi) ≥ size(xi)) and (size(y−i) ≥ size(x−i)) where we use shorthand size(x) to denote total number of units in all tuples in x.",
                "Now, define yj l = max(uj l , M −size(yi)−size(y−i)).",
                "From the preceding inequalities, we have yj l ≤ xj l .",
                "Since (yj l , yi, y−i) is also a feasible solution to the generalized knapsack problem without agent i, the value returned by Eq. 5 is at most cost(yi) + cost(y−i) + pj l yj l ≤ C(I \\ i) + εcost(A) ≤ C(I \\ i) + 2cost(A∗ )ε ≤ C(I \\ i) + 2C(I \\ i)ε This completes the proof.",
                "A naive implementation of this scheme will be inefficient because it might check (nα/ε)2 pairs of elements, for any particular choice of (l, j) and choice of dropped agent i.",
                "In the next section, we present an efficient way to compute Eq. 5, and eventually to compute the VCG payments. 4.2 Improved Approximation Scheme Our improved approximation scheme for the winner-determination problem without agent i uses the fact that elements in F (i − 1) and B (n − i) are sorted; specifically, both, unscaled cost and quantity (i.e. size), increases from left to right.",
                "As before, let g and h denote generic entries in F (i − 1) and B (n − i) respectively.",
                "To compute Eq. 5, we consider all the tuple pairs, and first divide the tuples that satisfy condition size(g) + size(h) > M − uj+1 l into two disjoint sets.",
                "For each set we compute the best solution, and then take the best between the two sets. [case I: size(g) + size(h) ≥ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l uj Ó (6) We define a pair (g, h) to be feasible if size(g) + size(h) ≥ M − uj l .",
                "Now to compute Eq. 6, we do a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We start from the smallest index of F (i − 1) and move right, and from the highest index of B (n − i) and move left.",
                "Let (g, h) be the current pair.",
                "If (g, h) is feasible, we decrement Bs pointer (that is, move backward) otherwise we increment Fs pointer.",
                "The feasible pairs found during the walk are used to compute Eq. 6.",
                "The complexity of this step is linear in size of F (i − 1), which is O(nα/ε). [case II: M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l ] The problem reduces to min g∈F (i−1), h∈B (n−i) Òcost(g) + cost(h) + pj l (M − size(g) − size(h)) Ó To compute the above equation, we transform the above problem to another problem using modified cost, which is defined as: mcost(g) = cost(g) − pj l · size(g) mcost(h) = cost(h) − pj l · size(h) The new problem is to compute min g∈F (i−1), h∈B (n−i) Òmcost(g) + mcost(h) + pj l M Ó (7) The modified cost simplifies the problem, but unfortunately the elements in F (i − 1) and B (n − i) are no longer sorted with respect to mcost.",
                "However, the elements are still sorted in quantity and we use this property to compute Eq. 7.",
                "Call a pair (g, h) feasible if M − uj+1 l ≤ size(g) + size(h) ≤ M − uj l .",
                "Define the feasible set of g as the elements h ∈ B (n − i) that are feasible given g. As the elements are sorted by quantity, the feasible set of g is a contiguous subset of B (n − i) and shifts left as g increases. 2 3 4 5 10 20 30 40 50 60 Begin End B (n−i)15 20 25 30 35 40 65421 3 1 6 F (i−1)l l Figure 4: The feasible set of g = 3, defined on B (n − i), is {2, 3, 4} when M − uj+1 l = 50 and M − uj l = 60.",
                "Begin and End represent the start and end pointers to the feasible set.",
                "Therefore, we can compute Eq. 7 by doing a forward and backward walk on F (i − 1) and B (n − i) respectively.",
                "We walk on B (n − i), starting from the highest index, using two pointers, Begin and End, to indicate the start and end of the current feasible set.",
                "We maintain the feasible set as a min heap, where the key is modified cost.",
                "To update the feasible set, when we increment Fs pointer(move forward), we walk left on B, first using End to remove elements from feasible set which are no longer 174 feasible and then using Begin to add new feasible elements.",
                "For a given g, the only element which we need to consider in gs feasible set is the one with minimum modified cost which can be computed in constant time with the min heap.",
                "So, the main complexity of the computation lies in heap updates.",
                "Since, any element is added or deleted at most once, there are O(nα ε ) heap updates and the time complexity of this step is O(nα ε log nα ε ). 4.3 Collecting the Pieces The algorithm works as follows.",
                "First, using the 2 approximation algorithm, we compute an upper bound on C(I).",
                "We use this bound to scale down the tuple costs.",
                "Using the scaled costs, we build the forward and backward tables corresponding to each tuple (l, j).",
                "The forward tables are used to compute C(I).",
                "To compute C(I \\ i), we iterate over all the possible midrange tuples and use the corresponding forward and backward tables to compute the locally optimal solution using the above scheme.",
                "Among all the locally optimal solutions we choose one with the minimum total cost.",
                "The most expensive step in the algorithm is computation of C(I \\ i).",
                "The time complexity of this step is O(n2 α ε log nα ε ) as we have to iterate over all O(n) choices of tj l , for all l = i, and each time use the above scheme to compute Eq. 5.",
                "In the worst case, we might need to compute C(I \\ i) for all n sellers, in which case the final complexity of the algorithm will be O(n3 α ε log nα ε ).",
                "THEOREM 4.",
                "We can compute an /(1+ )-<br>strategyproof</br> approximation to the VCG mechanism in the forward and reverse multi-unit auctions in worst-case time O(n3 α ε log nα ε ).",
                "It is interesting to recall that T = O(n3 ε ) is the time complexity of the FPTAS to the generalized knapsack problem with all agents.",
                "Our combined scheme computes an approximation to the complete VCG mechanism, including payments to O(n) agents, in time complexity O(T log(n/ε)), taking the no-monopoly parameter, α, as a constant.",
                "Thus, our algorithm performs much better than the naive scheme, which computes the VCG payment for each agent by solving a new instance of generalized knapsack problem.",
                "The speed up comes from the way we solve iKnapsack−i ( , j).",
                "Time complexity of computing iKnapsack−i ( , j) by creating a new dynamic programming table will be O(n2 ε ) but by using the forward and backward tables, the complexity is reduced to O(n ε log n ε ).",
                "We can further improve the time complexity of our algorithm by computing Eq. 5 more efficiently.",
                "Currently, the algorithm uses heap, which has logarithmic update time.",
                "In worst case, we can have two heap update operations for each element, which makes the time complexity super linear.",
                "If we can compute Eq. 5 in linear time then the complexity of computing the VCG payment will be same as the complexity of solving a single generalized knapsack problem. 5.",
                "CONCLUSIONS We presented a fully polynomial-time approximation scheme for the single-good multi-unit auction problem, using marginal decreasing piecewise constant bidding language.",
                "Our scheme is both approximately efficient and approximately <br>strategyproof</br> within any specified factor ε > 0.",
                "As such it is an example of computationally tractable ε-dominance result, as well as an example of a non-trivial but approximable allocation problem.",
                "It is particularly interesting that we are able to compute the payments to n agents in a VCG-based mechanism in worst-case time O(T log n), where T is the time complexity to compute the solution to a single allocation problem. 6.",
                "REFERENCES [1] L M Ausubel and P R Milgrom.",
                "Ascending auctions with package bidding.",
                "Frontiers of Theoretical Economics, 1:1-42, 2002. [2] S Bikchandani, S de Vries, J Schummer, and R V Vohra.",
                "Linear programming and Vickrey auctions.",
                "Technical report, Anderson Graduate School of Management, U.C.L.A., 2001. [3] S Bikchandani and J M Ostroy.",
                "The package assignment model.",
                "Journal of Economic Theory, 2002.",
                "Forthcoming. [4] K Chatterjee and W Samuelson.",
                "Bargaining under incomplete information.",
                "Operations Research, 31:835-851, 1983. [5] E H Clarke.",
                "Multipart pricing of public goods.",
                "Public Choice, 11:17-33, 1971. [6] S de Vries and R V Vohra.",
                "Combinatorial auctions: A survey.",
                "Informs Journal on Computing, 2002.",
                "Forthcoming. [7] M Eso, S Ghosh, J R Kalagnanam, and L Ladanyi.",
                "Bid evaluation in procurement auctions with piece-wise linear supply curves.",
                "Technical report, IBM TJ Watson Research Center, 2001. in preparation. [8] J Feigenbaum and S Shenker.",
                "Distributed Algorithmic Mechanism Design: Recent Results and Future Directions.",
                "In Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, pages 1-13, 2002. [9] M R Garey and D S Johnson.",
                "Computers and Intractability: A Guide to the Theory of NP-Completeness.",
                "W.H.Freeman and Company, New York, 1979. [10] G V Gens and E V Levner.",
                "Computational complexity of approximation algorithms for combinatorial problems.",
                "In Mathematical Foundation of Computer Science, 292-300, 1979. [11] T Groves.",
                "Incentives in teams.",
                "Econometrica, 41:617-631, 1973. [12] J R Kalagnanam, A J Davenport, and H S Lee.",
                "Computational aspects of clearing continuous call double auctions with assignment constraints and indivisible demand.",
                "Electronic Commerce Journal, 1(3):221-238, 2001. [13] V Krishna.",
                "Auction Theory.",
                "Academic Press, 2002. [14] V Krishna and M Perry.",
                "Efficient mechanism design.",
                "Technical report, Pennsylvania State University, 1998.",
                "Available at: http://econ.la.psu.edu/˜vkrishna/vcg18.ps. [15] D Lehmann, L I OCallaghan, and Y Shoham.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "JACM, 49(5):577-602, September 2002. [16] R B Myerson.",
                "Optimal auction design.",
                "Mathematics of Operation Research, 6:58-73, 1981. [17] R B Myerson and M A Satterthwaite.",
                "Efficient mechanisms for bilateral trading.",
                "Journal of Economic Theory, 28:265-281, 1983. [18] N Nisan and A Ronen.",
                "Computationally feasible VCG mechanisms.",
                "In ACM-EC, pages 242-252, 2000. [19] D C Parkes, J R Kalagnanam, and M Eso.",
                "Achieving budget-balance with Vickrey-based payment schemes in exchanges.",
                "In IJCAI, 2001. [20] M H Rothkopf, A Pekeˇc, and R M Harstad.",
                "Computationally manageable combinatorial auctions.",
                "Management Science, 44(8):1131-1147, 1998. [21] J Schummer.",
                "Almost dominant strategy implementation.",
                "Technical report, MEDS Department, Kellogg Graduate School of Management, 2001. [22] W Vickrey.",
                "Counterspeculation, auctions, and competitive sealed tenders.",
                "Journal of Finance, 16:8-37, 1961. 175"
            ],
            "original_annotated_samples": [
                "Approximately-<br>strategyproof</br> and Tractable Multi-Unit Auctions Anshul Kothari∗ David C. Parkes† Subhash Suri∗ ABSTRACT We present an approximately-efficient and approximatelystrategyproof auction mechanism for a single-good multi-unit allocation problem.",
                "Our scheme is both approximately efficient and approximately <br>strategyproof</br>.",
                "The approximate VCG mechanism is ( ε 1+ε )-<br>strategyproof</br> for an approximation to within (1 + ) of the optimal allocation.",
                "For instance, Lehmann et al. [15] propose a greedy and <br>strategyproof</br> approximation to a single-minded combinatorial auction problem.",
                "APPROXIMATELY-<br>strategyproof</br> VCG AUCTIONS In this section, we first describe the marginal-decreasing piecewise bidding language that is used in our forward and reverse auctions."
            ],
            "translated_annotated_samples": [
                "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente <br>a prueba de estrategias</br> para un problema de asignación multiunidad de un solo bien.",
                "Nuestro esquema es tanto aproximadamente eficiente como aproximadamente <br>a prueba de estrategias</br>.",
                "El mecanismo VCG aproximado es ( ε 1+ε )-<br>estrategia-veraz</br> para una aproximación dentro de (1 + ) de la asignación óptima.",
                "Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y <br>a prueba de estrategias</br> para un problema de subasta combinatoria de un solo interesado.",
                "En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente <br>a prueba de estrategias</br> VCG."
            ],
            "translated_text": "Presentamos un mecanismo de subasta aproximadamente eficiente y aproximadamente <br>a prueba de estrategias</br> para un problema de asignación multiunidad de un solo bien. El lenguaje de oferta en nuestras subastas permite curvas constantes por tramos con disminución marginal. Primero, desarrollamos un esquema de aproximación de tiempo polinómico completo para el problema de asignación de múltiples unidades, que calcula una aproximación de (1 + ) en tiempo de peor caso T = O(n3 / ), dado n ofertas cada una con un número constante de piezas. Segundo, incrustamos este esquema de aproximación dentro de un mecanismo de Vickrey-Clarke-Groves (VCG) y calculamos los pagos a n agentes por un costo asintótico de O(T log n). La ganancia máxima posible de la manipulación para un postor en el esquema combinado está limitada por /(1+ )V, donde V es el excedente total en el resultado eficiente. Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento-Economía. Términos generales Algoritmos, Economía. 1. En este documento presentamos un esquema de aproximación de tiempo polinómico completo para el problema de subasta multiunidad de un solo bien. Nuestro esquema es tanto aproximadamente eficiente como aproximadamente <br>a prueba de estrategias</br>. Las configuraciones de subasta consideradas en nuestro artículo están motivadas por las tendencias recientes en el comercio electrónico; por ejemplo, las corporaciones están utilizando cada vez más subastas para sus adquisiciones estratégicas. Consideramos tanto una variación de subasta inversa como una variación de subasta directa, y proponemos un lenguaje de oferta compacto y expresivo que permite curvas constantes por tramos con disminución marginal. En la subasta inversa, consideramos un único comprador con una demanda de M unidades de un bien y n proveedores, cada uno con una función de coste marginal decreciente y constante por tramos. Además, cada proveedor también puede expresar un límite superior, o restricción de capacidad, sobre la cantidad de unidades que puede suministrar. Los modelos de variación inversa, por ejemplo, representan una subasta de adquisiciones para obtener materias primas u otros servicios (por ejemplo, placas de circuito, fuentes de alimentación, cartuchos de tóner), con lotes de tamaño flexible. En la subasta ascendente, consideramos un único vendedor con M unidades de un bien y n compradores, cada uno con una función de valoración marginal decreciente y constante por tramos. Un comprador también puede expresar un límite inferior, o tamaño mínimo de lote, en la cantidad de unidades que demanda. Los modelos de variación hacia adelante, por ejemplo, simulan una subasta para vender inventario excedente en lotes de tamaño flexible. Consideramos la complejidad computacional de implementar el mecanismo de Vickrey-Clarke-Groves [22, 5, 11] para el problema de la subasta de unidades múltiples. El mecanismo de Vickrey-Clarke-Groves (VCG) tiene varias propiedades económicas interesantes en este contexto, incluyendo la a prueba de estrategias, de modo que hacer ofertas veraces es una estrategia dominante para los compradores en la subasta ascendente y para los vendedores en la subasta descendente, y la eficiencia asignativa, de modo que el resultado maximiza el excedente total en el sistema. Sin embargo, como discutimos en la Sección 2, la aplicación del enfoque basado en VCG está limitada en la dirección inversa a casos en los que los pagos totales a los vendedores son menores que el valor del resultado para el comprador. De lo contrario, la subasta debe operar con pérdidas en estos casos, o no se puede esperar que el comprador elija participar voluntariamente. Este es un ejemplo del problema del déficit presupuestario que a menudo ocurre en el diseño eficiente de mecanismos [17]. El problema computacional es interesante, porque incluso con curvas de oferta marginal decrecientes, el problema de asignación subyacente resulta ser (débilmente) intratable. Por ejemplo, la clásica mochila 0/1 es un caso especial de este problema. Modelamos el problema como una generalización novedosa e interesante del problema clásico de la mochila, y desarrollamos un esquema de aproximación de tiempo polinómico completo, calculando una aproximación (1 + ε) en tiempo de peor caso T = O(n3 /ε), donde cada oferta tiene un número fijo de piezas constantes por tramos. Dado este esquema, un cálculo directo de los pagos VCG a todos los n agentes requiere un tiempo O(nT). Calculamos pagos VCG aproximados en tiempo de peor caso O(αT log(αn/ε)), donde α es una constante que cuantifica una suposición razonable de no monopolio. Específicamente, en la subasta inversa, supongamos que C(I) es el costo mínimo para adquirir M unidades con todos los vendedores I, y C(I \\ i) es el costo mínimo sin el vendedor i. Entonces, la constante α se define como una cota superior para la razón C(I \\i)/C(I), sobre todos los vendedores i. Este límite superior tiende a 1 a medida que aumenta el número de vendedores. El mecanismo VCG aproximado es ( ε 1+ε )-<br>estrategia-veraz</br> para una aproximación dentro de (1 + ) de la asignación óptima. Esto significa que un postor puede obtener como máximo ( ε 1+ε )V de una oferta no veraz, donde V es el excedente total de la asignación eficiente. Por lo tanto, este es un ejemplo de un resultado de dominancia ε computacionalmente viable. En la práctica, podemos tener la seguridad de que los postores sin buena información sobre las estrategias de oferta de otros participantes tendrán poco que ganar con intentos de manipulación. La sección 2 define de manera formal las subastas directas e inversas, y define los mecanismos VCG. También demostramos nuestras afirmaciones sobre la ε-estrategia de prueba. La Sección 3 proporciona la formulación generalizada de la mochila para los problemas de asignación de múltiples unidades e introduce el esquema de aproximación de tiempo polinómico completo. La sección 4 define el esquema de aproximación para los pagos en el mecanismo VCG. La Sección 5 concluye. 1.1 Trabajo Relacionado Ha habido un considerable interés en los últimos años en caracterizar casos especiales del problema general de asignación combinatoria que pueden resolverse en tiempo polinómico o aproximarse, en los cuales hay múltiples elementos diferentes. El problema de asignación combinatoria (CAP) es tanto NP-completo como intratable (por ejemplo, [6]). Aunque se han identificado algunos casos de tiempo polinómico para el CAP [6, 20], la introducción de un lenguaje de oferta exclusiva-o expresivo rápidamente rompe estos casos especiales. Identificamos un problema de asignación no trivial pero aproximable con un lenguaje de oferta exclusivo expresivo: el receptor de la oferta en nuestro escenario puede aceptar como máximo un punto en la curva de oferta. La idea de utilizar aproximaciones dentro de los mecanismos, manteniendo ya sea la plena estrategia de prueba o la ε-dominancia, ha recibido cierta atención previa. Por ejemplo, Lehmann et al. [15] proponen una aproximación codiciosa y <br>a prueba de estrategias</br> para un problema de subasta combinatoria de un solo interesado. Nisan & Ronen [18] discutieron mecanismos aproximados basados en VCG, pero recurrieron a aproximaciones particulares de rango máximo para conservar la plena estrategia-proofness, o a agentes con recursos limitados con limitaciones de información o computacionales en la capacidad de calcular estrategias. Restricciones de tamaño mínimo de lote de Feigenbaum por parte de los compradores. Sin embargo, esto puede no ser un ejemplo de lo que Feigenbaum & Shenker se refieren como un mecanismo tolerablemente manipulable, ya que no hemos intentado limitar el efecto de dicha manipulación en la eficiencia del resultado. El mecanismo VCG sí tiene una propiedad auto-correctora natural, ya que una manipulación útil para un agente es un valor reportado que mejora el valor total de la asignación basado en los reportes de otros agentes y el valor propio del agente. Baum & Shenker [8] han definido el concepto de aproximaciones estratégicamente fieles, y propuesto el estudio de aproximaciones como una dirección importante para el diseño de mecanismos algorítmicos. Schummer [21] y Parkes et al [19] han considerado previamente la ε-dominancia, en el contexto de resultados de imposibilidad económica, por ejemplo en intercambios combinatorios. Eso et al. [7] han estudiado un problema de adquisiciones similar, pero para un modelo de descuento por volumen diferente. Este trabajo anterior formula el problema como un programa lineal entero mixto general y proporciona algunos resultados empíricos sobre datos simulados. Kalagnanam et al. [12] abordan subastas dobles, donde múltiples compradores y vendedores intercambian un bien divisible. El enfoque de este artículo también es diferente: investiga los precios de equilibrio utilizando las curvas de oferta y demanda, mientras que nuestro enfoque se centra en el diseño de mecanismos eficientes. Ausubel ha propuesto una subasta de múltiples unidades con precios ascendentes para compradores con valores marginales decrecientes, con una interpretación como algoritmo primal-dual. En esta sección, primero describimos el lenguaje de oferta por tramos decrecientes marginales que se utiliza en nuestras subastas hacia adelante y hacia atrás, que son aproximadamente <br>a prueba de estrategias</br> VCG. ",
            "candidates": [],
            "error": [
                [
                    "a prueba de estrategias",
                    "a prueba de estrategias",
                    "estrategia-veraz",
                    "a prueba de estrategias",
                    "a prueba de estrategias"
                ]
            ]
        }
    }
}